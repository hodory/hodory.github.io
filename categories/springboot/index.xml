<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>SpringBoot - Category - Web Developer Hodory</title><link>http://blog.hodory.dev/categories/springboot/</link><description>SpringBoot - Category - Web Developer Hodory</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Wed, 10 Aug 2022 23:04:49 +0000</lastBuildDate><atom:link href="http://blog.hodory.dev/categories/springboot/" rel="self" type="application/rss+xml"/><item><title>[Java] Spring AOP 에서 Custom Exception 사용하기</title><link>http://blog.hodory.dev/2022/08/10/java-spring-aop-%EC%97%90%EC%84%9C-custom-exception-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 10 Aug 2022 23:04:49 +0000</pubDate><author>hodory</author><guid>http://blog.hodory.dev/2022/08/10/java-spring-aop-%EC%97%90%EC%84%9C-custom-exception-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid><description>Spring AOP에서 Custom Exception 사용하기 Spring AOP는 CglibAopProxy 클래스를 이용하여 동작합니다.
아래 코드와 같이 super.process() 를 try-catch로 처리하고 있고, Runtime Exception은 exception 을 그대로 던질 수 있기 때문에
Custom Exception은 Exception 클래스가 아니라 RuntimeException을 상속받아서 사용해야 합니다
@Override @Nullable public Object proceed() throws Throwable { try { return super.proceed(); } catch (RuntimeException ex) { throw ex; } catch (Exception ex) { if (ReflectionUtils.declaresException(getMethod(), ex.getClass()) || KotlinDetector.isKotlinType(getMethod().getDeclaringClass())) { // Propagate original exception if declared on the target method // (with callers expecting it).</description></item><item><title>［Java］Spring REST Docs HTML이 생성되지 않을때</title><link>http://blog.hodory.dev/2019/12/04/javaspring-rest-docs-html%EC%9D%B4-%EC%83%9D%EC%84%B1%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EB%95%8C/</link><pubDate>Wed, 04 Dec 2019 23:39:14 +0000</pubDate><author>hodory</author><guid>http://blog.hodory.dev/2019/12/04/javaspring-rest-docs-html%EC%9D%B4-%EC%83%9D%EC%84%B1%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%84%EB%95%8C/</guid><description><![CDATA[백기선님의 스프링부트 강좌를 수강하는중에 Spring REST Docs를 이용하여 HTML을 생성하려하는데, 아무리 빌드를 해도 ascii\html\index.html이 생성되지 않았습니다.
오후 11:58:18: Executing task &#39;build&#39;... &gt; Task :compileJava &gt; Task :processResources &gt; Task :classes &gt; Task :compileTestJava &gt; Task :processTestResources NO-SOURCE &gt; Task :testClasses &gt; Task :test 2019-12-02 23:58:35.629 INFO 24376 --- [ Thread-5] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &#39;applicationTaskExecutor&#39; 2019-12-02 23:58:35.629 INFO 24376 --- [ Thread-7] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService &#39;applicationTaskExecutor&#39; 2019-12-02 23:58:35.]]></description></item><item><title>［Java］해당 클래스의 서비스는 어디서 주입되나요??</title><link>http://blog.hodory.dev/2019/06/05/java%ED%95%B4%EB%8B%B9-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%94%94%EC%84%9C-%EC%A3%BC%EC%9E%85%EB%90%98%EB%82%98%EC%9A%94/</link><pubDate>Wed, 05 Jun 2019 11:40:37 +0000</pubDate><author>hodory</author><guid>http://blog.hodory.dev/2019/06/05/java%ED%95%B4%EB%8B%B9-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%8A%94-%EC%96%B4%EB%94%94%EC%84%9C-%EC%A3%BC%EC%9E%85%EB%90%98%EB%82%98%EC%9A%94/</guid><description>회사 업무중 스프링 서비스 코드 푸시를 하였습니다.
다른 팀원들에게
인터페이스를 파라미터로 정의한것은 확인하였는데, 혹시 해당 컨트롤러에 주입은 어디에서 되나요?`
라는 질문을 들었습니다.
@RestController @Slf4j @RequiredArgsConstructor public class YourController { private final YourService yourService; } 위와같이 컨트롤러가 선언되어있었습니다.(물론 예제입니다.)
해당 클래스의 yourService에 YourServiceImpl(인터페이스 구현체)는 어떻게 주입이 되는걸까요?
아직도 스프링의 Application Context에 의한 DI(의존성 주입)가 저는 이해하기 어려운것 같습니다.
인터페이스의 구현체가 Service 어노테이션을 사용해서 Application Context에 의해 관리되는 Bean으로 등록되면,
해당 인터페이스에 자동으로 주입이됩니다 (이 부분은 정말 신기하다고 생각합니다.</description></item><item><title>［Java］@JsonProperty이 왜 동작을 안하지?</title><link>http://blog.hodory.dev/2019/06/04/java@jsonproperty%EC%9D%B4-%EC%99%9C-%EB%8F%99%EC%9E%91%EC%9D%84-%EC%95%88%ED%95%98%EC%A7%80/</link><pubDate>Tue, 04 Jun 2019 23:13:03 +0000</pubDate><author>hodory</author><guid>http://blog.hodory.dev/2019/06/04/java@jsonproperty%EC%9D%B4-%EC%99%9C-%EB%8F%99%EC%9E%91%EC%9D%84-%EC%95%88%ED%95%98%EC%A7%80/</guid><description>class anonymousDTO { String whatYouWant; } 대부분 자바의 변수를 생성할때 위와 같이 CamelCase를 많이 쓰는것으로 알고있습니다&amp;hellip;..(본인이 잘못 생각하는것일 수 있습니다.)
필자 또한 위와 같이 camelCase를 사용하였으나 API 통신 및 응답을 리턴할때에는 hyphen uppercase가 필요했습니다.
위의 조건을 충족하기 위해 적절한 어노테이션을 찾았는데, @JsonProperty(&amp;quot;{WHAT_YOU_WANT}&amp;quot;)였습니다.
json으로 매핑할때 WHAT_YOU_WANT에 들어갈 값으로 해당 프로퍼티를 매핑하는것이였습니다.
테스트 코드를 작성하여 확인해보았지만 정상 동작하지 않아,
주위의 도움을 받았는데, getter메소드에 해당 어노테이션을 작성해야한다는 조언도 있었으며, compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind' 해당 라이브러리를 gradle에 추가하여 jackson 라이브러리를 최신화 할 필요가 있다는 조언을 받았습니다.</description></item><item><title>［Java］@AllArgsConstructor의 잘못된 사용</title><link>http://blog.hodory.dev/2019/05/28/java@allargsconstructor%EC%9D%98-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%82%AC%EC%9A%A9/</link><pubDate>Tue, 28 May 2019 23:29:30 +0000</pubDate><author>hodory</author><guid>http://blog.hodory.dev/2019/05/28/java@allargsconstructor%EC%9D%98-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%82%AC%EC%9A%A9/</guid><description><![CDATA[Consider defining a bean of type java.lang.String in your configuration. 스프링부트로 서비스를 개발중에 @Value 어노테이션을 이용하여 application.yml 파일에 저장해둔 환경변수에 접근하고 싶었는데, 아래와 같은 오류가 발생하였습니다.
Parameter 2 of constructor in com.hodory.v1.service.MyService required a bean of type &#39;java.lang.String&#39; that could not be found. Consider defining a bean of type &#39;java.lang.String&#39; in your configuration. Retrofit을 사용하기위해 apiBaseUrl을 가져오려 작성한 코드는 아래와 같습니다.
@Slf4j @Service @AllArgsConstructor public class MyService { private final MyRepository myRepository; private final ModelMapper modelMapper; @Value(&#34;${config.]]></description></item><item><title>［Java］스프링부트 회원 기존 비밀번호 체크하기</title><link>http://blog.hodory.dev/2019/05/14/java%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%9A%8C%EC%9B%90-%EA%B8%B0%EC%A1%B4-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0/</link><pubDate>Tue, 14 May 2019 15:42:32 +0000</pubDate><author>hodory</author><guid>http://blog.hodory.dev/2019/05/14/java%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%ED%9A%8C%EC%9B%90-%EA%B8%B0%EC%A1%B4-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0/</guid><description><![CDATA[회원 비밀번호 변경 로직을 작성중에 현재 비밀번호와 새 비밀번호를 입력받아, 기존 비밀번호가 맞는지 체크하는 로직을 넣고 싶었습니다.
String currentPassword = new BCryptPasswordEncoder().encode(request.getCurrentPassword());	final User persistUser = userRepository.findUserByIdAndPassword(userId, currentPassword) .orElseThrow(() -&gt; new EntityNotFoundException(&#34;회원정보를 찾을 수 없습니다.&#34;)); if(!currentPassword.equals(persistUser.getPassword())) {	logger.info(&#34;changePassword is Not Equal Current Password&#34;);	return new ResponseEntity&lt;&gt;(UserRegisterResult.ERROR.getResponseBody(),	HttpStatus.FORBIDDEN);	} new BCryptPasswordEncoder().encode(password);로 암호화 한 패스워드를 저장했기 때문에, 회원을 찾을때도 이렇게 하면 되겠다고 생각해서 위와 같은 코드를 작성하였는데, 테스트중 계속하여 EntityNotFoundException이 발생하였습니다.
디버깅으로 체크하였더니 String currentPassword = new BCryptPasswordEncoder().]]></description></item></channel></rss>