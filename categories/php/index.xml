<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>PHP - Category - Web Developer Hodory</title><link>http://blog.hodory.dev/categories/php/</link><description>PHP - Category - Web Developer Hodory</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>master@hodory.dev (hodory)</managingEditor><webMaster>master@hodory.dev (hodory)</webMaster><lastBuildDate>Sun, 15 Dec 2024 15:00:00 +0000</lastBuildDate><atom:link href="http://blog.hodory.dev/categories/php/" rel="self" type="application/rss+xml"/><item><title>[PHP] Array And Class Object Performance Test</title><link>http://blog.hodory.dev/2024/12/15/php-array-and-class-object-performance-test/</link><pubDate>Sun, 15 Dec 2024 15:00:00 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2024/12/15/php-array-and-class-object-performance-test/</guid><description><![CDATA[<table>
<thead>
<tr>
<th></th>
<th>PHP Dynamic Array</th>
<th>Class With Constructor</th>
<th>Class With Setter</th>
<th>Illuminate\Support\Collection</th>
<th>Collection + Class Based Collection</th>
</tr>
</thead>
<tbody>
<tr>
<td>Test Link</td>
<td><a href="https://3v4l.org/h08dj/perf" target="_blank" rel="noopener noreferrer">https://3v4l.org/h08dj/perf</a></td>
<td><a href="https://3v4l.org/CU0MC/perf" target="_blank" rel="noopener noreferrer">https://3v4l.org/CU0MC/perf</a></td>
<td><a href="https://3v4l.org/IqmsA/perf" target="_blank" rel="noopener noreferrer">https://3v4l.org/IqmsA/perf</a></td>
<td>코드가 너무 길어서 테스트 불가</td>
<td>코드가 너무 길어서 테스트 불가</td>
</tr>
<tr>
<td>Memory Peak</td>
<td>Memory Peak Usage: 536 MB</td>
<td>Memory Peak Usage: 254 MB</td>
<td>Memory Peak Usage: 254 MB</td>
<td>Memory Peak Usage: 658 MB</td>
<td>Memory Peak Usage: 660 MB</td>
</tr>
<tr>
<td>Execution Time</td>
<td>Execution Time: 2.32 seconds</td>
<td>Execution Time: 3.38 seconds</td>
<td>Execution Time: 4.25 seconds</td>
<td>Execution Time: 3.55 seconds</td>
<td>Execution Time: 5.96 seconds</td>
</tr>
<tr>
<td>Code</td>
<td>&lt;?php ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); $start = microtime(true); $product = []; for ($k = 0; $k &lt;= 1000; $k++) { $options = []; for ($j = 0; $j &lt;= 10; $j++) { $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItems[] = array( &rsquo;title&rsquo; =&gt; &lsquo;OptionItem&rsquo; . $i, &lsquo;description&rsquo; =&gt; &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, &lsquo;price&rsquo; =&gt; random_int(1000, 10000) ); } $options[] = array( &rsquo;title&rsquo; =&gt; &lsquo;Option&rsquo; . $j, &lsquo;description&rsquo; =&gt; &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, &lsquo;price&rsquo; =&gt; random_int(1000, 10000), &lsquo;items&rsquo; =&gt; $optionItems ); } $product[] = array( &rsquo;title&rsquo; =&gt; &lsquo;Product&rsquo; . $k, &lsquo;description&rsquo; =&gt; &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, &lsquo;price&rsquo; =&gt; random_int(1000, 10000), &lsquo;currency&rsquo; =&gt; &lsquo;USD&rsquo;, &lsquo;category&rsquo; =&gt; &lsquo;Category&rsquo; . $k, &lsquo;brand&rsquo; =&gt; &lsquo;Brand&rsquo; . $k, &lsquo;options&rsquo; =&gt; $options ); } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br&gt;&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br&gt;&rsquo;;</td>
<td>&lt;?php class Product { private string $title; private string $description; private int $price; private string $currency; private string $category; private string $brand; private array $options; /** * @param string $title * @param string $description * @param int $price * @param string $currency * @param string $category * @param string $brand * @param array $options */ public function __construct(string $title, string $description, int $price, string $currency, string $category, string $brand, array $options) { $this-&gt;title = $title; $this-&gt;description = $description; $this-&gt;price = $price; $this-&gt;currency = $currency; $this-&gt;category = $category; $this-&gt;brand = $brand; $this-&gt;options = $options; } /** * @return string */ public function getTitle(): string { return $this-&gt;title; } /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @return string */ public function getDescription(): string { return $this-&gt;description; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @return int */ public function getPrice(): int { return $this-&gt;price; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } /** * @return string */ public function getCurrency(): string { return $this-&gt;currency; } /** * @param string $currency */ public function setCurrency(string $currency): void { $this-&gt;currency = $currency; } /** * @return string */ public function getCategory(): string { return $this-&gt;category; } /** * @param string $category */ public function setCategory(string $category): void { $this-&gt;category = $category; } /** * @return string */ public function getBrand(): string { return $this-&gt;brand; } /** * @param string $brand */ public function setBrand(string $brand): void { $this-&gt;brand = $brand; } /** * @return array */ public function getOptions(): array { return $this-&gt;options; } /** * @param array $options */ public function setOptions(array $options): void { $this-&gt;options = $options; } } class Option { private string $title; private string $description; private int $price; private array $items; /** * @param string $title * @param string $description * @param int $price * @param array $items */ public function __construct(string $title, string $description, int $price, array $items) { $this-&gt;title = $title; $this-&gt;description = $description; $this-&gt;price = $price; $this-&gt;items = $items; } /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } /** * @param array $items */ public function setItems(array $items): void { $this-&gt;items = $items; } } class OptionItem { private string $title; private string $description; private int $price; /** * @param string $title * @param string $description * @param int $price */ public function __construct(string $title, string $description, int $price) { $this-&gt;title = $title; $this-&gt;description = $description; $this-&gt;price = $price; } /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } } $product = []; for ($k = 0; $k &lt;= 100; $k++) { $options = []; for ($j = 0; $j &lt;= 10; $j++) { $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItem = new OptionItem(title: &lsquo;OptionItem&rsquo; . $i, description: &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, price: random_int(1000, 10000)); $optionItems[] = $optionItem; } $option = new Option(title: &lsquo;Option&rsquo; . $j, description: &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, price: random_int(1000, 10000), items: $optionItems); $options[] = $option; } $product[] = new Product(title: &lsquo;Product&rsquo; . $k, description: &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, price: random_int(1000, 10000), currency: &lsquo;USD&rsquo;, category: &lsquo;Category&rsquo; . $k, brand: &lsquo;Brand&rsquo; . $k, options: $options); }</td>
<td>&lt;?php ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); class Product { private string $title; private string $description; private int $price; private string $currency; private string $category; private string $brand; private array $options; /** * @return string */ public function getTitle(): string { return $this-&gt;title; } /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @return string */ public function getDescription(): string { return $this-&gt;description; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @return int */ public function getPrice(): int { return $this-&gt;price; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } /** * @return string */ public function getCurrency(): string { return $this-&gt;currency; } /** * @param string $currency */ public function setCurrency(string $currency): void { $this-&gt;currency = $currency; } /** * @return string */ public function getCategory(): string { return $this-&gt;category; } /** * @param string $category */ public function setCategory(string $category): void { $this-&gt;category = $category; } /** * @return string */ public function getBrand(): string { return $this-&gt;brand; } /** * @param string $brand */ public function setBrand(string $brand): void { $this-&gt;brand = $brand; } /** * @return array */ public function getOptions(): array { return $this-&gt;options; } /** * @param array $options */ public function setOptions(array $options): void { $this-&gt;options = $options; } } class Option { private string $title; private string $description; private int $price; private array $items; /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } /** * @param array $items */ public function setItems(array $items): void { $this-&gt;items = $items; } } class OptionItem { private string $title; private string $description; private int $price; /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } } $start = microtime(true); $products = []; for ($k = 0; $k &lt;= 1000; $k++) { $product = new Product(); $product-&gt;setTitle(&lsquo;Product&rsquo; . $k); $product-&gt;setDescription(&lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;); $product-&gt;setPrice(random_int(1000, 10000)); $product-&gt;setCurrency(&lsquo;USD&rsquo;); $product-&gt;setCategory(&lsquo;Category&rsquo; . $k); $product-&gt;setBrand(&lsquo;Brand&rsquo; . $k); $options = []; for ($j = 0; $j &lt;= 10; $j++) { $option = new Option(); $option-&gt;setTitle(&lsquo;Option&rsquo; . $j); $option-&gt;setDescription(&lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;); $option-&gt;setPrice(random_int(1000, 10000)); $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItem = new OptionItem(); $optionItem-&gt;setTitle(&lsquo;Option Item&rsquo; . $i); $optionItem-&gt;setDescription(&lsquo;Option Item &rsquo; . $i . &rsquo; Description&rsquo;); $optionItem-&gt;setPrice(random_int(1000, 10000)); $optionItems[] = $optionItem; } $option-&gt;setItems($optionItems); $options[] = $option; } $product-&gt;setOptions($options); $products[] = $product; } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br&gt;&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br&gt;&rsquo;;</td>
<td>&lt;?php namespace Illuminate\Contracts\Support; ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); interface CanBeEscapedWhenCastToString { /** * Indicate that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); } ?&gt; &lt;?php namespace Illuminate\Support\Traits; use Closure; use Illuminate\Support\HigherOrderWhenProxy; trait Conditionable { /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenParameter * @template TWhenReturnType * * @param (\Closure($this): TWhenParameter)|TWhenParameter|null $value * @param (callable($this, TWhenParameter): TWhenReturnType)|null $callback * @param (callable($this, TWhenParameter): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return new HigherOrderWhenProxy($this); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))-&gt;condition($value); } if ($value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessParameter * @template TUnlessReturnType * * @param (\Closure($this): TUnlessParameter)|TUnlessParameter|null $value * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $callback * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return (new HigherOrderWhenProxy($this))-&gt;negateConditionOnCapture(); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))-&gt;condition(! $value); } if (! $value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } } ?&gt; &lt;?php namespace Illuminate\Support; use ArgumentCountError; use \ArrayAccess; use Illuminate\Support\Traits\Macroable; use InvalidArgumentException; use Random\Randomizer; class Arr { use Macroable; /** * Determine whether the given value is array accessible. * * @param mixed $value * @return bool */ public static function accessible($value) { return is_array($value) || $value instanceof ArrayAccess; } /** * Add an element to an array using &ldquo;dot&rdquo; notation if it doesn&rsquo;t exist. * * @param array $array * @param string|int|float $key * @param mixed $value * @return array */ public static function add($array, $key, $value) { if (is_null(static::get($array, $key))) { static::set($array, $key, $value); } return $array; } /** * Collapse an array of arrays into a single array. * * @param iterable $array * @return array */ public static function collapse($array) { $results = []; foreach ($array as $values) { if ($values instanceof Collection) { $values = $values-&gt;all(); } elseif (! is_array($values)) { continue; } $results[] = $values; } return array_merge([], &hellip;$results); } /** * Cross join the given arrays, returning all possible permutations. * * @param iterable &hellip;$arrays * @return array */ public static function crossJoin(&hellip;$arrays) { $results = [[]]; foreach ($arrays as $index =&gt; $array) { $append = []; foreach ($results as $product) { foreach ($array as $item) { $product[$index] = $item; $append[] = $product; } } $results = $append; } return $results; } /** * Divide an array into two arrays. One with keys and the other with values. * * @param array $array * @return array */ public static function divide($array) { return [array_keys($array), array_values($array)]; } /** * Flatten a multi-dimensional associative array with dots. * * @param iterable $array * @param string $prepend * @return array */ public static function dot($array, $prepend = &lsquo;&rsquo;) { $results = []; foreach ($array as $key =&gt; $value) { if (is_array($value) &amp;&amp; ! empty($value)) { $results = array_merge($results, static::dot($value, $prepend.$key.&rsquo;.&rsquo;)); } else { $results[$prepend.$key] = $value; } } return $results; } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @param iterable $array * @return array */ public static function undot($array) { $results = []; foreach ($array as $key =&gt; $value) { static::set($results, $key, $value); } return $results; } /** * Get all of the given array except for a specified array of keys. * * @param array $array * @param array|string|int|float $keys * @return array */ public static function except($array, $keys) { static::forget($array, $keys); return $array; } /** * Determine if the given key exists in the provided array. * * @param \ArrayAccess|array $array * @param string|int|float $key * @return bool */ public static function exists($array, $key) { if ($array instanceof Enumerable) { return $array-&gt;has($key); } if ($array instanceof ArrayAccess) { return $array-&gt;offsetExists($key); } if (is_float($key)) { $key = (string) $key; } return array_key_exists($key, $array); } /** * Return the first element in an array passing a given truth test. * * @template TKey * @template TValue * @template TFirstDefault * * @param iterable&lt;TKey, TValue&gt; $array * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public static function first($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { if (empty($array)) { return value($default); } foreach ($array as $item) { return $item; } return value($default); } foreach ($array as $key =&gt; $value) { if ($callback($value, $key)) { return $value; } } return value($default); } /** * Return the last element in an array passing a given truth test. * * @param array $array * @param callable|null $callback * @param mixed $default * @return mixed */ public static function last($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { return empty($array) ? value($default) : end($array); } return static::first(array_reverse($array, true), $callback, $default); } /** * Take the first or last {$limit} items from an array. * * @param array $array * @param int $limit * @return array */ public static function take($array, $limit) { if ($limit &lt; 0) { return array_slice($array, $limit, abs($limit)); } return array_slice($array, 0, $limit); } /** * Flatten a multi-dimensional array into a single level. * * @param iterable $array * @param int $depth * @return array */ public static function flatten($array, $depth = INF) { $result = []; foreach ($array as $item) { $item = $item instanceof Collection ? $item-&gt;all() : $item; if (! is_array($item)) { $result[] = $item; } else { $values = $depth === 1 ? array_values($item) : static::flatten($item, $depth - 1); foreach ($values as $value) { $result[] = $value; } } } return $result; } /** * Remove one or many array items from a given array using &ldquo;dot&rdquo; notation. * * @param array $array * @param array|string|int|float $keys * @return void */ public static function forget(&amp;$array, $keys) { $original = &amp;$array; $keys = (array) $keys; if (count($keys) === 0) { return; } foreach ($keys as $key) { // if the exact key exists in the top-level, remove it if (static::exists($array, $key)) { unset($array[$key]); continue; } $parts = explode(&rsquo;.&rsquo;, $key); // clean up before each pass $array = &amp;$original; while (count($parts) &gt; 1) { $part = array_shift($parts); if (isset($array[$part]) &amp;&amp; static::accessible($array[$part])) { $array = &amp;$array[$part]; } else { continue 2; } } unset($array[array_shift($parts)]); } } /** * Get an item from an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|int|null $key * @param mixed $default * @return mixed */ public static function get($array, $key, $default = null) { if (! static::accessible($array)) { return value($default); } if (is_null($key)) { return $array; } if (static::exists($array, $key)) { return $array[$key]; } if (! str_contains($key, &lsquo;.&rsquo;)) { return $array[$key] ?? value($default); } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($array) &amp;&amp; static::exists($array, $segment)) { $array = $array[$segment]; } else { return value($default); } } return $array; } /** * Check if an item or items exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function has($array, $keys) { $keys = (array) $keys; if (! $array || $keys === []) { return false; } foreach ($keys as $key) { $subKeyArray = $array; if (static::exists($array, $key)) { continue; } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($subKeyArray) &amp;&amp; static::exists($subKeyArray, $segment)) { $subKeyArray = $subKeyArray[$segment]; } else { return false; } } } return true; } /** * Determine if any of the keys exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function hasAny($array, $keys) { if (is_null($keys)) { return false; } $keys = (array) $keys; if (! $array) { return false; } if ($keys === []) { return false; } foreach ($keys as $key) { if (static::has($array, $key)) { return true; } } return false; } /** * Determines if an array is associative. * * An array is &ldquo;associative&rdquo; if it doesn&rsquo;t have sequential numerical keys beginning with zero. * * @param array $array * @return bool */ public static function isAssoc(array $array) { return ! array_is_list($array); } /** * Determines if an array is a list. * * An array is a &ldquo;list&rdquo; if all array keys are sequential integers starting from 0 with no gaps in between. * * @param array $array * @return bool */ public static function isList($array) { return array_is_list($array); } /** * Join all items using a string. The final items can use a separate glue string. * * @param array $array * @param string $glue * @param string $finalGlue * @return string */ public static function join($array, $glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return implode($glue, $array); } if (count($array) === 0) { return &lsquo;&rsquo;; } if (count($array) === 1) { return end($array); } $finalItem = array_pop($array); return implode($glue, $array).$finalGlue.$finalItem; } /** * Key an associative array by a field or using a callback. * * @param array $array * @param callable|array|string $keyBy * @return array */ public static function keyBy($array, $keyBy) { return Collection::make($array)-&gt;keyBy($keyBy)-&gt;all(); } /** * Prepend the key names of an associative array. * * @param array $array * @param string $prependWith * @return array */ public static function prependKeysWith($array, $prependWith) { return static::mapWithKeys($array, fn ($item, $key) =&gt; [$prependWith.$key =&gt; $item]); } /** * Get a subset of the items from the given array. * * @param array $array * @param array|string $keys * @return array */ public static function only($array, $keys) { return array_intersect_key($array, array_flip((array) $keys)); } /** * Select an array of values from an array. * * @param array $array * @param array|string $keys * @return array */ public static function select($array, $keys) { $keys = static::wrap($keys); return static::map($array, function ($item) use ($keys) { $result = []; foreach ($keys as $key) { if (Arr::accessible($item) &amp;&amp; Arr::exists($item, $key)) { $result[$key] = $item[$key]; } elseif (is_object($item) &amp;&amp; isset($item-&gt;{$key})) { $result[$key] = $item-&gt;{$key}; } } return $result; }); } /** * Pluck an array of values from an array. * * @param iterable $array * @param string|array|int|null $value * @param string|array|null $key * @return array */ public static function pluck($array, $value, $key = null) { $results = []; [$value, $key] = static::explodePluckParameters($value, $key); foreach ($array as $item) { $itemValue = data_get($item, $value); // If the key is &ldquo;null&rdquo;, we will just append the value to the array and keep // looping. Otherwise we will key the array using the value of the key we // received from the developer. Then we&rsquo;ll return the final array form. if (is_null($key)) { $results[] = $itemValue; } else { $itemKey = data_get($item, $key); if (is_object($itemKey) &amp;&amp; method_exists($itemKey, &lsquo;__toString&rsquo;)) { $itemKey = (string) $itemKey; } $results[$itemKey] = $itemValue; } } return $results; } /** * Explode the &ldquo;value&rdquo; and &ldquo;key&rdquo; arguments passed to &ldquo;pluck&rdquo;. * * @param string|array $value * @param string|array|null $key * @return array */ protected static function explodePluckParameters($value, $key) { $value = is_string($value) ? explode(&rsquo;.&rsquo;, $value) : $value; $key = is_null($key) || is_array($key) ? $key : explode(&rsquo;.&rsquo;, $key); return [$value, $key]; } /** * Run a map over each of the items in the array. * * @param array $array * @param callable $callback * @return array */ public static function map(array $array, callable $callback) { $keys = array_keys($array); try { $items = array_map($callback, $array, $keys); } catch (ArgumentCountError) { $items = array_map($callback, $array); } return array_combine($keys, $items); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TKey * @template TValue * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param array&lt;TKey, TValue&gt; $array * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue&gt; $callback * @return array */ public static function mapWithKeys(array $array, callable $callback) { $result = []; foreach ($array as $key =&gt; $value) { $assoc = $callback($value, $key); foreach ($assoc as $mapKey =&gt; $mapValue) { $result[$mapKey] = $mapValue; } } return $result; } /** * Run a map over each nested chunk of items. * * @template TKey * @template TValue * * @param array&lt;TKey, array&gt; $array * @param callable(mixed&hellip;): TValue $callback * @return array&lt;TKey, TValue&gt; */ public static function mapSpread(array $array, callable $callback) { return static::map($array, function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&hellip;$chunk); }); } /** * Push an item onto the beginning of an array. * * @param array $array * @param mixed $value * @param mixed $key * @return array */ public static function prepend($array, $value, $key = null) { if (func_num_args() == 2) { array_unshift($array, $value); } else { $array = [$key =&gt; $value] + $array; } return $array; } /** * Get a value from the array, and remove it. * * @param array $array * @param string|int $key * @param mixed $default * @return mixed */ public static function pull(&amp;$array, $key, $default = null) { $value = static::get($array, $key, $default); static::forget($array, $key); return $value; } /** * Convert the array into a query string. * * @param array $array * @return string */ public static function query($array) { return http_build_query($array, &lsquo;&rsquo;, &lsquo;&amp;&rsquo;, PHP_QUERY_RFC3986); } /** * Get one or a specified number of random values from an array. * * @param array $array * @param int|null $number * @param bool $preserveKeys * @return mixed * * @throws \InvalidArgumentException */ public static function random($array, $number = null, $preserveKeys = false) { $requested = is_null($number) ? 1 : $number; $count = count($array); if ($requested &gt; $count) { throw new InvalidArgumentException( &ldquo;You requested {$requested} items, but there are only {$count} items available.&rdquo; ); } if (empty($array) || (! is_null($number) &amp;&amp; $number &lt;= 0)) { return is_null($number) ? null : []; } $keys = (new Randomizer)-&gt;pickArrayKeys($array, $requested); if (is_null($number)) { return $array[$keys[0]]; } $results = []; if ($preserveKeys) { foreach ($keys as $key) { $results[$key] = $array[$key]; } } else { foreach ($keys as $key) { $results[] = $array[$key]; } } return $results; } /** * Set an array item to a given value using &ldquo;dot&rdquo; notation. * * If no key is given to the method, the entire array will be replaced. * * @param array $array * @param string|int|null $key * @param mixed $value * @return array */ public static function set(&amp;$array, $key, $value) { if (is_null($key)) { return $array = $value; } $keys = explode(&rsquo;.&rsquo;, $key); foreach ($keys as $i =&gt; $key) { if (count($keys) === 1) { break; } unset($keys[$i]); // If the key doesn&rsquo;t exist at this depth, we will just create an empty array // to hold the next value, allowing us to create the arrays to hold final // values at the correct depth. Then we&rsquo;ll keep digging into the array. if (! isset($array[$key]) || ! is_array($array[$key])) { $array[$key] = []; } $array = &amp;$array[$key]; } $array[array_shift($keys)] = $value; return $array; } /** * Shuffle the given array and return the result. * * @param array $array * @return array */ public static function shuffle($array) { return (new Randomizer)-&gt;shuffleArray($array); } /** * Sort the array using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sort($array, $callback = null) { return Collection::make($array)-&gt;sortBy($callback)-&gt;all(); } /** * Sort the array in descending order using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sortDesc($array, $callback = null) { return Collection::make($array)-&gt;sortByDesc($callback)-&gt;all(); } /** * Recursively sort an array by keys and values. * * @param array $array * @param int $options * @param bool $descending * @return array */ public static function sortRecursive($array, $options = SORT_REGULAR, $descending = false) { foreach ($array as &amp;$value) { if (is_array($value)) { $value = static::sortRecursive($value, $options, $descending); } } if (! array_is_list($array)) { $descending ? krsort($array, $options) : ksort($array, $options); } else { $descending ? rsort($array, $options) : sort($array, $options); } return $array; } /** * Recursively sort an array by keys and values in descending order. * * @param array $array * @param int $options * @return array */ public static function sortRecursiveDesc($array, $options = SORT_REGULAR) { return static::sortRecursive($array, $options, true); } /** * Conditionally compile classes from an array into a CSS class list. * * @param array $array * @return string */ public static function toCssClasses($array) { $classList = static::wrap($array); $classes = []; foreach ($classList as $class =&gt; $constraint) { if (is_numeric($class)) { $classes[] = $constraint; } elseif ($constraint) { $classes[] = $class; } } return implode(&rsquo; &lsquo;, $classes); } /** * Conditionally compile styles from an array into a style list. * * @param array $array * @return string */ public static function toCssStyles($array) { $styleList = static::wrap($array); $styles = []; foreach ($styleList as $class =&gt; $constraint) { if (is_numeric($class)) { $styles[] = Str::finish($constraint, &lsquo;;&rsquo;); } elseif ($constraint) { $styles[] = Str::finish($class, &lsquo;;&rsquo;); } } return implode(&rsquo; &lsquo;, $styles); } /** * Filter the array using the given callback. * * @param array $array * @param callable $callback * @return array */ public static function where($array, callable $callback) { return array_filter($array, $callback, ARRAY_FILTER_USE_BOTH); } /** * Filter items where the value is not null. * * @param array $array * @return array */ public static function whereNotNull($array) { return static::where($array, fn ($value) =&gt; ! is_null($value)); } /** * If the given value is not an array and not null, wrap it in one. * * @param mixed $value * @return array */ public static function wrap($value) { if (is_null($value)) { return []; } return is_array($value) ? $value : [$value]; } } ?&gt; &lt;?php namespace Illuminate\Contracts\Support; interface Jsonable { /** * Convert the object to its JSON representation. * * @param int $options * @return string */ public function toJson($options = 0); } ?&gt; &lt;?php namespace Illuminate\Contracts\Support; /** * @template TKey of array-key * @template TValue */ interface Arrayable { /** * Get the instance as an array. * * @return array&lt;TKey, TValue&gt; */ public function toArray(); } ?&gt; &lt;?php namespace Illuminate\Support\Traits; use BadMethodCallException; use ReflectionClass; use ReflectionMethod; trait Macroable { /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @param-closure-this static $macro * * @return void */ public static function macro($name, $macro) { static::$macros[$name] = $macro; } /** * Mix another object into the class. * * @param object $mixin * @param bool $replace * @return void * * @throws \ReflectionException */ public static function mixin($mixin, $replace = true) { $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) { if ($replace || ! static::hasMacro($method-&gt;name)) { static::macro($method-&gt;name, $method-&gt;invoke($mixin)); } } } /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) { return isset(static::$macros[$name]); } /** * Flush the existing macros. * * @return void */ public static function flushMacros() { static::$macros = []; } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro-&gt;bindTo(null, static::class); } return $macro(&hellip;$parameters); } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro-&gt;bindTo($this, static::class); } return $macro(&hellip;$parameters); } } ?&gt; &lt;?php namespace Illuminate\Support; use CachingIterator; use Countable; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use IteratorAggregate; use JsonSerializable; use \Traversable; /** * @template TKey of array-key * * @template-covariant TValue * * @extends \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt; * @extends \IteratorAggregate&lt;TKey, TValue&gt; */ interface Enumerable extends Arrayable, Countable, IteratorAggregate, Jsonable, JsonSerializable { /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue&gt;|iterable&lt;TMakeKey, TMakeValue&gt;|null $items * @return static&lt;TMakeKey, TMakeValue&gt; */ public static function make($items = []); /** * Create a new instance by invoking the callback a given amount of times. * * @param int $number * @param callable|null $callback * @return static */ public static function times($number, ?callable $callback = null); /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static */ public static function range($from, $to, $step = 1); /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue&gt;|TWrapValue $value * @return static&lt;array-key, TWrapValue&gt; */ public static function wrap($value); /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue&gt;|static&lt;TUnwrapKey, TUnwrapValue&gt; $value * @return array&lt;TUnwrapKey, TUnwrapValue&gt; */ public static function unwrap($value); /** * Create a new instance with no items. * * @return static */ public static function empty(); /** * Get all items in the enumerable. * * @return array */ public function all(); /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null); /** * Get the median of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return float|int|null */ public function median($key = null); /** * Get the mode of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return array&lt;int, float|int&gt;|null */ public function mode($key = null); /** * Collapse the items into a single enumerable. * * @return static&lt;int, mixed&gt; */ public function collapse(); /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null); /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null); /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null); /** * Determine if an item exists in the enumerable. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null); /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null); /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue&gt;|iterable&lt;TCrossJoinKey, TCrossJoinValue&gt; &hellip;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&raquo; */ public function crossJoin(&hellip;$lists); /** * Dump the collection and end the script. * * @param mixed &hellip;$args * @return never */ public function dd(&hellip;$args); /** * Dump the collection. * * @param mixed &hellip;$args * @return $this */ public function dump(&hellip;$args); /** * Get the items that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @return static */ public function diff($items); /** * Get the items that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback); /** * Get the items whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function diffAssoc($items); /** * Get the items whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback); /** * Get the items whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function diffKeys($items); /** * Get the items whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback); /** * Retrieve duplicate items. * * @param (callable(TValue): bool)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false); /** * Retrieve duplicate items using strict comparison. * * @param (callable(TValue): bool)|string|null $callback * @return static */ public function duplicatesStrict($callback = null); /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback); /** * Execute a callback over each nested chunk of items. * * @param callable $callback * @return static */ public function eachSpread(callable $callback); /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null); /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt; $keys * @return static */ public function except($keys); /** * Run a filter over each of the items. * * @param (callable(TValue): bool)|null $callback * @return static */ public function filter(?callable $callback = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenReturnType as null * * @param bool $value * @param (callable($this): TWhenReturnType)|null $callback * @param (callable($this): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value, ?callable $callback = null, ?callable $default = null); /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessReturnType * * @param bool $value * @param (callable($this): TUnlessReturnType) $callback * @param (callable($this): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value, callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null); /** * Filter items by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null); /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null); /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values); /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values); /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values); /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf&gt;|array&lt;array-key, class-string&lt;TWhereInstanceOf&raquo; $type * @return static&lt;TKey, TWhereInstanceOf&gt; */ public function whereInstanceOf($type); /** * Get the first item from the enumerable passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue,TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null); /** * Get the first item by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null); /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static */ public function flatten($depth = INF); /** * Flip the values with their keys. * * @return static&lt;TValue, TKey&gt; */ public function flip(); /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null); /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&raquo; */ public function groupBy($groupBy, $preserveKeys = false); /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue&gt; */ public function keyBy($keyBy); /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey&gt; $key * @return bool */ public function has($key); /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key); /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string $value * @param string|null $glue * @return string */ public function implode($value, $glue = null); /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersect($items); /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback); /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersectAssoc($items); /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback); /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function intersectByKeys($items); /** * Determine if the collection is empty or not. * * @return bool */ public function isEmpty(); /** * Determine if the collection is not empty. * * @return bool */ public function isNotEmpty(); /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem(); /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;); /** * Get the keys of the collection items. * * @return static&lt;int, TKey&gt; */ public function keys(); /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null); /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue&gt; */ public function map(callable $callback); /** * Run a map over each nested chunk of items. * * @param callable $callback * @return static */ public function mapSpread(callable $callback); /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue&gt; $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&raquo; */ public function mapToDictionary(callable $callback); /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue&gt; $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&raquo; */ public function mapToGroups(callable $callback); /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue&gt; $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue&gt; */ public function mapWithKeys(callable $callback); /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue&gt;|array&lt;TFlatMapKey, TFlatMapValue&gt;) $callback * @return static&lt;TFlatMapKey, TFlatMapValue&gt; */ public function flatMap(callable $callback); /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue&gt; $class * @return static&lt;TKey, TMapIntoValue&gt; */ public function mapInto($class); /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function merge($items); /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue&gt;|iterable&lt;TKey, TMergeRecursiveValue&gt; $items * @return static&lt;TKey, TValue|TMergeRecursiveValue&gt; */ public function mergeRecursive($items); /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue&gt;|iterable&lt;array-key, TCombineValue&gt; $values * @return static&lt;TValue, TCombineValue&gt; */ public function combine($values); /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function union($items); /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null); /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null); /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0); /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string $keys * @return static */ public function only($keys); /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage); /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return static&lt;int&lt;0, 1&gt;, static&lt;TKey, TValue&raquo; */ public function partition($key, $operator = null, $value = null); /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue&gt; $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue&gt; */ public function concat($source); /** * Get one or a specified number of items randomly from the collection. * * @param int|null $number * @return static&lt;int, TValue&gt;|TValue * * @throws \InvalidArgumentException */ public function random($number = null); /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null); /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &hellip;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &hellip;$initial); /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replace($items); /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replaceRecursive($items); /** * Reverse items order. * * @return static */ public function reverse(); /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|callable(TValue,TKey): bool $value * @param bool $strict * @return TKey|bool */ public function search($value, $strict = false); /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false); /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false); /** * Shuffle the items in the collection. * * @return static */ public function shuffle(); /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static&gt; */ public function sliding($size = 2, $step = 1); /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count); /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value); /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value); /** * Get a slice of items from the enumerable. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null); /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function split($numberOfGroups); /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null); /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null); /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static&gt; */ public function chunk($size); /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue&gt;): bool $callback * @return static&lt;int, static&lt;int, TValue&raquo; */ public function chunkWhile(callable $callback); /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function splitIn($numberOfGroups); /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null); /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR); /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false); /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR); /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false); /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR); /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback); /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null); /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit); /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value); /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value); /** * Pass the collection to the given callback and then return it. * * @param callable(TValue): mixed $callback * @return $this */ public function tap(callable $callback); /** * Pass the enumerable to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback); /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue&gt; $class * @return TPipeIntoValue */ public function pipeInto($class); /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable&gt; $pipes * @return mixed */ public function pipeThrough($pipes); /** * Get the values of a given key. * * @param string|array&lt;array-key, string&gt; $value * @param string|null $key * @return static&lt;array-key, mixed&gt; */ public function pluck($value, $key = null); /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true); /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot(); /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false); /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null); /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue&gt; */ public function values(); /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue&gt; */ public function pad($size, $value); /** * Get the values iterator. * * @return \Traversable&lt;TKey, TValue&gt; */ public function getIterator(): \Traversable; /** * Count the number of items in the collection. * * @return int */ public function count(): int; /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int&gt; */ public function countBy($countBy = null); /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])-&gt;zip([4, 5, 6]); * =&gt; [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue&gt;|iterable&lt;array-key, TZipValue&gt; &hellip;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&raquo; */ public function zip($items); /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue&gt; */ public function collect(); /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed&gt; */ public function toArray(); /** * Convert the object into something JSON serializable. * * @return mixed */ public function jsonSerialize(): mixed; /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0); /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING); /** * Convert the collection to its string representation. * * @return string */ public function __toString(); /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method); /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key); } ?&gt; &lt;?php namespace Illuminate\Support\Traits; use BackedEnum; use CachingIterator; use Exception; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use Illuminate\Support\Arr; use Illuminate\Support\Collection; use Illuminate\Support\Enumerable; use Illuminate\Support\HigherOrderCollectionProxy; use InvalidArgumentException; use JsonSerializable; use \Traversable; use UnexpectedValueException; use UnitEnum; use WeakMap; /** * @template TKey of array-key * * @template-covariant TValue * * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $average * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $avg * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $contains * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $doesntContain * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $each * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $every * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $filter * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $first * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $flatMap * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $groupBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $keyBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $map * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $max * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $min * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $partition * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $percentage * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $reject * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $skipUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $skipWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $some * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $sortBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $sortByDesc * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $sum * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $takeUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $takeWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $unique * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $unless * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $until * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $when */ trait EnumeratesValues { use Conditionable; /** * Indicates that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @var bool */ protected $escapeWhenCastingToString = false; /** * The methods that can be proxied. * * @var array&lt;int, string&gt; */ protected static $proxies = [ &lsquo;average&rsquo;, &lsquo;avg&rsquo;, &lsquo;contains&rsquo;, &lsquo;doesntContain&rsquo;, &rsquo;each&rsquo;, &rsquo;every&rsquo;, &lsquo;filter&rsquo;, &lsquo;first&rsquo;, &lsquo;flatMap&rsquo;, &lsquo;groupBy&rsquo;, &lsquo;keyBy&rsquo;, &lsquo;map&rsquo;, &lsquo;max&rsquo;, &lsquo;min&rsquo;, &lsquo;partition&rsquo;, &lsquo;percentage&rsquo;, &lsquo;reject&rsquo;, &lsquo;skipUntil&rsquo;, &lsquo;skipWhile&rsquo;, &lsquo;some&rsquo;, &lsquo;sortBy&rsquo;, &lsquo;sortByDesc&rsquo;, &lsquo;sum&rsquo;, &rsquo;takeUntil&rsquo;, &rsquo;takeWhile&rsquo;, &lsquo;unique&rsquo;, &lsquo;unless&rsquo;, &lsquo;until&rsquo;, &lsquo;when&rsquo;, ]; /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue&gt;|iterable&lt;TMakeKey, TMakeValue&gt;|null $items * @return static&lt;TMakeKey, TMakeValue&gt; */ public static function make($items = []) { return new static($items); } /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue&gt;|TWrapValue $value * @return static&lt;array-key, TWrapValue&gt; */ public static function wrap($value) { return $value instanceof Enumerable ? new static($value) : new static(Arr::wrap($value)); } /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue&gt;|static&lt;TUnwrapKey, TUnwrapValue&gt; $value * @return array&lt;TUnwrapKey, TUnwrapValue&gt; */ public static function unwrap($value) { return $value instanceof Enumerable ? $value-&gt;all() : $value; } /** * Create a new instance with no items. * * @return static */ public static function empty() { return new static([]); } /** * Create a new collection by invoking the callback a given amount of times. * * @template TTimesValue * * @param int $number * @param (callable(int): TTimesValue)|null $callback * @return static&lt;int, TTimesValue&gt; */ public static function times($number, ?callable $callback = null) { if ($number &lt; 1) { return new static; } return static::range(1, $number) -&gt;unless($callback == null) -&gt;map($callback); } /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null) { $callback = $this-&gt;valueRetriever($callback); $reduced = $this-&gt;reduce(static function (&amp;$reduce, $value) use ($callback) { if (! is_null($resolved = $callback($value))) { $reduce[0] += $resolved; $reduce[1]++; } return $reduce; }, [0, 0]); return $reduced[1] ? $reduced[0] / $reduced[1] : null; } /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null) { return $this-&gt;avg($callback); } /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null) { return $this-&gt;contains(&hellip;func_get_args()); } /** * Dump the given arguments and terminate execution. * * @param mixed &hellip;$args * @return never */ public function dd(&hellip;$args) { dd($this-&gt;all(), &hellip;$args); } /** * Dump the items. * * @param mixed &hellip;$args * @return $this */ public function dump(&hellip;$args) { dump($this-&gt;all(), &hellip;$args); return $this; } /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback) { foreach ($this as $key =&gt; $item) { if ($callback($item, $key) === false) { break; } } return $this; } /** * Execute a callback over each nested chunk of items. * * @param callable(&hellip;mixed): mixed $callback * @return static */ public function eachSpread(callable $callback) { return $this-&gt;each(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&hellip;$chunk); }); } /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null) { if (func_num_args() === 1) { $callback = $this-&gt;valueRetriever($key); foreach ($this as $k =&gt; $v) { if (! $callback($v, $k)) { return false; } } return true; } return $this-&gt;every($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Get the first item by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null) { return $this-&gt;first($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Get a single key&rsquo;s value from the first matching item in the collection. * * @template TValueDefault * * @param string $key * @param TValueDefault|(\Closure(): TValueDefault) $default * @return TValue|TValueDefault */ public function value($key, $default = null) { if ($value = $this-&gt;firstWhere($key)) { return data_get($value, $key, $default); } return value($default); } /** * Ensure that every item in the collection is of the expected type. * * @template TEnsureOfType * * @param class-string&lt;TEnsureOfType&gt;|array&lt;array-key, class-string&lt;TEnsureOfType&raquo; $type * @return static&lt;TKey, TEnsureOfType&gt; * * @throws \UnexpectedValueException */ public function ensure($type) { $allowedTypes = is_array($type) ? $type : [$type]; return $this-&gt;each(function ($item, $index) use ($allowedTypes) { $itemType = get_debug_type($item); foreach ($allowedTypes as $allowedType) { if ($itemType === $allowedType || $item instanceof $allowedType) { return true; } } throw new UnexpectedValueException( sprintf(&ldquo;Collection should only include [%s] items, but &lsquo;%s&rsquo; found at position %d.&rdquo;, implode(&rsquo;, &lsquo;, $allowedTypes), $itemType, $index) ); }); } /** * Determine if the collection is not empty. * * @phpstan-assert-if-true TValue $this-&gt;first() * @phpstan-assert-if-true TValue $this-&gt;last() * * @phpstan-assert-if-false null $this-&gt;first() * @phpstan-assert-if-false null $this-&gt;last() * * @return bool */ public function isNotEmpty() { return ! $this-&gt;isEmpty(); } /** * Run a map over each nested chunk of items. * * @template TMapSpreadValue * * @param callable(mixed&hellip;): TMapSpreadValue $callback * @return static&lt;TKey, TMapSpreadValue&gt; */ public function mapSpread(callable $callback) { return $this-&gt;map(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&hellip;$chunk); }); } /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue&gt; $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&raquo; */ public function mapToGroups(callable $callback) { $groups = $this-&gt;mapToDictionary($callback); return $groups-&gt;map([$this, &lsquo;make&rsquo;]); } /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue&gt;|array&lt;TFlatMapKey, TFlatMapValue&gt;) $callback * @return static&lt;TFlatMapKey, TFlatMapValue&gt; */ public function flatMap(callable $callback) { return $this-&gt;map($callback)-&gt;collapse(); } /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue&gt; $class * @return static&lt;TKey, TMapIntoValue&gt; */ public function mapInto($class) { if (is_subclass_of($class, BackedEnum::class)) { return $this-&gt;map(fn ($value, $key) =&gt; $class::from($value)); } return $this-&gt;map(fn ($value, $key) =&gt; new $class($value, $key)); } /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null) { $callback = $this-&gt;valueRetriever($callback); return $this-&gt;map(fn ($value) =&gt; $callback($value)) -&gt;filter(fn ($value) =&gt; ! is_null($value)) -&gt;reduce(fn ($result, $value) =&gt; is_null($result) || $value &lt; $result ? $value : $result); } /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null) { $callback = $this-&gt;valueRetriever($callback); return $this-&gt;filter(fn ($value) =&gt; ! is_null($value))-&gt;reduce(function ($result, $item) use ($callback) { $value = $callback($item); return is_null($result) || $value &gt; $result ? $value : $result; }); } /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage) { $offset = max(0, ($page - 1) * $perPage); return $this-&gt;slice($offset, $perPage); } /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param TValue|string|null $operator * @param TValue|null $value * @return static&lt;int&lt;0, 1&gt;, static&lt;TKey, TValue&raquo; */ public function partition($key, $operator = null, $value = null) { $passed = []; $failed = []; $callback = func_num_args() === 1 ? $this-&gt;valueRetriever($key) : $this-&gt;operatorForWhere(&hellip;func_get_args()); foreach ($this as $key =&gt; $item) { if ($callback($item, $key)) { $passed[$key] = $item; } else { $failed[$key] = $item; } } return new static([new static($passed), new static($failed)]); } /** * Calculate the percentage of items that pass a given truth test. * * @param (callable(TValue, TKey): bool) $callback * @param int $precision * @return float|null */ public function percentage(callable $callback, int $precision = 2) { if ($this-&gt;isEmpty()) { return null; } return round( $this-&gt;filter($callback)-&gt;count() / $this-&gt;count() * 100, $precision ); } /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null) { $callback = is_null($callback) ? $this-&gt;identity() : $this-&gt;valueRetriever($callback); return $this-&gt;reduce(fn ($result, $item) =&gt; $result + $callback($item), 0); } /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null) { return $this-&gt;when($this-&gt;isEmpty(), $callback, $default); } /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null) { return $this-&gt;when($this-&gt;isNotEmpty(), $callback, $default); } /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null) { return $this-&gt;whenNotEmpty($callback, $default); } /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null) { return $this-&gt;whenEmpty($callback, $default); } /** * Filter items by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null) { return $this-&gt;filter($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null) { return $this-&gt;whereStrict($key, null); } /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null) { return $this-&gt;where($key, &lsquo;!==&rsquo;, null); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value) { return $this-&gt;where($key, &lsquo;===&rsquo;, $value); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false) { $values = $this-&gt;getArrayableItems($values); return $this-&gt;filter(fn ($item) =&gt; in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values) { return $this-&gt;whereIn($key, $values, true); } /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values) { return $this-&gt;where($key, &lsquo;&gt;=&rsquo;, reset($values))-&gt;where($key, &lsquo;&lt;=&rsquo;, end($values)); } /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values) { return $this-&gt;filter( fn ($item) =&gt; data_get($item, $key) &lt; reset($values) || data_get($item, $key) &gt; end($values) ); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false) { $values = $this-&gt;getArrayableItems($values); return $this-&gt;reject(fn ($item) =&gt; in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values) { return $this-&gt;whereNotIn($key, $values, true); } /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf&gt;|array&lt;array-key, class-string&lt;TWhereInstanceOf&raquo; $type * @return static&lt;TKey, TWhereInstanceOf&gt; */ public function whereInstanceOf($type) { return $this-&gt;filter(function ($value) use ($type) { if (is_array($type)) { foreach ($type as $classType) { if ($value instanceof $classType) { return true; } } return false; } return $value instanceof $type; }); } /** * Pass the collection to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback) { return $callback($this); } /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue&gt; $class * @return TPipeIntoValue */ public function pipeInto($class) { return new $class($this); } /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable&gt; $callbacks * @return mixed */ public function pipeThrough($callbacks) { return Collection::make($callbacks)-&gt;reduce( fn ($carry, $callback) =&gt; $callback($carry), $this, ); } /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null) { $result = $initial; foreach ($this as $key =&gt; $value) { $result = $callback($result, $value, $key); } return $result; } /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &hellip;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &hellip;$initial) { $result = $initial; foreach ($this as $key =&gt; $value) { $result = call_user_func_array($callback, array_merge($result, [$value, $key])); if (! is_array($result)) { throw new UnexpectedValueException(sprintf( &ldquo;%s::reduceSpread expects reducer to return an array, but got a &lsquo;%s&rsquo; instead.&rdquo;, class_basename(static::class), gettype($result) )); } } return $result; } /** * Reduce an associative collection to a single value. * * @template TReduceWithKeysInitial * @template TReduceWithKeysReturnType * * @param callable(TReduceWithKeysInitial|TReduceWithKeysReturnType, TValue, TKey): TReduceWithKeysReturnType $callback * @param TReduceWithKeysInitial $initial * @return TReduceWithKeysReturnType */ public function reduceWithKeys(callable $callback, $initial = null) { return $this-&gt;reduce($callback, $initial); } /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true) { $useAsCallable = $this-&gt;useAsCallable($callback); return $this-&gt;filter(function ($value, $key) use ($callback, $useAsCallable) { return $useAsCallable ? ! $callback($value, $key) : $value != $callback; }); } /** * Pass the collection to the given callback and then return it. * * @param callable($this): mixed $callback * @return $this */ public function tap(callable $callback) { $callback($this); return $this; } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { $callback = $this-&gt;valueRetriever($key); $exists = []; return $this-&gt;reject(function ($item, $key) use ($callback, $strict, &amp;$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null) { return $this-&gt;unique($key, true); } /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue&gt; */ public function collect() { return new Collection($this-&gt;all()); } /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed&gt; */ public function toArray() { return $this-&gt;map(fn ($value) =&gt; $value instanceof Arrayable ? $value-&gt;toArray() : $value)-&gt;all(); } /** * Convert the object into something JSON serializable. * * @return array&lt;TKey, mixed&gt; */ public function jsonSerialize(): array { return array_map(function ($value) { if ($value instanceof JsonSerializable) { return $value-&gt;jsonSerialize(); } elseif ($value instanceof Jsonable) { return json_decode($value-&gt;toJson(), true); } elseif ($value instanceof Arrayable) { return $value-&gt;toArray(); } return $value; }, $this-&gt;all()); } /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0) { return json_encode($this-&gt;jsonSerialize(), $options); } /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING) { return new CachingIterator($this-&gt;getIterator(), $flags); } /** * Convert the collection to its string representation. * * @return string */ public function __toString() { return $this-&gt;escapeWhenCastingToString ? e($this-&gt;toJson()) : $this-&gt;toJson(); } /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true) { $this-&gt;escapeWhenCastingToString = $escape; return $this; } /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method) { static::$proxies[] = $method; } /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key) { if (! in_array($key, static::$proxies)) { throw new Exception(&ldquo;Property [{$key}] does not exist on this collection instance.&rdquo;); } return new HigherOrderCollectionProxy($this, $key); } /** * Results array of items from Collection or Arrayable. * * @param mixed $items * @return array&lt;TKey, TValue&gt; */ protected function getArrayableItems($items) { if (is_array($items)) { return $items; } return match (true) { $items instanceof WeakMap =&gt; throw new InvalidArgumentException(&lsquo;Collections can not be created using instances of WeakMap.&rsquo;), $items instanceof Enumerable =&gt; $items-&gt;all(), $items instanceof Arrayable =&gt; $items-&gt;toArray(), $items instanceof \Traversable =&gt; iterator_to_array($items), $items instanceof Jsonable =&gt; json_decode($items-&gt;toJson(), true), $items instanceof JsonSerializable =&gt; (array) $items-&gt;jsonSerialize(), $items instanceof UnitEnum =&gt; [$items], default =&gt; (array) $items, }; } /** * Get an operator checker callback. * * @param callable|string $key * @param string|null $operator * @param mixed $value * @return \Closure */ protected function operatorForWhere($key, $operator = null, $value = null) { if ($this-&gt;useAsCallable($key)) { return $key; } if (func_num_args() === 1) { $value = true; $operator = &lsquo;=&rsquo;; } if (func_num_args() === 2) { $value = $operator; $operator = &lsquo;=&rsquo;; } return function ($item) use ($key, $operator, $value) { $retrieved = data_get($item, $key); $strings = array_filter([$retrieved, $value], function ($value) { return is_string($value) || (is_object($value) &amp;&amp; method_exists($value, &lsquo;__toString&rsquo;)); }); if (count($strings) &lt; 2 &amp;&amp; count(array_filter([$retrieved, $value], &lsquo;is_object&rsquo;)) == 1) { return in_array($operator, [&rsquo;!=&rsquo;, &lsquo;&lt;&gt;&rsquo;, &lsquo;!==&rsquo;]); } switch ($operator) { default: case &lsquo;=&rsquo;: case &lsquo;==&rsquo;: return $retrieved == $value; case &lsquo;!=&rsquo;: case &lsquo;&lt;&gt;&rsquo;: return $retrieved != $value; case &lsquo;&lt;&rsquo;: return $retrieved &lt; $value; case &lsquo;&gt;&rsquo;: return $retrieved &gt; $value; case &lsquo;&lt;=&rsquo;: return $retrieved &lt;= $value; case &lsquo;&gt;=&rsquo;: return $retrieved &gt;= $value; case &lsquo;===&rsquo;: return $retrieved === $value; case &lsquo;!==&rsquo;: return $retrieved !== $value; case &lsquo;&lt;=&gt;&rsquo;: return $retrieved &lt;=&gt; $value; } }; } /** * Determine if the given value is callable, but not a string. * * @param mixed $value * @return bool */ protected function useAsCallable($value) { return ! is_string($value) &amp;&amp; is_callable($value); } /** * Get a value retrieving callback. * * @param callable|string|null $value * @return callable */ protected function valueRetriever($value) { if ($this-&gt;useAsCallable($value)) { return $value; } return fn ($item) =&gt; data_get($item, $value); } /** * Make a function to check an item&rsquo;s equality. * * @param mixed $value * @return \Closure(mixed): bool */ protected function equality($value) { return fn ($item) =&gt; $item === $value; } /** * Make a function using another function, by negating its result. * * @param \Closure $callback * @return \Closure */ protected function negate(Closure $callback) { return fn (&hellip;$params) =&gt; ! $callback(&hellip;$params); } /** * Make a function that returns what&rsquo;s passed to it. * * @return \Closure(TValue): TValue */ protected function identity() { return fn ($value) =&gt; $value; } } ?&gt; &lt;?php namespace Illuminate\Support; use ArrayIterator; use Illuminate\Contracts\Support\CanBeEscapedWhenCastToString; use Illuminate\Support\Traits\EnumeratesValues; use stdClass; /** * @template TKey of array-key * * @template-covariant TValue * * @implements \ArrayAccess&lt;TKey, TValue&gt; * @implements \Illuminate\Support\Enumerable&lt;TKey, TValue&gt; */ class Collection implements \ArrayAccess, CanBeEscapedWhenCastToString, Enumerable { /** * @use \Illuminate\Support\Traits\EnumeratesValues&lt;TKey, TValue&gt; */ use EnumeratesValues, Traits\Macroable; /** * The items contained in the collection. * * @var array&lt;TKey, TValue&gt; */ protected $items = []; /** * Create a new collection. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt;|null $items * @return void */ public function __construct($items = []) { $this-&gt;items = $this-&gt;getArrayableItems($items); } /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static&lt;int, int&gt; */ public static function range($from, $to, $step = 1) { return new static(range($from, $to, $step)); } /** * Get all of the items in the collection. * * @return array&lt;TKey, TValue&gt; */ public function all() { return $this-&gt;items; } /** * Get a lazy collection for the items in this collection. * * @return \Illuminate\Support\LazyCollection&lt;TKey, TValue&gt; */ public function lazy() { return new LazyCollection($this-&gt;items); } /** * Get the median of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return float|int|null */ public function median($key = null) { $values = (isset($key) ? $this-&gt;pluck($key) : $this) -&gt;filter(fn ($item) =&gt; ! is_null($item)) -&gt;sort()-&gt;values(); $count = $values-&gt;count(); if ($count === 0) { return; } $middle = (int) ($count / 2); if ($count % 2) { return $values-&gt;get($middle); } return (new static([ $values-&gt;get($middle - 1), $values-&gt;get($middle), ]))-&gt;average(); } /** * Get the mode of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return array&lt;int, float|int&gt;|null */ public function mode($key = null) { if ($this-&gt;count() === 0) { return; } $collection = isset($key) ? $this-&gt;pluck($key) : $this; $counts = new static; $collection-&gt;each(fn ($value) =&gt; $counts[$value] = isset($counts[$value]) ? $counts[$value] + 1 : 1); $sorted = $counts-&gt;sort(); $highestValue = $sorted-&gt;last(); return $sorted-&gt;filter(fn ($value) =&gt; $value == $highestValue) -&gt;sort()-&gt;keys()-&gt;all(); } /** * Collapse the collection of items into a single array. * * @return static&lt;int, mixed&gt; */ public function collapse() { return new static(Arr::collapse($this-&gt;items)); } /** * Collapse the collection of items into a single array while preserving its keys. * * @return static&lt;mixed, mixed&gt; */ public function collapseWithKeys() { $results = []; foreach ($this-&gt;items as $key =&gt; $values) { if ($values instanceof Collection) { $values = $values-&gt;all(); } elseif (! is_array($values)) { continue; } $results[$key] = $values; } return new static(array_replace(&hellip;$results)); } /** * Determine if an item exists in the collection. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null) { if (func_num_args() === 1) { if ($this-&gt;useAsCallable($key)) { $placeholder = new stdClass; return $this-&gt;first($key, $placeholder) !== $placeholder; } return in_array($key, $this-&gt;items); } return $this-&gt;contains($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null) { if (func_num_args() === 2) { return $this-&gt;contains(fn ($item) =&gt; data_get($item, $key) === $value); } if ($this-&gt;useAsCallable($key)) { return ! is_null($this-&gt;first($key)); } return in_array($key, $this-&gt;items, true); } /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null) { return ! $this-&gt;contains(&hellip;func_get_args()); } /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue&gt;|iterable&lt;TCrossJoinKey, TCrossJoinValue&gt; &hellip;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&raquo; */ public function crossJoin(&hellip;$lists) { return new static(Arr::crossJoin( $this-&gt;items, &hellip;array_map([$this, &lsquo;getArrayableItems&rsquo;], $lists) )); } /** * Get the items in the collection that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @return static */ public function diff($items) { return new static(array_diff($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Get the items in the collection that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback) { return new static(array_udiff($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function diffAssoc($items) { return new static(array_diff_assoc($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Get the items in the collection whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback) { return new static(array_diff_uassoc($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function diffKeys($items) { return new static(array_diff_key($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Get the items in the collection whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback) { return new static(array_diff_ukey($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Retrieve duplicate items from the collection. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false) { $items = $this-&gt;map($this-&gt;valueRetriever($callback)); $uniqueItems = $items-&gt;unique(null, $strict); $compare = $this-&gt;duplicateComparator($strict); $duplicates = new static; foreach ($items as $key =&gt; $value) { if ($uniqueItems-&gt;isNotEmpty() &amp;&amp; $compare($value, $uniqueItems-&gt;first())) { $uniqueItems-&gt;shift(); } else { $duplicates[$key] = $value; } } return $duplicates; } /** * Retrieve duplicate items from the collection using strict comparison. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @return static */ public function duplicatesStrict($callback = null) { return $this-&gt;duplicates($callback, true); } /** * Get the comparison function to detect duplicates. * * @param bool $strict * @return callable(TValue, TValue): bool */ protected function duplicateComparator($strict) { if ($strict) { return fn ($a, $b) =&gt; $a === $b; } return fn ($a, $b) =&gt; $a == $b; } /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string $keys * @return static */ public function except($keys) { if (is_null($keys)) { return new static($this-&gt;items); } if ($keys instanceof Enumerable) { $keys = $keys-&gt;all(); } elseif (! is_array($keys)) { $keys = func_get_args(); } return new static(Arr::except($this-&gt;items, $keys)); } /** * Run a filter over each of the items. * * @param (callable(TValue, TKey): bool)|null $callback * @return static */ public function filter(?callable $callback = null) { if ($callback) { return new static(Arr::where($this-&gt;items, $callback)); } return new static(array_filter($this-&gt;items)); } /** * Get the first item from the collection passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null) { return Arr::first($this-&gt;items, $callback, $default); } /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static&lt;int, mixed&gt; */ public function flatten($depth = INF) { return new static(Arr::flatten($this-&gt;items, $depth)); } /** * Flip the items in the collection. * * @return static&lt;TValue, TKey&gt; */ public function flip() { return new static(array_flip($this-&gt;items)); } /** * Remove an item from the collection by key. * * \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TKey&gt;|TKey $keys * * @return $this */ public function forget($keys) { foreach ($this-&gt;getArrayableItems($keys) as $key) { $this-&gt;offsetUnset($key); } return $this; } /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null) { if (array_key_exists($key, $this-&gt;items)) { return $this-&gt;items[$key]; } return value($default); } /** * Get an item from the collection by key or add it to collection if it does not exist. * * @template TGetOrPutValue * * @param mixed $key * @param TGetOrPutValue|(\Closure(): TGetOrPutValue) $value * @return TValue|TGetOrPutValue */ public function getOrPut($key, $value) { if (array_key_exists($key, $this-&gt;items)) { return $this-&gt;items[$key]; } $this-&gt;offsetSet($key, $value = value($value)); return $value; } /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&raquo; */ public function groupBy($groupBy, $preserveKeys = false) { if (! $this-&gt;useAsCallable($groupBy) &amp;&amp; is_array($groupBy)) { $nextGroups = $groupBy; $groupBy = array_shift($nextGroups); } $groupBy = $this-&gt;valueRetriever($groupBy); $results = []; foreach ($this-&gt;items as $key =&gt; $value) { $groupKeys = $groupBy($value, $key); if (! is_array($groupKeys)) { $groupKeys = [$groupKeys]; } foreach ($groupKeys as $groupKey) { $groupKey = match (true) { is_bool($groupKey) =&gt; (int) $groupKey, $groupKey instanceof \BackedEnum =&gt; $groupKey-&gt;value, $groupKey instanceof \Stringable =&gt; (string) $groupKey, default =&gt; $groupKey, }; if (! array_key_exists($groupKey, $results)) { $results[$groupKey] = new static; } $results[$groupKey]-&gt;offsetSet($preserveKeys ? $key : null, $value); } } $result = new static($results); if (! empty($nextGroups)) { return $result-&gt;map-&gt;groupBy($nextGroups, $preserveKeys); } return $result; } /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue&gt; */ public function keyBy($keyBy) { $keyBy = $this-&gt;valueRetriever($keyBy); $results = []; foreach ($this-&gt;items as $key =&gt; $item) { $resolvedKey = $keyBy($item, $key); if (is_object($resolvedKey)) { $resolvedKey = (string) $resolvedKey; } $results[$resolvedKey] = $item; } return new static($results); } /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey&gt; $key * @return bool */ public function has($key) { $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if (! array_key_exists($value, $this-&gt;items)) { return false; } } return true; } /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key) { if ($this-&gt;isEmpty()) { return false; } $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if ($this-&gt;has($value)) { return true; } } return false; } /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string|null $value * @param string|null $glue * @return string */ public function implode($value, $glue = null) { if ($this-&gt;useAsCallable($value)) { return implode($glue ?? &lsquo;&rsquo;, $this-&gt;map($value)-&gt;all()); } $first = $this-&gt;first(); if (is_array($first) || (is_object($first) &amp;&amp; ! $first instanceof Stringable)) { return implode($glue ?? &lsquo;&rsquo;, $this-&gt;pluck($value)-&gt;all()); } return implode($value ?? &lsquo;&rsquo;, $this-&gt;items); } /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersect($items) { return new static(array_intersect($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback) { return new static(array_uintersect($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersectAssoc($items) { return new static(array_intersect_assoc($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback) { return new static(array_intersect_uassoc($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function intersectByKeys($items) { return new static(array_intersect_key( $this-&gt;items, $this-&gt;getArrayableItems($items) )); } /** * Determine if the collection is empty or not. * * @phpstan-assert-if-true null $this-&gt;first() * @phpstan-assert-if-true null $this-&gt;last() * * @phpstan-assert-if-false TValue $this-&gt;first() * @phpstan-assert-if-false TValue $this-&gt;last() * * @return bool */ public function isEmpty() { return empty($this-&gt;items); } /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem() { return $this-&gt;count() === 1; } /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return $this-&gt;implode($glue); } $count = $this-&gt;count(); if ($count === 0) { return &lsquo;&rsquo;; } if ($count === 1) { return $this-&gt;last(); } $collection = new static($this-&gt;items); $finalItem = $collection-&gt;pop(); return $collection-&gt;implode($glue).$finalGlue.$finalItem; } /** * Get the keys of the collection items. * * @return static&lt;int, TKey&gt; */ public function keys() { return new static(array_keys($this-&gt;items)); } /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null) { return Arr::last($this-&gt;items, $callback, $default); } /** * Get the values of a given key. * * @param string|int|array&lt;array-key, string&gt;|null $value * @param string|null $key * @return static&lt;array-key, mixed&gt; */ public function pluck($value, $key = null) { return new static(Arr::pluck($this-&gt;items, $value, $key)); } /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue&gt; */ public function map(callable $callback) { return new static(Arr::map($this-&gt;items, $callback)); } /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue&gt; $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&raquo; */ public function mapToDictionary(callable $callback) { $dictionary = []; foreach ($this-&gt;items as $key =&gt; $item) { $pair = $callback($item, $key); $key = key($pair); $value = reset($pair); if (! isset($dictionary[$key])) { $dictionary[$key] = []; } $dictionary[$key][] = $value; } return new static($dictionary); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue&gt; $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue&gt; */ public function mapWithKeys(callable $callback) { return new static(Arr::mapWithKeys($this-&gt;items, $callback)); } /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function merge($items) { return new static(array_merge($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue&gt;|iterable&lt;TKey, TMergeRecursiveValue&gt; $items * @return static&lt;TKey, TValue|TMergeRecursiveValue&gt; */ public function mergeRecursive($items) { return new static(array_merge_recursive($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Multiply the items in the collection by the multiplier. * * @param int $multiplier * @return static */ public function multiply(int $multiplier) { $new = new static; for ($i = 0; $i &lt; $multiplier; $i++) { $new-&gt;push(&hellip;$this-&gt;items); } return $new; } /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue&gt;|iterable&lt;array-key, TCombineValue&gt; $values * @return static&lt;TValue, TCombineValue&gt; */ public function combine($values) { return new static(array_combine($this-&gt;all(), $this-&gt;getArrayableItems($values))); } /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function union($items) { return new static($this-&gt;items + $this-&gt;getArrayableItems($items)); } /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0) { $new = []; $position = 0; foreach ($this-&gt;slice($offset)-&gt;items as $item) { if ($position % $step === 0) { $new[] = $item; } $position++; } return new static($new); } /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string|null $keys * @return static */ public function only($keys) { if (is_null($keys)) { return new static($this-&gt;items); } if ($keys instanceof Enumerable) { $keys = $keys-&gt;all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::only($this-&gt;items, $keys)); } /** * Select specific values from the items within the collection. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string|null $keys * @return static */ public function select($keys) { if (is_null($keys)) { return new static($this-&gt;items); } if ($keys instanceof Enumerable) { $keys = $keys-&gt;all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::select($this-&gt;items, $keys)); } /** * Get and remove the last N items from the collection. * * @param int $count * @return static&lt;int, TValue&gt;|TValue|null */ public function pop($count = 1) { if ($count === 1) { return array_pop($this-&gt;items); } if ($this-&gt;isEmpty()) { return new static; } $results = []; $collectionCount = $this-&gt;count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_pop($this-&gt;items)); } return new static($results); } /** * Push an item onto the beginning of the collection. * * @param TValue $value * @param TKey $key * @return $this */ public function prepend($value, $key = null) { $this-&gt;items = Arr::prepend($this-&gt;items, &hellip;func_get_args()); return $this; } /** * Push one or more items onto the end of the collection. * * @param TValue &hellip;$values * @return $this */ public function push(&hellip;$values) { foreach ($values as $value) { $this-&gt;items[] = $value; } return $this; } /** * Prepend one or more items to the beginning of the collection. * * @param TValue &hellip;$values * @return $this */ public function unshift(&hellip;$values) { array_unshift($this-&gt;items, &hellip;$values); return $this; } /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue&gt; $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue&gt; */ public function concat($source) { $result = new static($this); foreach ($source as $item) { $result-&gt;push($item); } return $result; } /** * Get and remove an item from the collection. * * @template TPullDefault * * @param TKey $key * @param TPullDefault|(\Closure(): TPullDefault) $default * @return TValue|TPullDefault */ public function pull($key, $default = null) { return Arr::pull($this-&gt;items, $key, $default); } /** * Put an item in the collection by key. * * @param TKey $key * @param TValue $value * @return $this */ public function put($key, $value) { $this-&gt;offsetSet($key, $value); return $this; } /** * Get one or a specified number of items randomly from the collection. * * @param (callable(self&lt;TKey, TValue&gt;): int)|int|null $number * @param bool $preserveKeys * @return static&lt;int, TValue&gt;|TValue * * @throws \InvalidArgumentException */ public function random($number = null, $preserveKeys = false) { if (is_null($number)) { return Arr::random($this-&gt;items); } if (is_callable($number)) { return new static(Arr::random($this-&gt;items, $number($this), $preserveKeys)); } return new static(Arr::random($this-&gt;items, $number, $preserveKeys)); } /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replace($items) { return new static(array_replace($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replaceRecursive($items) { return new static(array_replace_recursive($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Reverse items order. * * @return static */ public function reverse() { return new static(array_reverse($this-&gt;items, true)); } /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TKey|false */ public function search($value, $strict = false) { if (! $this-&gt;useAsCallable($value)) { return array_search($value, $this-&gt;items, $strict); } foreach ($this-&gt;items as $key =&gt; $item) { if ($value($item, $key)) { return $key; } } return false; } /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false) { $key = $this-&gt;search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this-&gt;keys())-&gt;search($key); if ($position === 0) { return null; } return $this-&gt;get($keys-&gt;get($position - 1)); } /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false) { $key = $this-&gt;search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this-&gt;keys())-&gt;search($key); if ($position === $keys-&gt;count() - 1) { return null; } return $this-&gt;get($keys-&gt;get($position + 1)); } /** * Get and remove the first N items from the collection. * * @param int $count * @return static&lt;int, TValue&gt;|TValue|null * * @throws \InvalidArgumentException */ public function shift($count = 1) { if ($count &lt; 0) { throw new InvalidArgumentException(&lsquo;Number of shifted items may not be less than zero.&rsquo;); } if ($this-&gt;isEmpty()) { return null; } if ($count === 0) { return new static; } if ($count === 1) { return array_shift($this-&gt;items); } $results = []; $collectionCount = $this-&gt;count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_shift($this-&gt;items)); } return new static($results); } /** * Shuffle the items in the collection. * * @return static */ public function shuffle() { return new static(Arr::shuffle($this-&gt;items)); } /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static&gt; */ public function sliding($size = 2, $step = 1) { $chunks = floor(($this-&gt;count() - $size) / $step) + 1; return static::times($chunks, fn ($number) =&gt; $this-&gt;slice(($number - 1) * $step, $size)); } /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count) { return $this-&gt;slice($count); } /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value) { return new static($this-&gt;lazy()-&gt;skipUntil($value)-&gt;all()); } /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value) { return new static($this-&gt;lazy()-&gt;skipWhile($value)-&gt;all()); } /** * Slice the underlying collection array. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null) { return new static(array_slice($this-&gt;items, $offset, $length, true)); } /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function split($numberOfGroups) { if ($this-&gt;isEmpty()) { return new static; } $groups = new static; $groupSize = floor($this-&gt;count() / $numberOfGroups); $remain = $this-&gt;count() % $numberOfGroups; $start = 0; for ($i = 0; $i &lt; $numberOfGroups; $i++) { $size = $groupSize; if ($i &lt; $remain) { $size++; } if ($size) { $groups-&gt;push(new static(array_slice($this-&gt;items, $start, $size))); $start += $size; } } return $groups; } /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function splitIn($numberOfGroups) { return $this-&gt;chunk((int) ceil($this-&gt;count() / $numberOfGroups)); } /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null) { $filter = func_num_args() &gt; 1 ? $this-&gt;operatorForWhere(&hellip;func_get_args()) : $key; $items = $this-&gt;unless($filter == null)-&gt;filter($filter); $count = $items-&gt;count(); if ($count === 0) { throw new ItemNotFoundException; } if ($count &gt; 1) { throw new MultipleItemsFoundException($count); } return $items-&gt;first(); } /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null) { $filter = func_num_args() &gt; 1 ? $this-&gt;operatorForWhere(&hellip;func_get_args()) : $key; $placeholder = new stdClass(); $item = $this-&gt;first($filter, $placeholder); if ($item === $placeholder) { throw new ItemNotFoundException; } return $item; } /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static&gt; */ public function chunk($size) { if ($size &lt;= 0) { return new static; } $chunks = []; foreach (array_chunk($this-&gt;items, $size, true) as $chunk) { $chunks[] = new static($chunk); } return new static($chunks); } /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue&gt;): bool $callback * @return static&lt;int, static&lt;int, TValue&raquo; */ public function chunkWhile(callable $callback) { return new static( $this-&gt;lazy()-&gt;chunkWhile($callback)-&gt;mapInto(static::class) ); } /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null) { $items = $this-&gt;items; $callback &amp;&amp; is_callable($callback) ? uasort($items, $callback) : asort($items, $callback ?? SORT_REGULAR); return new static($items); } /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR) { $items = $this-&gt;items; arsort($items, $options); return new static($items); } /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false) { if (is_array($callback) &amp;&amp; ! is_callable($callback)) { return $this-&gt;sortByMany($callback, $options); } $results = []; $callback = $this-&gt;valueRetriever($callback); // First we will loop through the items and get the comparator from a callback // function which we were given. Then, we will sort the returned values and // grab all the corresponding values for the sorted keys from this array. foreach ($this-&gt;items as $key =&gt; $value) { $results[$key] = $callback($value, $key); } $descending ? arsort($results, $options) : asort($results, $options); // Once we have sorted all of the keys in the array, we will loop through them // and grab the corresponding model so we can set the underlying items list // to the sorted version. Then we&rsquo;ll just return the collection instance. foreach (array_keys($results) as $key) { $results[$key] = $this-&gt;items[$key]; } return new static($results); } /** * Sort the collection using multiple comparisons. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt; $comparisons * @param int $options * @return static */ protected function sortByMany(array $comparisons = [], int $options = SORT_REGULAR) { $items = $this-&gt;items; uasort($items, function ($a, $b) use ($comparisons, $options) { foreach ($comparisons as $comparison) { $comparison = Arr::wrap($comparison); $prop = $comparison[0]; $ascending = Arr::get($comparison, 1, true) === true || Arr::get($comparison, 1, true) === &lsquo;asc&rsquo;; if (! is_string($prop) &amp;&amp; is_callable($prop)) { $result = $prop($a, $b); } else { $values = [data_get($a, $prop), data_get($b, $prop)]; if (! $ascending) { $values = array_reverse($values); } if (($options &amp; SORT_FLAG_CASE) === SORT_FLAG_CASE) { if (($options &amp; SORT_NATURAL) === SORT_NATURAL) { $result = strnatcasecmp($values[0], $values[1]); } else { $result = strcasecmp($values[0], $values[1]); } } else { $result = match ($options) { SORT_NUMERIC =&gt; intval($values[0]) &lt;=&gt; intval($values[1]), SORT_STRING =&gt; strcmp($values[0], $values[1]), SORT_NATURAL =&gt; strnatcmp((string) $values[0], (string) $values[1]), SORT_LOCALE_STRING =&gt; strcoll($values[0], $values[1]), default =&gt; $values[0] &lt;=&gt; $values[1], }; } } if ($result === 0) { continue; } return $result; } }); return new static($items); } /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR) { if (is_array($callback) &amp;&amp; ! is_callable($callback)) { foreach ($callback as $index =&gt; $key) { $comparison = Arr::wrap($key); $comparison[1] = &lsquo;desc&rsquo;; $callback[$index] = $comparison; } } return $this-&gt;sortBy($callback, $options, true); } /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false) { $items = $this-&gt;items; $descending ? krsort($items, $options) : ksort($items, $options); return new static($items); } /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR) { return $this-&gt;sortKeys($options, true); } /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback) { $items = $this-&gt;items; uksort($items, $callback); return new static($items); } /** * Splice a portion of the underlying collection array. * * @param int $offset * @param int|null $length * @param array&lt;array-key, TValue&gt; $replacement * @return static */ public function splice($offset, $length = null, $replacement = []) { if (func_num_args() === 1) { return new static(array_splice($this-&gt;items, $offset)); } return new static(array_splice($this-&gt;items, $offset, $length, $this-&gt;getArrayableItems($replacement))); } /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit) { if ($limit &lt; 0) { return $this-&gt;slice($limit, abs($limit)); } return $this-&gt;slice(0, $limit); } /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value) { return new static($this-&gt;lazy()-&gt;takeUntil($value)-&gt;all()); } /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value) { return new static($this-&gt;lazy()-&gt;takeWhile($value)-&gt;all()); } /** * Transform each item in the collection using a callback. * * @param callable(TValue, TKey): TValue $callback * @return $this */ public function transform(callable $callback) { $this-&gt;items = $this-&gt;map($callback)-&gt;all(); return $this; } /** * Flatten a multi-dimensional associative array with dots. * * @return static */ public function dot() { return new static(Arr::dot($this-&gt;all())); } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot() { return new static(Arr::undot($this-&gt;all())); } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { if (is_null($key) &amp;&amp; $strict === false) { return new static(array_unique($this-&gt;items, SORT_REGULAR)); } $callback = $this-&gt;valueRetriever($key); $exists = []; return $this-&gt;reject(function ($item, $key) use ($callback, $strict, &amp;$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue&gt; */ public function values() { return new static(array_values($this-&gt;items)); } /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])-&gt;zip([4, 5, 6]); * =&gt; [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue&gt;|iterable&lt;array-key, TZipValue&gt; &hellip;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&raquo; */ public function zip($items) { $arrayableItems = array_map(fn ($items) =&gt; $this-&gt;getArrayableItems($items), func_get_args()); $params = array_merge([fn () =&gt; new static(func_get_args()), $this-&gt;items], $arrayableItems); return new static(array_map(&hellip;$params)); } /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue&gt; */ public function pad($size, $value) { return new static(array_pad($this-&gt;items, $size, $value)); } /** * Get an iterator for the items. * * @return \ArrayIterator&lt;TKey, TValue&gt; */ public function getIterator(): \Traversable { return new ArrayIterator($this-&gt;items); } /** * Count the number of items in the collection. * * @return int */ public function count(): int { return count($this-&gt;items); } /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int&gt; */ public function countBy($countBy = null) { return new static($this-&gt;lazy()-&gt;countBy($countBy)-&gt;all()); } /** * Add an item to the collection. * * @param TValue $item * @return $this */ public function add($item) { $this-&gt;items[] = $item; return $this; } /** * Get a base Support collection instance from this collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue&gt; */ public function toBase() { return new self($this); } /** * Determine if an item exists at an offset. * * @param TKey $key * @return bool */ public function offsetExists($key): bool { return isset($this-&gt;items[$key]); } /** * Get an item at a given offset. * * @param TKey $key * @return TValue */ public function offsetGet($key): mixed { return $this-&gt;items[$key]; } /** * Set the item at a given offset. * * @param TKey|null $key * @param TValue $value * @return void */ public function offsetSet($key, $value): void { if (is_null($key)) { $this-&gt;items[] = $value; } else { $this-&gt;items[$key] = $value; } } /** * Unset the item at a given offset. * * @param TKey $key * @return void */ public function offsetUnset($key): void { unset($this-&gt;items[$key]); } } ?&gt; &lt;?php $start = microtime(true); $product = []; for ($k = 0; $k &lt;= 1000; $k++) { $options = []; for ($j = 0; $j &lt;= 10; $j++) { $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItems[] = new Collection(array( &rsquo;title&rsquo; =&gt; &lsquo;OptionItem&rsquo; . $i, &lsquo;description&rsquo; =&gt; &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, &lsquo;price&rsquo; =&gt; random_int(1000, 10000) )); } $options[] = new Collection(array( &rsquo;title&rsquo; =&gt; &lsquo;Option&rsquo; . $j, &lsquo;description&rsquo; =&gt; &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, &lsquo;price&rsquo; =&gt; random_int(1000, 10000), &lsquo;items&rsquo; =&gt; $optionItems )); } $product[] = new Collection(array( &rsquo;title&rsquo; =&gt; &lsquo;Product&rsquo; . $k, &lsquo;description&rsquo; =&gt; &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, &lsquo;price&rsquo; =&gt; random_int(1000, 10000), &lsquo;currency&rsquo; =&gt; &lsquo;USD&rsquo;, &lsquo;category&rsquo; =&gt; &lsquo;Category&rsquo; . $k, &lsquo;brand&rsquo; =&gt; &lsquo;Brand&rsquo; . $k, &lsquo;options&rsquo; =&gt; $options )); } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br&gt;&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br&gt;&rsquo;;</td>
<td>&lt;?php namespace Illuminate\Contracts\Support; ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); interface CanBeEscapedWhenCastToString { /** * Indicate that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); } ?&gt; &lt;?php namespace Illuminate\Support\Traits; use Closure; use Illuminate\Support\HigherOrderWhenProxy; trait Conditionable { /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenParameter * @template TWhenReturnType * * @param (\Closure($this): TWhenParameter)|TWhenParameter|null $value * @param (callable($this, TWhenParameter): TWhenReturnType)|null $callback * @param (callable($this, TWhenParameter): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return new HigherOrderWhenProxy($this); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))-&gt;condition($value); } if ($value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessParameter * @template TUnlessReturnType * * @param (\Closure($this): TUnlessParameter)|TUnlessParameter|null $value * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $callback * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return (new HigherOrderWhenProxy($this))-&gt;negateConditionOnCapture(); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))-&gt;condition(! $value); } if (! $value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } } ?&gt; &lt;?php namespace Illuminate\Support; use ArgumentCountError; use \ArrayAccess; use Illuminate\Support\Traits\Macroable; use InvalidArgumentException; use Random\Randomizer; class Arr { use Macroable; /** * Determine whether the given value is array accessible. * * @param mixed $value * @return bool */ public static function accessible($value) { return is_array($value) || $value instanceof ArrayAccess; } /** * Add an element to an array using &ldquo;dot&rdquo; notation if it doesn&rsquo;t exist. * * @param array $array * @param string|int|float $key * @param mixed $value * @return array */ public static function add($array, $key, $value) { if (is_null(static::get($array, $key))) { static::set($array, $key, $value); } return $array; } /** * Collapse an array of arrays into a single array. * * @param iterable $array * @return array */ public static function collapse($array) { $results = []; foreach ($array as $values) { if ($values instanceof Collection) { $values = $values-&gt;all(); } elseif (! is_array($values)) { continue; } $results[] = $values; } return array_merge([], &hellip;$results); } /** * Cross join the given arrays, returning all possible permutations. * * @param iterable &hellip;$arrays * @return array */ public static function crossJoin(&hellip;$arrays) { $results = [[]]; foreach ($arrays as $index =&gt; $array) { $append = []; foreach ($results as $product) { foreach ($array as $item) { $product[$index] = $item; $append[] = $product; } } $results = $append; } return $results; } /** * Divide an array into two arrays. One with keys and the other with values. * * @param array $array * @return array */ public static function divide($array) { return [array_keys($array), array_values($array)]; } /** * Flatten a multi-dimensional associative array with dots. * * @param iterable $array * @param string $prepend * @return array */ public static function dot($array, $prepend = &lsquo;&rsquo;) { $results = []; foreach ($array as $key =&gt; $value) { if (is_array($value) &amp;&amp; ! empty($value)) { $results = array_merge($results, static::dot($value, $prepend.$key.&rsquo;.&rsquo;)); } else { $results[$prepend.$key] = $value; } } return $results; } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @param iterable $array * @return array */ public static function undot($array) { $results = []; foreach ($array as $key =&gt; $value) { static::set($results, $key, $value); } return $results; } /** * Get all of the given array except for a specified array of keys. * * @param array $array * @param array|string|int|float $keys * @return array */ public static function except($array, $keys) { static::forget($array, $keys); return $array; } /** * Determine if the given key exists in the provided array. * * @param \ArrayAccess|array $array * @param string|int|float $key * @return bool */ public static function exists($array, $key) { if ($array instanceof Enumerable) { return $array-&gt;has($key); } if ($array instanceof ArrayAccess) { return $array-&gt;offsetExists($key); } if (is_float($key)) { $key = (string) $key; } return array_key_exists($key, $array); } /** * Return the first element in an array passing a given truth test. * * @template TKey * @template TValue * @template TFirstDefault * * @param iterable&lt;TKey, TValue&gt; $array * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public static function first($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { if (empty($array)) { return value($default); } foreach ($array as $item) { return $item; } return value($default); } foreach ($array as $key =&gt; $value) { if ($callback($value, $key)) { return $value; } } return value($default); } /** * Return the last element in an array passing a given truth test. * * @param array $array * @param callable|null $callback * @param mixed $default * @return mixed */ public static function last($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { return empty($array) ? value($default) : end($array); } return static::first(array_reverse($array, true), $callback, $default); } /** * Take the first or last {$limit} items from an array. * * @param array $array * @param int $limit * @return array */ public static function take($array, $limit) { if ($limit &lt; 0) { return array_slice($array, $limit, abs($limit)); } return array_slice($array, 0, $limit); } /** * Flatten a multi-dimensional array into a single level. * * @param iterable $array * @param int $depth * @return array */ public static function flatten($array, $depth = INF) { $result = []; foreach ($array as $item) { $item = $item instanceof Collection ? $item-&gt;all() : $item; if (! is_array($item)) { $result[] = $item; } else { $values = $depth === 1 ? array_values($item) : static::flatten($item, $depth - 1); foreach ($values as $value) { $result[] = $value; } } } return $result; } /** * Remove one or many array items from a given array using &ldquo;dot&rdquo; notation. * * @param array $array * @param array|string|int|float $keys * @return void */ public static function forget(&amp;$array, $keys) { $original = &amp;$array; $keys = (array) $keys; if (count($keys) === 0) { return; } foreach ($keys as $key) { // if the exact key exists in the top-level, remove it if (static::exists($array, $key)) { unset($array[$key]); continue; } $parts = explode(&rsquo;.&rsquo;, $key); // clean up before each pass $array = &amp;$original; while (count($parts) &gt; 1) { $part = array_shift($parts); if (isset($array[$part]) &amp;&amp; static::accessible($array[$part])) { $array = &amp;$array[$part]; } else { continue 2; } } unset($array[array_shift($parts)]); } } /** * Get an item from an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|int|null $key * @param mixed $default * @return mixed */ public static function get($array, $key, $default = null) { if (! static::accessible($array)) { return value($default); } if (is_null($key)) { return $array; } if (static::exists($array, $key)) { return $array[$key]; } if (! str_contains($key, &lsquo;.&rsquo;)) { return $array[$key] ?? value($default); } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($array) &amp;&amp; static::exists($array, $segment)) { $array = $array[$segment]; } else { return value($default); } } return $array; } /** * Check if an item or items exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function has($array, $keys) { $keys = (array) $keys; if (! $array || $keys === []) { return false; } foreach ($keys as $key) { $subKeyArray = $array; if (static::exists($array, $key)) { continue; } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($subKeyArray) &amp;&amp; static::exists($subKeyArray, $segment)) { $subKeyArray = $subKeyArray[$segment]; } else { return false; } } } return true; } /** * Determine if any of the keys exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function hasAny($array, $keys) { if (is_null($keys)) { return false; } $keys = (array) $keys; if (! $array) { return false; } if ($keys === []) { return false; } foreach ($keys as $key) { if (static::has($array, $key)) { return true; } } return false; } /** * Determines if an array is associative. * * An array is &ldquo;associative&rdquo; if it doesn&rsquo;t have sequential numerical keys beginning with zero. * * @param array $array * @return bool */ public static function isAssoc(array $array) { return ! array_is_list($array); } /** * Determines if an array is a list. * * An array is a &ldquo;list&rdquo; if all array keys are sequential integers starting from 0 with no gaps in between. * * @param array $array * @return bool */ public static function isList($array) { return array_is_list($array); } /** * Join all items using a string. The final items can use a separate glue string. * * @param array $array * @param string $glue * @param string $finalGlue * @return string */ public static function join($array, $glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return implode($glue, $array); } if (count($array) === 0) { return &lsquo;&rsquo;; } if (count($array) === 1) { return end($array); } $finalItem = array_pop($array); return implode($glue, $array).$finalGlue.$finalItem; } /** * Key an associative array by a field or using a callback. * * @param array $array * @param callable|array|string $keyBy * @return array */ public static function keyBy($array, $keyBy) { return Collection::make($array)-&gt;keyBy($keyBy)-&gt;all(); } /** * Prepend the key names of an associative array. * * @param array $array * @param string $prependWith * @return array */ public static function prependKeysWith($array, $prependWith) { return static::mapWithKeys($array, fn ($item, $key) =&gt; [$prependWith.$key =&gt; $item]); } /** * Get a subset of the items from the given array. * * @param array $array * @param array|string $keys * @return array */ public static function only($array, $keys) { return array_intersect_key($array, array_flip((array) $keys)); } /** * Select an array of values from an array. * * @param array $array * @param array|string $keys * @return array */ public static function select($array, $keys) { $keys = static::wrap($keys); return static::map($array, function ($item) use ($keys) { $result = []; foreach ($keys as $key) { if (Arr::accessible($item) &amp;&amp; Arr::exists($item, $key)) { $result[$key] = $item[$key]; } elseif (is_object($item) &amp;&amp; isset($item-&gt;{$key})) { $result[$key] = $item-&gt;{$key}; } } return $result; }); } /** * Pluck an array of values from an array. * * @param iterable $array * @param string|array|int|null $value * @param string|array|null $key * @return array */ public static function pluck($array, $value, $key = null) { $results = []; [$value, $key] = static::explodePluckParameters($value, $key); foreach ($array as $item) { $itemValue = data_get($item, $value); // If the key is &ldquo;null&rdquo;, we will just append the value to the array and keep // looping. Otherwise we will key the array using the value of the key we // received from the developer. Then we&rsquo;ll return the final array form. if (is_null($key)) { $results[] = $itemValue; } else { $itemKey = data_get($item, $key); if (is_object($itemKey) &amp;&amp; method_exists($itemKey, &lsquo;__toString&rsquo;)) { $itemKey = (string) $itemKey; } $results[$itemKey] = $itemValue; } } return $results; } /** * Explode the &ldquo;value&rdquo; and &ldquo;key&rdquo; arguments passed to &ldquo;pluck&rdquo;. * * @param string|array $value * @param string|array|null $key * @return array */ protected static function explodePluckParameters($value, $key) { $value = is_string($value) ? explode(&rsquo;.&rsquo;, $value) : $value; $key = is_null($key) || is_array($key) ? $key : explode(&rsquo;.&rsquo;, $key); return [$value, $key]; } /** * Run a map over each of the items in the array. * * @param array $array * @param callable $callback * @return array */ public static function map(array $array, callable $callback) { $keys = array_keys($array); try { $items = array_map($callback, $array, $keys); } catch (ArgumentCountError) { $items = array_map($callback, $array); } return array_combine($keys, $items); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TKey * @template TValue * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param array&lt;TKey, TValue&gt; $array * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue&gt; $callback * @return array */ public static function mapWithKeys(array $array, callable $callback) { $result = []; foreach ($array as $key =&gt; $value) { $assoc = $callback($value, $key); foreach ($assoc as $mapKey =&gt; $mapValue) { $result[$mapKey] = $mapValue; } } return $result; } /** * Run a map over each nested chunk of items. * * @template TKey * @template TValue * * @param array&lt;TKey, array&gt; $array * @param callable(mixed&hellip;): TValue $callback * @return array&lt;TKey, TValue&gt; */ public static function mapSpread(array $array, callable $callback) { return static::map($array, function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&hellip;$chunk); }); } /** * Push an item onto the beginning of an array. * * @param array $array * @param mixed $value * @param mixed $key * @return array */ public static function prepend($array, $value, $key = null) { if (func_num_args() == 2) { array_unshift($array, $value); } else { $array = [$key =&gt; $value] + $array; } return $array; } /** * Get a value from the array, and remove it. * * @param array $array * @param string|int $key * @param mixed $default * @return mixed */ public static function pull(&amp;$array, $key, $default = null) { $value = static::get($array, $key, $default); static::forget($array, $key); return $value; } /** * Convert the array into a query string. * * @param array $array * @return string */ public static function query($array) { return http_build_query($array, &lsquo;&rsquo;, &lsquo;&amp;&rsquo;, PHP_QUERY_RFC3986); } /** * Get one or a specified number of random values from an array. * * @param array $array * @param int|null $number * @param bool $preserveKeys * @return mixed * * @throws \InvalidArgumentException */ public static function random($array, $number = null, $preserveKeys = false) { $requested = is_null($number) ? 1 : $number; $count = count($array); if ($requested &gt; $count) { throw new InvalidArgumentException( &ldquo;You requested {$requested} items, but there are only {$count} items available.&rdquo; ); } if (empty($array) || (! is_null($number) &amp;&amp; $number &lt;= 0)) { return is_null($number) ? null : []; } $keys = (new Randomizer)-&gt;pickArrayKeys($array, $requested); if (is_null($number)) { return $array[$keys[0]]; } $results = []; if ($preserveKeys) { foreach ($keys as $key) { $results[$key] = $array[$key]; } } else { foreach ($keys as $key) { $results[] = $array[$key]; } } return $results; } /** * Set an array item to a given value using &ldquo;dot&rdquo; notation. * * If no key is given to the method, the entire array will be replaced. * * @param array $array * @param string|int|null $key * @param mixed $value * @return array */ public static function set(&amp;$array, $key, $value) { if (is_null($key)) { return $array = $value; } $keys = explode(&rsquo;.&rsquo;, $key); foreach ($keys as $i =&gt; $key) { if (count($keys) === 1) { break; } unset($keys[$i]); // If the key doesn&rsquo;t exist at this depth, we will just create an empty array // to hold the next value, allowing us to create the arrays to hold final // values at the correct depth. Then we&rsquo;ll keep digging into the array. if (! isset($array[$key]) || ! is_array($array[$key])) { $array[$key] = []; } $array = &amp;$array[$key]; } $array[array_shift($keys)] = $value; return $array; } /** * Shuffle the given array and return the result. * * @param array $array * @return array */ public static function shuffle($array) { return (new Randomizer)-&gt;shuffleArray($array); } /** * Sort the array using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sort($array, $callback = null) { return Collection::make($array)-&gt;sortBy($callback)-&gt;all(); } /** * Sort the array in descending order using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sortDesc($array, $callback = null) { return Collection::make($array)-&gt;sortByDesc($callback)-&gt;all(); } /** * Recursively sort an array by keys and values. * * @param array $array * @param int $options * @param bool $descending * @return array */ public static function sortRecursive($array, $options = SORT_REGULAR, $descending = false) { foreach ($array as &amp;$value) { if (is_array($value)) { $value = static::sortRecursive($value, $options, $descending); } } if (! array_is_list($array)) { $descending ? krsort($array, $options) : ksort($array, $options); } else { $descending ? rsort($array, $options) : sort($array, $options); } return $array; } /** * Recursively sort an array by keys and values in descending order. * * @param array $array * @param int $options * @return array */ public static function sortRecursiveDesc($array, $options = SORT_REGULAR) { return static::sortRecursive($array, $options, true); } /** * Conditionally compile classes from an array into a CSS class list. * * @param array $array * @return string */ public static function toCssClasses($array) { $classList = static::wrap($array); $classes = []; foreach ($classList as $class =&gt; $constraint) { if (is_numeric($class)) { $classes[] = $constraint; } elseif ($constraint) { $classes[] = $class; } } return implode(&rsquo; &lsquo;, $classes); } /** * Conditionally compile styles from an array into a style list. * * @param array $array * @return string */ public static function toCssStyles($array) { $styleList = static::wrap($array); $styles = []; foreach ($styleList as $class =&gt; $constraint) { if (is_numeric($class)) { $styles[] = Str::finish($constraint, &lsquo;;&rsquo;); } elseif ($constraint) { $styles[] = Str::finish($class, &lsquo;;&rsquo;); } } return implode(&rsquo; &lsquo;, $styles); } /** * Filter the array using the given callback. * * @param array $array * @param callable $callback * @return array */ public static function where($array, callable $callback) { return array_filter($array, $callback, ARRAY_FILTER_USE_BOTH); } /** * Filter items where the value is not null. * * @param array $array * @return array */ public static function whereNotNull($array) { return static::where($array, fn ($value) =&gt; ! is_null($value)); } /** * If the given value is not an array and not null, wrap it in one. * * @param mixed $value * @return array */ public static function wrap($value) { if (is_null($value)) { return []; } return is_array($value) ? $value : [$value]; } } ?&gt; &lt;?php namespace Illuminate\Contracts\Support; interface Jsonable { /** * Convert the object to its JSON representation. * * @param int $options * @return string */ public function toJson($options = 0); } ?&gt; &lt;?php namespace Illuminate\Contracts\Support; /** * @template TKey of array-key * @template TValue */ interface Arrayable { /** * Get the instance as an array. * * @return array&lt;TKey, TValue&gt; */ public function toArray(); } ?&gt; &lt;?php namespace Illuminate\Support\Traits; use BadMethodCallException; use ReflectionClass; use ReflectionMethod; trait Macroable { /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @param-closure-this static $macro * * @return void */ public static function macro($name, $macro) { static::$macros[$name] = $macro; } /** * Mix another object into the class. * * @param object $mixin * @param bool $replace * @return void * * @throws \ReflectionException */ public static function mixin($mixin, $replace = true) { $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) { if ($replace || ! static::hasMacro($method-&gt;name)) { static::macro($method-&gt;name, $method-&gt;invoke($mixin)); } } } /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) { return isset(static::$macros[$name]); } /** * Flush the existing macros. * * @return void */ public static function flushMacros() { static::$macros = []; } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro-&gt;bindTo(null, static::class); } return $macro(&hellip;$parameters); } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro-&gt;bindTo($this, static::class); } return $macro(&hellip;$parameters); } } ?&gt; &lt;?php namespace Illuminate\Support; use CachingIterator; use Countable; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use IteratorAggregate; use JsonSerializable; use \Traversable; /** * @template TKey of array-key * * @template-covariant TValue * * @extends \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt; * @extends \IteratorAggregate&lt;TKey, TValue&gt; */ interface Enumerable extends Arrayable, Countable, IteratorAggregate, Jsonable, JsonSerializable { /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue&gt;|iterable&lt;TMakeKey, TMakeValue&gt;|null $items * @return static&lt;TMakeKey, TMakeValue&gt; */ public static function make($items = []); /** * Create a new instance by invoking the callback a given amount of times. * * @param int $number * @param callable|null $callback * @return static */ public static function times($number, ?callable $callback = null); /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static */ public static function range($from, $to, $step = 1); /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue&gt;|TWrapValue $value * @return static&lt;array-key, TWrapValue&gt; */ public static function wrap($value); /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue&gt;|static&lt;TUnwrapKey, TUnwrapValue&gt; $value * @return array&lt;TUnwrapKey, TUnwrapValue&gt; */ public static function unwrap($value); /** * Create a new instance with no items. * * @return static */ public static function empty(); /** * Get all items in the enumerable. * * @return array */ public function all(); /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null); /** * Get the median of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return float|int|null */ public function median($key = null); /** * Get the mode of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return array&lt;int, float|int&gt;|null */ public function mode($key = null); /** * Collapse the items into a single enumerable. * * @return static&lt;int, mixed&gt; */ public function collapse(); /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null); /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null); /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null); /** * Determine if an item exists in the enumerable. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null); /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null); /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue&gt;|iterable&lt;TCrossJoinKey, TCrossJoinValue&gt; &hellip;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&raquo; */ public function crossJoin(&hellip;$lists); /** * Dump the collection and end the script. * * @param mixed &hellip;$args * @return never */ public function dd(&hellip;$args); /** * Dump the collection. * * @param mixed &hellip;$args * @return $this */ public function dump(&hellip;$args); /** * Get the items that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @return static */ public function diff($items); /** * Get the items that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback); /** * Get the items whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function diffAssoc($items); /** * Get the items whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback); /** * Get the items whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function diffKeys($items); /** * Get the items whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback); /** * Retrieve duplicate items. * * @param (callable(TValue): bool)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false); /** * Retrieve duplicate items using strict comparison. * * @param (callable(TValue): bool)|string|null $callback * @return static */ public function duplicatesStrict($callback = null); /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback); /** * Execute a callback over each nested chunk of items. * * @param callable $callback * @return static */ public function eachSpread(callable $callback); /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null); /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt; $keys * @return static */ public function except($keys); /** * Run a filter over each of the items. * * @param (callable(TValue): bool)|null $callback * @return static */ public function filter(?callable $callback = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenReturnType as null * * @param bool $value * @param (callable($this): TWhenReturnType)|null $callback * @param (callable($this): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value, ?callable $callback = null, ?callable $default = null); /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessReturnType * * @param bool $value * @param (callable($this): TUnlessReturnType) $callback * @param (callable($this): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value, callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null); /** * Filter items by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null); /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null); /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values); /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values); /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values); /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf&gt;|array&lt;array-key, class-string&lt;TWhereInstanceOf&raquo; $type * @return static&lt;TKey, TWhereInstanceOf&gt; */ public function whereInstanceOf($type); /** * Get the first item from the enumerable passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue,TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null); /** * Get the first item by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null); /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static */ public function flatten($depth = INF); /** * Flip the values with their keys. * * @return static&lt;TValue, TKey&gt; */ public function flip(); /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null); /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&raquo; */ public function groupBy($groupBy, $preserveKeys = false); /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue&gt; */ public function keyBy($keyBy); /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey&gt; $key * @return bool */ public function has($key); /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key); /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string $value * @param string|null $glue * @return string */ public function implode($value, $glue = null); /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersect($items); /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback); /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersectAssoc($items); /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback); /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function intersectByKeys($items); /** * Determine if the collection is empty or not. * * @return bool */ public function isEmpty(); /** * Determine if the collection is not empty. * * @return bool */ public function isNotEmpty(); /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem(); /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;); /** * Get the keys of the collection items. * * @return static&lt;int, TKey&gt; */ public function keys(); /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null); /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue&gt; */ public function map(callable $callback); /** * Run a map over each nested chunk of items. * * @param callable $callback * @return static */ public function mapSpread(callable $callback); /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue&gt; $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&raquo; */ public function mapToDictionary(callable $callback); /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue&gt; $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&raquo; */ public function mapToGroups(callable $callback); /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue&gt; $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue&gt; */ public function mapWithKeys(callable $callback); /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue&gt;|array&lt;TFlatMapKey, TFlatMapValue&gt;) $callback * @return static&lt;TFlatMapKey, TFlatMapValue&gt; */ public function flatMap(callable $callback); /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue&gt; $class * @return static&lt;TKey, TMapIntoValue&gt; */ public function mapInto($class); /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function merge($items); /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue&gt;|iterable&lt;TKey, TMergeRecursiveValue&gt; $items * @return static&lt;TKey, TValue|TMergeRecursiveValue&gt; */ public function mergeRecursive($items); /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue&gt;|iterable&lt;array-key, TCombineValue&gt; $values * @return static&lt;TValue, TCombineValue&gt; */ public function combine($values); /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function union($items); /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null); /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null); /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0); /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string $keys * @return static */ public function only($keys); /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage); /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return static&lt;int&lt;0, 1&gt;, static&lt;TKey, TValue&raquo; */ public function partition($key, $operator = null, $value = null); /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue&gt; $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue&gt; */ public function concat($source); /** * Get one or a specified number of items randomly from the collection. * * @param int|null $number * @return static&lt;int, TValue&gt;|TValue * * @throws \InvalidArgumentException */ public function random($number = null); /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null); /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &hellip;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &hellip;$initial); /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replace($items); /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replaceRecursive($items); /** * Reverse items order. * * @return static */ public function reverse(); /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|callable(TValue,TKey): bool $value * @param bool $strict * @return TKey|bool */ public function search($value, $strict = false); /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false); /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false); /** * Shuffle the items in the collection. * * @return static */ public function shuffle(); /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static&gt; */ public function sliding($size = 2, $step = 1); /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count); /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value); /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value); /** * Get a slice of items from the enumerable. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null); /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function split($numberOfGroups); /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null); /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null); /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static&gt; */ public function chunk($size); /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue&gt;): bool $callback * @return static&lt;int, static&lt;int, TValue&raquo; */ public function chunkWhile(callable $callback); /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function splitIn($numberOfGroups); /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null); /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR); /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false); /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR); /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false); /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR); /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback); /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null); /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit); /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value); /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value); /** * Pass the collection to the given callback and then return it. * * @param callable(TValue): mixed $callback * @return $this */ public function tap(callable $callback); /** * Pass the enumerable to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback); /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue&gt; $class * @return TPipeIntoValue */ public function pipeInto($class); /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable&gt; $pipes * @return mixed */ public function pipeThrough($pipes); /** * Get the values of a given key. * * @param string|array&lt;array-key, string&gt; $value * @param string|null $key * @return static&lt;array-key, mixed&gt; */ public function pluck($value, $key = null); /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true); /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot(); /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false); /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null); /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue&gt; */ public function values(); /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue&gt; */ public function pad($size, $value); /** * Get the values iterator. * * @return \Traversable&lt;TKey, TValue&gt; */ public function getIterator(): \Traversable; /** * Count the number of items in the collection. * * @return int */ public function count(): int; /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int&gt; */ public function countBy($countBy = null); /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])-&gt;zip([4, 5, 6]); * =&gt; [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue&gt;|iterable&lt;array-key, TZipValue&gt; &hellip;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&raquo; */ public function zip($items); /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue&gt; */ public function collect(); /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed&gt; */ public function toArray(); /** * Convert the object into something JSON serializable. * * @return mixed */ public function jsonSerialize(): mixed; /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0); /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING); /** * Convert the collection to its string representation. * * @return string */ public function __toString(); /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method); /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key); } ?&gt; &lt;?php namespace Illuminate\Support\Traits; use BackedEnum; use CachingIterator; use Exception; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use Illuminate\Support\Arr; use Illuminate\Support\Collection; use Illuminate\Support\Enumerable; use Illuminate\Support\HigherOrderCollectionProxy; use InvalidArgumentException; use JsonSerializable; use \Traversable; use UnexpectedValueException; use UnitEnum; use WeakMap; /** * @template TKey of array-key * * @template-covariant TValue * * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $average * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $avg * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $contains * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $doesntContain * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $each * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $every * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $filter * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $first * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $flatMap * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $groupBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $keyBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $map * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $max * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $min * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $partition * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $percentage * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $reject * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $skipUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $skipWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $some * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $sortBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $sortByDesc * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $sum * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $takeUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $takeWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $unique * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $unless * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $until * @property-read HigherOrderCollectionProxy&lt;TKey, TValue&gt; $when */ trait EnumeratesValues { use Conditionable; /** * Indicates that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @var bool */ protected $escapeWhenCastingToString = false; /** * The methods that can be proxied. * * @var array&lt;int, string&gt; */ protected static $proxies = [ &lsquo;average&rsquo;, &lsquo;avg&rsquo;, &lsquo;contains&rsquo;, &lsquo;doesntContain&rsquo;, &rsquo;each&rsquo;, &rsquo;every&rsquo;, &lsquo;filter&rsquo;, &lsquo;first&rsquo;, &lsquo;flatMap&rsquo;, &lsquo;groupBy&rsquo;, &lsquo;keyBy&rsquo;, &lsquo;map&rsquo;, &lsquo;max&rsquo;, &lsquo;min&rsquo;, &lsquo;partition&rsquo;, &lsquo;percentage&rsquo;, &lsquo;reject&rsquo;, &lsquo;skipUntil&rsquo;, &lsquo;skipWhile&rsquo;, &lsquo;some&rsquo;, &lsquo;sortBy&rsquo;, &lsquo;sortByDesc&rsquo;, &lsquo;sum&rsquo;, &rsquo;takeUntil&rsquo;, &rsquo;takeWhile&rsquo;, &lsquo;unique&rsquo;, &lsquo;unless&rsquo;, &lsquo;until&rsquo;, &lsquo;when&rsquo;, ]; /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue&gt;|iterable&lt;TMakeKey, TMakeValue&gt;|null $items * @return static&lt;TMakeKey, TMakeValue&gt; */ public static function make($items = []) { return new static($items); } /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue&gt;|TWrapValue $value * @return static&lt;array-key, TWrapValue&gt; */ public static function wrap($value) { return $value instanceof Enumerable ? new static($value) : new static(Arr::wrap($value)); } /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue&gt;|static&lt;TUnwrapKey, TUnwrapValue&gt; $value * @return array&lt;TUnwrapKey, TUnwrapValue&gt; */ public static function unwrap($value) { return $value instanceof Enumerable ? $value-&gt;all() : $value; } /** * Create a new instance with no items. * * @return static */ public static function empty() { return new static([]); } /** * Create a new collection by invoking the callback a given amount of times. * * @template TTimesValue * * @param int $number * @param (callable(int): TTimesValue)|null $callback * @return static&lt;int, TTimesValue&gt; */ public static function times($number, ?callable $callback = null) { if ($number &lt; 1) { return new static; } return static::range(1, $number) -&gt;unless($callback == null) -&gt;map($callback); } /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null) { $callback = $this-&gt;valueRetriever($callback); $reduced = $this-&gt;reduce(static function (&amp;$reduce, $value) use ($callback) { if (! is_null($resolved = $callback($value))) { $reduce[0] += $resolved; $reduce[1]++; } return $reduce; }, [0, 0]); return $reduced[1] ? $reduced[0] / $reduced[1] : null; } /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null) { return $this-&gt;avg($callback); } /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null) { return $this-&gt;contains(&hellip;func_get_args()); } /** * Dump the given arguments and terminate execution. * * @param mixed &hellip;$args * @return never */ public function dd(&hellip;$args) { dd($this-&gt;all(), &hellip;$args); } /** * Dump the items. * * @param mixed &hellip;$args * @return $this */ public function dump(&hellip;$args) { dump($this-&gt;all(), &hellip;$args); return $this; } /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback) { foreach ($this as $key =&gt; $item) { if ($callback($item, $key) === false) { break; } } return $this; } /** * Execute a callback over each nested chunk of items. * * @param callable(&hellip;mixed): mixed $callback * @return static */ public function eachSpread(callable $callback) { return $this-&gt;each(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&hellip;$chunk); }); } /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null) { if (func_num_args() === 1) { $callback = $this-&gt;valueRetriever($key); foreach ($this as $k =&gt; $v) { if (! $callback($v, $k)) { return false; } } return true; } return $this-&gt;every($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Get the first item by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null) { return $this-&gt;first($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Get a single key&rsquo;s value from the first matching item in the collection. * * @template TValueDefault * * @param string $key * @param TValueDefault|(\Closure(): TValueDefault) $default * @return TValue|TValueDefault */ public function value($key, $default = null) { if ($value = $this-&gt;firstWhere($key)) { return data_get($value, $key, $default); } return value($default); } /** * Ensure that every item in the collection is of the expected type. * * @template TEnsureOfType * * @param class-string&lt;TEnsureOfType&gt;|array&lt;array-key, class-string&lt;TEnsureOfType&raquo; $type * @return static&lt;TKey, TEnsureOfType&gt; * * @throws \UnexpectedValueException */ public function ensure($type) { $allowedTypes = is_array($type) ? $type : [$type]; return $this-&gt;each(function ($item, $index) use ($allowedTypes) { $itemType = get_debug_type($item); foreach ($allowedTypes as $allowedType) { if ($itemType === $allowedType || $item instanceof $allowedType) { return true; } } throw new UnexpectedValueException( sprintf(&ldquo;Collection should only include [%s] items, but &lsquo;%s&rsquo; found at position %d.&rdquo;, implode(&rsquo;, &lsquo;, $allowedTypes), $itemType, $index) ); }); } /** * Determine if the collection is not empty. * * @phpstan-assert-if-true TValue $this-&gt;first() * @phpstan-assert-if-true TValue $this-&gt;last() * * @phpstan-assert-if-false null $this-&gt;first() * @phpstan-assert-if-false null $this-&gt;last() * * @return bool */ public function isNotEmpty() { return ! $this-&gt;isEmpty(); } /** * Run a map over each nested chunk of items. * * @template TMapSpreadValue * * @param callable(mixed&hellip;): TMapSpreadValue $callback * @return static&lt;TKey, TMapSpreadValue&gt; */ public function mapSpread(callable $callback) { return $this-&gt;map(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&hellip;$chunk); }); } /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue&gt; $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&raquo; */ public function mapToGroups(callable $callback) { $groups = $this-&gt;mapToDictionary($callback); return $groups-&gt;map([$this, &lsquo;make&rsquo;]); } /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue&gt;|array&lt;TFlatMapKey, TFlatMapValue&gt;) $callback * @return static&lt;TFlatMapKey, TFlatMapValue&gt; */ public function flatMap(callable $callback) { return $this-&gt;map($callback)-&gt;collapse(); } /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue&gt; $class * @return static&lt;TKey, TMapIntoValue&gt; */ public function mapInto($class) { if (is_subclass_of($class, BackedEnum::class)) { return $this-&gt;map(fn ($value, $key) =&gt; $class::from($value)); } return $this-&gt;map(fn ($value, $key) =&gt; new $class($value, $key)); } /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null) { $callback = $this-&gt;valueRetriever($callback); return $this-&gt;map(fn ($value) =&gt; $callback($value)) -&gt;filter(fn ($value) =&gt; ! is_null($value)) -&gt;reduce(fn ($result, $value) =&gt; is_null($result) || $value &lt; $result ? $value : $result); } /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null) { $callback = $this-&gt;valueRetriever($callback); return $this-&gt;filter(fn ($value) =&gt; ! is_null($value))-&gt;reduce(function ($result, $item) use ($callback) { $value = $callback($item); return is_null($result) || $value &gt; $result ? $value : $result; }); } /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage) { $offset = max(0, ($page - 1) * $perPage); return $this-&gt;slice($offset, $perPage); } /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param TValue|string|null $operator * @param TValue|null $value * @return static&lt;int&lt;0, 1&gt;, static&lt;TKey, TValue&raquo; */ public function partition($key, $operator = null, $value = null) { $passed = []; $failed = []; $callback = func_num_args() === 1 ? $this-&gt;valueRetriever($key) : $this-&gt;operatorForWhere(&hellip;func_get_args()); foreach ($this as $key =&gt; $item) { if ($callback($item, $key)) { $passed[$key] = $item; } else { $failed[$key] = $item; } } return new static([new static($passed), new static($failed)]); } /** * Calculate the percentage of items that pass a given truth test. * * @param (callable(TValue, TKey): bool) $callback * @param int $precision * @return float|null */ public function percentage(callable $callback, int $precision = 2) { if ($this-&gt;isEmpty()) { return null; } return round( $this-&gt;filter($callback)-&gt;count() / $this-&gt;count() * 100, $precision ); } /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null) { $callback = is_null($callback) ? $this-&gt;identity() : $this-&gt;valueRetriever($callback); return $this-&gt;reduce(fn ($result, $item) =&gt; $result + $callback($item), 0); } /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null) { return $this-&gt;when($this-&gt;isEmpty(), $callback, $default); } /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null) { return $this-&gt;when($this-&gt;isNotEmpty(), $callback, $default); } /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null) { return $this-&gt;whenNotEmpty($callback, $default); } /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null) { return $this-&gt;whenEmpty($callback, $default); } /** * Filter items by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null) { return $this-&gt;filter($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null) { return $this-&gt;whereStrict($key, null); } /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null) { return $this-&gt;where($key, &lsquo;!==&rsquo;, null); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value) { return $this-&gt;where($key, &lsquo;===&rsquo;, $value); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false) { $values = $this-&gt;getArrayableItems($values); return $this-&gt;filter(fn ($item) =&gt; in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values) { return $this-&gt;whereIn($key, $values, true); } /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values) { return $this-&gt;where($key, &lsquo;&gt;=&rsquo;, reset($values))-&gt;where($key, &lsquo;&lt;=&rsquo;, end($values)); } /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values) { return $this-&gt;filter( fn ($item) =&gt; data_get($item, $key) &lt; reset($values) || data_get($item, $key) &gt; end($values) ); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false) { $values = $this-&gt;getArrayableItems($values); return $this-&gt;reject(fn ($item) =&gt; in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values) { return $this-&gt;whereNotIn($key, $values, true); } /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf&gt;|array&lt;array-key, class-string&lt;TWhereInstanceOf&raquo; $type * @return static&lt;TKey, TWhereInstanceOf&gt; */ public function whereInstanceOf($type) { return $this-&gt;filter(function ($value) use ($type) { if (is_array($type)) { foreach ($type as $classType) { if ($value instanceof $classType) { return true; } } return false; } return $value instanceof $type; }); } /** * Pass the collection to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback) { return $callback($this); } /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue&gt; $class * @return TPipeIntoValue */ public function pipeInto($class) { return new $class($this); } /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable&gt; $callbacks * @return mixed */ public function pipeThrough($callbacks) { return Collection::make($callbacks)-&gt;reduce( fn ($carry, $callback) =&gt; $callback($carry), $this, ); } /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null) { $result = $initial; foreach ($this as $key =&gt; $value) { $result = $callback($result, $value, $key); } return $result; } /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &hellip;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &hellip;$initial) { $result = $initial; foreach ($this as $key =&gt; $value) { $result = call_user_func_array($callback, array_merge($result, [$value, $key])); if (! is_array($result)) { throw new UnexpectedValueException(sprintf( &ldquo;%s::reduceSpread expects reducer to return an array, but got a &lsquo;%s&rsquo; instead.&rdquo;, class_basename(static::class), gettype($result) )); } } return $result; } /** * Reduce an associative collection to a single value. * * @template TReduceWithKeysInitial * @template TReduceWithKeysReturnType * * @param callable(TReduceWithKeysInitial|TReduceWithKeysReturnType, TValue, TKey): TReduceWithKeysReturnType $callback * @param TReduceWithKeysInitial $initial * @return TReduceWithKeysReturnType */ public function reduceWithKeys(callable $callback, $initial = null) { return $this-&gt;reduce($callback, $initial); } /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true) { $useAsCallable = $this-&gt;useAsCallable($callback); return $this-&gt;filter(function ($value, $key) use ($callback, $useAsCallable) { return $useAsCallable ? ! $callback($value, $key) : $value != $callback; }); } /** * Pass the collection to the given callback and then return it. * * @param callable($this): mixed $callback * @return $this */ public function tap(callable $callback) { $callback($this); return $this; } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { $callback = $this-&gt;valueRetriever($key); $exists = []; return $this-&gt;reject(function ($item, $key) use ($callback, $strict, &amp;$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null) { return $this-&gt;unique($key, true); } /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue&gt; */ public function collect() { return new Collection($this-&gt;all()); } /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed&gt; */ public function toArray() { return $this-&gt;map(fn ($value) =&gt; $value instanceof Arrayable ? $value-&gt;toArray() : $value)-&gt;all(); } /** * Convert the object into something JSON serializable. * * @return array&lt;TKey, mixed&gt; */ public function jsonSerialize(): array { return array_map(function ($value) { if ($value instanceof JsonSerializable) { return $value-&gt;jsonSerialize(); } elseif ($value instanceof Jsonable) { return json_decode($value-&gt;toJson(), true); } elseif ($value instanceof Arrayable) { return $value-&gt;toArray(); } return $value; }, $this-&gt;all()); } /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0) { return json_encode($this-&gt;jsonSerialize(), $options); } /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING) { return new CachingIterator($this-&gt;getIterator(), $flags); } /** * Convert the collection to its string representation. * * @return string */ public function __toString() { return $this-&gt;escapeWhenCastingToString ? e($this-&gt;toJson()) : $this-&gt;toJson(); } /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true) { $this-&gt;escapeWhenCastingToString = $escape; return $this; } /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method) { static::$proxies[] = $method; } /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key) { if (! in_array($key, static::$proxies)) { throw new Exception(&ldquo;Property [{$key}] does not exist on this collection instance.&rdquo;); } return new HigherOrderCollectionProxy($this, $key); } /** * Results array of items from Collection or Arrayable. * * @param mixed $items * @return array&lt;TKey, TValue&gt; */ protected function getArrayableItems($items) { if (is_array($items)) { return $items; } return match (true) { $items instanceof WeakMap =&gt; throw new InvalidArgumentException(&lsquo;Collections can not be created using instances of WeakMap.&rsquo;), $items instanceof Enumerable =&gt; $items-&gt;all(), $items instanceof Arrayable =&gt; $items-&gt;toArray(), $items instanceof \Traversable =&gt; iterator_to_array($items), $items instanceof Jsonable =&gt; json_decode($items-&gt;toJson(), true), $items instanceof JsonSerializable =&gt; (array) $items-&gt;jsonSerialize(), $items instanceof UnitEnum =&gt; [$items], default =&gt; (array) $items, }; } /** * Get an operator checker callback. * * @param callable|string $key * @param string|null $operator * @param mixed $value * @return \Closure */ protected function operatorForWhere($key, $operator = null, $value = null) { if ($this-&gt;useAsCallable($key)) { return $key; } if (func_num_args() === 1) { $value = true; $operator = &lsquo;=&rsquo;; } if (func_num_args() === 2) { $value = $operator; $operator = &lsquo;=&rsquo;; } return function ($item) use ($key, $operator, $value) { $retrieved = data_get($item, $key); $strings = array_filter([$retrieved, $value], function ($value) { return is_string($value) || (is_object($value) &amp;&amp; method_exists($value, &lsquo;__toString&rsquo;)); }); if (count($strings) &lt; 2 &amp;&amp; count(array_filter([$retrieved, $value], &lsquo;is_object&rsquo;)) == 1) { return in_array($operator, [&rsquo;!=&rsquo;, &lsquo;&lt;&gt;&rsquo;, &lsquo;!==&rsquo;]); } switch ($operator) { default: case &lsquo;=&rsquo;: case &lsquo;==&rsquo;: return $retrieved == $value; case &lsquo;!=&rsquo;: case &lsquo;&lt;&gt;&rsquo;: return $retrieved != $value; case &lsquo;&lt;&rsquo;: return $retrieved &lt; $value; case &lsquo;&gt;&rsquo;: return $retrieved &gt; $value; case &lsquo;&lt;=&rsquo;: return $retrieved &lt;= $value; case &lsquo;&gt;=&rsquo;: return $retrieved &gt;= $value; case &lsquo;===&rsquo;: return $retrieved === $value; case &lsquo;!==&rsquo;: return $retrieved !== $value; case &lsquo;&lt;=&gt;&rsquo;: return $retrieved &lt;=&gt; $value; } }; } /** * Determine if the given value is callable, but not a string. * * @param mixed $value * @return bool */ protected function useAsCallable($value) { return ! is_string($value) &amp;&amp; is_callable($value); } /** * Get a value retrieving callback. * * @param callable|string|null $value * @return callable */ protected function valueRetriever($value) { if ($this-&gt;useAsCallable($value)) { return $value; } return fn ($item) =&gt; data_get($item, $value); } /** * Make a function to check an item&rsquo;s equality. * * @param mixed $value * @return \Closure(mixed): bool */ protected function equality($value) { return fn ($item) =&gt; $item === $value; } /** * Make a function using another function, by negating its result. * * @param \Closure $callback * @return \Closure */ protected function negate(Closure $callback) { return fn (&hellip;$params) =&gt; ! $callback(&hellip;$params); } /** * Make a function that returns what&rsquo;s passed to it. * * @return \Closure(TValue): TValue */ protected function identity() { return fn ($value) =&gt; $value; } } ?&gt; &lt;?php namespace Illuminate\Support; use ArrayIterator; use Illuminate\Contracts\Support\CanBeEscapedWhenCastToString; use Illuminate\Support\Traits\EnumeratesValues; use stdClass; /** * @template TKey of array-key * * @template-covariant TValue * * @implements \ArrayAccess&lt;TKey, TValue&gt; * @implements \Illuminate\Support\Enumerable&lt;TKey, TValue&gt; */ class Collection implements \ArrayAccess, CanBeEscapedWhenCastToString, Enumerable { /** * @use \Illuminate\Support\Traits\EnumeratesValues&lt;TKey, TValue&gt; */ use EnumeratesValues, Traits\Macroable; /** * The items contained in the collection. * * @var array&lt;TKey, TValue&gt; */ protected $items = []; /** * Create a new collection. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt;|null $items * @return void */ public function __construct($items = []) { $this-&gt;items = $this-&gt;getArrayableItems($items); } /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static&lt;int, int&gt; */ public static function range($from, $to, $step = 1) { return new static(range($from, $to, $step)); } /** * Get all of the items in the collection. * * @return array&lt;TKey, TValue&gt; */ public function all() { return $this-&gt;items; } /** * Get a lazy collection for the items in this collection. * * @return \Illuminate\Support\LazyCollection&lt;TKey, TValue&gt; */ public function lazy() { return new LazyCollection($this-&gt;items); } /** * Get the median of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return float|int|null */ public function median($key = null) { $values = (isset($key) ? $this-&gt;pluck($key) : $this) -&gt;filter(fn ($item) =&gt; ! is_null($item)) -&gt;sort()-&gt;values(); $count = $values-&gt;count(); if ($count === 0) { return; } $middle = (int) ($count / 2); if ($count % 2) { return $values-&gt;get($middle); } return (new static([ $values-&gt;get($middle - 1), $values-&gt;get($middle), ]))-&gt;average(); } /** * Get the mode of a given key. * * @param string|array&lt;array-key, string&gt;|null $key * @return array&lt;int, float|int&gt;|null */ public function mode($key = null) { if ($this-&gt;count() === 0) { return; } $collection = isset($key) ? $this-&gt;pluck($key) : $this; $counts = new static; $collection-&gt;each(fn ($value) =&gt; $counts[$value] = isset($counts[$value]) ? $counts[$value] + 1 : 1); $sorted = $counts-&gt;sort(); $highestValue = $sorted-&gt;last(); return $sorted-&gt;filter(fn ($value) =&gt; $value == $highestValue) -&gt;sort()-&gt;keys()-&gt;all(); } /** * Collapse the collection of items into a single array. * * @return static&lt;int, mixed&gt; */ public function collapse() { return new static(Arr::collapse($this-&gt;items)); } /** * Collapse the collection of items into a single array while preserving its keys. * * @return static&lt;mixed, mixed&gt; */ public function collapseWithKeys() { $results = []; foreach ($this-&gt;items as $key =&gt; $values) { if ($values instanceof Collection) { $values = $values-&gt;all(); } elseif (! is_array($values)) { continue; } $results[$key] = $values; } return new static(array_replace(&hellip;$results)); } /** * Determine if an item exists in the collection. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null) { if (func_num_args() === 1) { if ($this-&gt;useAsCallable($key)) { $placeholder = new stdClass; return $this-&gt;first($key, $placeholder) !== $placeholder; } return in_array($key, $this-&gt;items); } return $this-&gt;contains($this-&gt;operatorForWhere(&hellip;func_get_args())); } /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null) { if (func_num_args() === 2) { return $this-&gt;contains(fn ($item) =&gt; data_get($item, $key) === $value); } if ($this-&gt;useAsCallable($key)) { return ! is_null($this-&gt;first($key)); } return in_array($key, $this-&gt;items, true); } /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null) { return ! $this-&gt;contains(&hellip;func_get_args()); } /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue&gt;|iterable&lt;TCrossJoinKey, TCrossJoinValue&gt; &hellip;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&raquo; */ public function crossJoin(&hellip;$lists) { return new static(Arr::crossJoin( $this-&gt;items, &hellip;array_map([$this, &lsquo;getArrayableItems&rsquo;], $lists) )); } /** * Get the items in the collection that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @return static */ public function diff($items) { return new static(array_diff($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Get the items in the collection that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback) { return new static(array_udiff($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function diffAssoc($items) { return new static(array_diff_assoc($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Get the items in the collection whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback) { return new static(array_diff_uassoc($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function diffKeys($items) { return new static(array_diff_key($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Get the items in the collection whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback) { return new static(array_diff_ukey($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Retrieve duplicate items from the collection. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false) { $items = $this-&gt;map($this-&gt;valueRetriever($callback)); $uniqueItems = $items-&gt;unique(null, $strict); $compare = $this-&gt;duplicateComparator($strict); $duplicates = new static; foreach ($items as $key =&gt; $value) { if ($uniqueItems-&gt;isNotEmpty() &amp;&amp; $compare($value, $uniqueItems-&gt;first())) { $uniqueItems-&gt;shift(); } else { $duplicates[$key] = $value; } } return $duplicates; } /** * Retrieve duplicate items from the collection using strict comparison. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @return static */ public function duplicatesStrict($callback = null) { return $this-&gt;duplicates($callback, true); } /** * Get the comparison function to detect duplicates. * * @param bool $strict * @return callable(TValue, TValue): bool */ protected function duplicateComparator($strict) { if ($strict) { return fn ($a, $b) =&gt; $a === $b; } return fn ($a, $b) =&gt; $a == $b; } /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string $keys * @return static */ public function except($keys) { if (is_null($keys)) { return new static($this-&gt;items); } if ($keys instanceof Enumerable) { $keys = $keys-&gt;all(); } elseif (! is_array($keys)) { $keys = func_get_args(); } return new static(Arr::except($this-&gt;items, $keys)); } /** * Run a filter over each of the items. * * @param (callable(TValue, TKey): bool)|null $callback * @return static */ public function filter(?callable $callback = null) { if ($callback) { return new static(Arr::where($this-&gt;items, $callback)); } return new static(array_filter($this-&gt;items)); } /** * Get the first item from the collection passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null) { return Arr::first($this-&gt;items, $callback, $default); } /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static&lt;int, mixed&gt; */ public function flatten($depth = INF) { return new static(Arr::flatten($this-&gt;items, $depth)); } /** * Flip the items in the collection. * * @return static&lt;TValue, TKey&gt; */ public function flip() { return new static(array_flip($this-&gt;items)); } /** * Remove an item from the collection by key. * * \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TKey&gt;|TKey $keys * * @return $this */ public function forget($keys) { foreach ($this-&gt;getArrayableItems($keys) as $key) { $this-&gt;offsetUnset($key); } return $this; } /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null) { if (array_key_exists($key, $this-&gt;items)) { return $this-&gt;items[$key]; } return value($default); } /** * Get an item from the collection by key or add it to collection if it does not exist. * * @template TGetOrPutValue * * @param mixed $key * @param TGetOrPutValue|(\Closure(): TGetOrPutValue) $value * @return TValue|TGetOrPutValue */ public function getOrPut($key, $value) { if (array_key_exists($key, $this-&gt;items)) { return $this-&gt;items[$key]; } $this-&gt;offsetSet($key, $value = value($value)); return $value; } /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&raquo; */ public function groupBy($groupBy, $preserveKeys = false) { if (! $this-&gt;useAsCallable($groupBy) &amp;&amp; is_array($groupBy)) { $nextGroups = $groupBy; $groupBy = array_shift($nextGroups); } $groupBy = $this-&gt;valueRetriever($groupBy); $results = []; foreach ($this-&gt;items as $key =&gt; $value) { $groupKeys = $groupBy($value, $key); if (! is_array($groupKeys)) { $groupKeys = [$groupKeys]; } foreach ($groupKeys as $groupKey) { $groupKey = match (true) { is_bool($groupKey) =&gt; (int) $groupKey, $groupKey instanceof \BackedEnum =&gt; $groupKey-&gt;value, $groupKey instanceof \Stringable =&gt; (string) $groupKey, default =&gt; $groupKey, }; if (! array_key_exists($groupKey, $results)) { $results[$groupKey] = new static; } $results[$groupKey]-&gt;offsetSet($preserveKeys ? $key : null, $value); } } $result = new static($results); if (! empty($nextGroups)) { return $result-&gt;map-&gt;groupBy($nextGroups, $preserveKeys); } return $result; } /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue&gt; */ public function keyBy($keyBy) { $keyBy = $this-&gt;valueRetriever($keyBy); $results = []; foreach ($this-&gt;items as $key =&gt; $item) { $resolvedKey = $keyBy($item, $key); if (is_object($resolvedKey)) { $resolvedKey = (string) $resolvedKey; } $results[$resolvedKey] = $item; } return new static($results); } /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey&gt; $key * @return bool */ public function has($key) { $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if (! array_key_exists($value, $this-&gt;items)) { return false; } } return true; } /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key) { if ($this-&gt;isEmpty()) { return false; } $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if ($this-&gt;has($value)) { return true; } } return false; } /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string|null $value * @param string|null $glue * @return string */ public function implode($value, $glue = null) { if ($this-&gt;useAsCallable($value)) { return implode($glue ?? &lsquo;&rsquo;, $this-&gt;map($value)-&gt;all()); } $first = $this-&gt;first(); if (is_array($first) || (is_object($first) &amp;&amp; ! $first instanceof Stringable)) { return implode($glue ?? &lsquo;&rsquo;, $this-&gt;pluck($value)-&gt;all()); } return implode($value ?? &lsquo;&rsquo;, $this-&gt;items); } /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersect($items) { return new static(array_intersect($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback) { return new static(array_uintersect($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function intersectAssoc($items) { return new static(array_intersect_assoc($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue&gt;|iterable&lt;array-key, TValue&gt; $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback) { return new static(array_intersect_uassoc($this-&gt;items, $this-&gt;getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed&gt;|iterable&lt;TKey, mixed&gt; $items * @return static */ public function intersectByKeys($items) { return new static(array_intersect_key( $this-&gt;items, $this-&gt;getArrayableItems($items) )); } /** * Determine if the collection is empty or not. * * @phpstan-assert-if-true null $this-&gt;first() * @phpstan-assert-if-true null $this-&gt;last() * * @phpstan-assert-if-false TValue $this-&gt;first() * @phpstan-assert-if-false TValue $this-&gt;last() * * @return bool */ public function isEmpty() { return empty($this-&gt;items); } /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem() { return $this-&gt;count() === 1; } /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return $this-&gt;implode($glue); } $count = $this-&gt;count(); if ($count === 0) { return &lsquo;&rsquo;; } if ($count === 1) { return $this-&gt;last(); } $collection = new static($this-&gt;items); $finalItem = $collection-&gt;pop(); return $collection-&gt;implode($glue).$finalGlue.$finalItem; } /** * Get the keys of the collection items. * * @return static&lt;int, TKey&gt; */ public function keys() { return new static(array_keys($this-&gt;items)); } /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null) { return Arr::last($this-&gt;items, $callback, $default); } /** * Get the values of a given key. * * @param string|int|array&lt;array-key, string&gt;|null $value * @param string|null $key * @return static&lt;array-key, mixed&gt; */ public function pluck($value, $key = null) { return new static(Arr::pluck($this-&gt;items, $value, $key)); } /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue&gt; */ public function map(callable $callback) { return new static(Arr::map($this-&gt;items, $callback)); } /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue&gt; $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&raquo; */ public function mapToDictionary(callable $callback) { $dictionary = []; foreach ($this-&gt;items as $key =&gt; $item) { $pair = $callback($item, $key); $key = key($pair); $value = reset($pair); if (! isset($dictionary[$key])) { $dictionary[$key] = []; } $dictionary[$key][] = $value; } return new static($dictionary); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue&gt; $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue&gt; */ public function mapWithKeys(callable $callback) { return new static(Arr::mapWithKeys($this-&gt;items, $callback)); } /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function merge($items) { return new static(array_merge($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue&gt;|iterable&lt;TKey, TMergeRecursiveValue&gt; $items * @return static&lt;TKey, TValue|TMergeRecursiveValue&gt; */ public function mergeRecursive($items) { return new static(array_merge_recursive($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Multiply the items in the collection by the multiplier. * * @param int $multiplier * @return static */ public function multiply(int $multiplier) { $new = new static; for ($i = 0; $i &lt; $multiplier; $i++) { $new-&gt;push(&hellip;$this-&gt;items); } return $new; } /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue&gt;|iterable&lt;array-key, TCombineValue&gt; $values * @return static&lt;TValue, TCombineValue&gt; */ public function combine($values) { return new static(array_combine($this-&gt;all(), $this-&gt;getArrayableItems($values))); } /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function union($items) { return new static($this-&gt;items + $this-&gt;getArrayableItems($items)); } /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0) { $new = []; $position = 0; foreach ($this-&gt;slice($offset)-&gt;items as $item) { if ($position % $step === 0) { $new[] = $item; } $position++; } return new static($new); } /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string|null $keys * @return static */ public function only($keys) { if (is_null($keys)) { return new static($this-&gt;items); } if ($keys instanceof Enumerable) { $keys = $keys-&gt;all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::only($this-&gt;items, $keys)); } /** * Select specific values from the items within the collection. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey&gt;|array&lt;array-key, TKey&gt;|string|null $keys * @return static */ public function select($keys) { if (is_null($keys)) { return new static($this-&gt;items); } if ($keys instanceof Enumerable) { $keys = $keys-&gt;all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::select($this-&gt;items, $keys)); } /** * Get and remove the last N items from the collection. * * @param int $count * @return static&lt;int, TValue&gt;|TValue|null */ public function pop($count = 1) { if ($count === 1) { return array_pop($this-&gt;items); } if ($this-&gt;isEmpty()) { return new static; } $results = []; $collectionCount = $this-&gt;count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_pop($this-&gt;items)); } return new static($results); } /** * Push an item onto the beginning of the collection. * * @param TValue $value * @param TKey $key * @return $this */ public function prepend($value, $key = null) { $this-&gt;items = Arr::prepend($this-&gt;items, &hellip;func_get_args()); return $this; } /** * Push one or more items onto the end of the collection. * * @param TValue &hellip;$values * @return $this */ public function push(&hellip;$values) { foreach ($values as $value) { $this-&gt;items[] = $value; } return $this; } /** * Prepend one or more items to the beginning of the collection. * * @param TValue &hellip;$values * @return $this */ public function unshift(&hellip;$values) { array_unshift($this-&gt;items, &hellip;$values); return $this; } /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue&gt; $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue&gt; */ public function concat($source) { $result = new static($this); foreach ($source as $item) { $result-&gt;push($item); } return $result; } /** * Get and remove an item from the collection. * * @template TPullDefault * * @param TKey $key * @param TPullDefault|(\Closure(): TPullDefault) $default * @return TValue|TPullDefault */ public function pull($key, $default = null) { return Arr::pull($this-&gt;items, $key, $default); } /** * Put an item in the collection by key. * * @param TKey $key * @param TValue $value * @return $this */ public function put($key, $value) { $this-&gt;offsetSet($key, $value); return $this; } /** * Get one or a specified number of items randomly from the collection. * * @param (callable(self&lt;TKey, TValue&gt;): int)|int|null $number * @param bool $preserveKeys * @return static&lt;int, TValue&gt;|TValue * * @throws \InvalidArgumentException */ public function random($number = null, $preserveKeys = false) { if (is_null($number)) { return Arr::random($this-&gt;items); } if (is_callable($number)) { return new static(Arr::random($this-&gt;items, $number($this), $preserveKeys)); } return new static(Arr::random($this-&gt;items, $number, $preserveKeys)); } /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replace($items) { return new static(array_replace($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue&gt;|iterable&lt;TKey, TValue&gt; $items * @return static */ public function replaceRecursive($items) { return new static(array_replace_recursive($this-&gt;items, $this-&gt;getArrayableItems($items))); } /** * Reverse items order. * * @return static */ public function reverse() { return new static(array_reverse($this-&gt;items, true)); } /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TKey|false */ public function search($value, $strict = false) { if (! $this-&gt;useAsCallable($value)) { return array_search($value, $this-&gt;items, $strict); } foreach ($this-&gt;items as $key =&gt; $item) { if ($value($item, $key)) { return $key; } } return false; } /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false) { $key = $this-&gt;search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this-&gt;keys())-&gt;search($key); if ($position === 0) { return null; } return $this-&gt;get($keys-&gt;get($position - 1)); } /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false) { $key = $this-&gt;search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this-&gt;keys())-&gt;search($key); if ($position === $keys-&gt;count() - 1) { return null; } return $this-&gt;get($keys-&gt;get($position + 1)); } /** * Get and remove the first N items from the collection. * * @param int $count * @return static&lt;int, TValue&gt;|TValue|null * * @throws \InvalidArgumentException */ public function shift($count = 1) { if ($count &lt; 0) { throw new InvalidArgumentException(&lsquo;Number of shifted items may not be less than zero.&rsquo;); } if ($this-&gt;isEmpty()) { return null; } if ($count === 0) { return new static; } if ($count === 1) { return array_shift($this-&gt;items); } $results = []; $collectionCount = $this-&gt;count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_shift($this-&gt;items)); } return new static($results); } /** * Shuffle the items in the collection. * * @return static */ public function shuffle() { return new static(Arr::shuffle($this-&gt;items)); } /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static&gt; */ public function sliding($size = 2, $step = 1) { $chunks = floor(($this-&gt;count() - $size) / $step) + 1; return static::times($chunks, fn ($number) =&gt; $this-&gt;slice(($number - 1) * $step, $size)); } /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count) { return $this-&gt;slice($count); } /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value) { return new static($this-&gt;lazy()-&gt;skipUntil($value)-&gt;all()); } /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value) { return new static($this-&gt;lazy()-&gt;skipWhile($value)-&gt;all()); } /** * Slice the underlying collection array. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null) { return new static(array_slice($this-&gt;items, $offset, $length, true)); } /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function split($numberOfGroups) { if ($this-&gt;isEmpty()) { return new static; } $groups = new static; $groupSize = floor($this-&gt;count() / $numberOfGroups); $remain = $this-&gt;count() % $numberOfGroups; $start = 0; for ($i = 0; $i &lt; $numberOfGroups; $i++) { $size = $groupSize; if ($i &lt; $remain) { $size++; } if ($size) { $groups-&gt;push(new static(array_slice($this-&gt;items, $start, $size))); $start += $size; } } return $groups; } /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static&gt; */ public function splitIn($numberOfGroups) { return $this-&gt;chunk((int) ceil($this-&gt;count() / $numberOfGroups)); } /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null) { $filter = func_num_args() &gt; 1 ? $this-&gt;operatorForWhere(&hellip;func_get_args()) : $key; $items = $this-&gt;unless($filter == null)-&gt;filter($filter); $count = $items-&gt;count(); if ($count === 0) { throw new ItemNotFoundException; } if ($count &gt; 1) { throw new MultipleItemsFoundException($count); } return $items-&gt;first(); } /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null) { $filter = func_num_args() &gt; 1 ? $this-&gt;operatorForWhere(&hellip;func_get_args()) : $key; $placeholder = new stdClass(); $item = $this-&gt;first($filter, $placeholder); if ($item === $placeholder) { throw new ItemNotFoundException; } return $item; } /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static&gt; */ public function chunk($size) { if ($size &lt;= 0) { return new static; } $chunks = []; foreach (array_chunk($this-&gt;items, $size, true) as $chunk) { $chunks[] = new static($chunk); } return new static($chunks); } /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue&gt;): bool $callback * @return static&lt;int, static&lt;int, TValue&raquo; */ public function chunkWhile(callable $callback) { return new static( $this-&gt;lazy()-&gt;chunkWhile($callback)-&gt;mapInto(static::class) ); } /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null) { $items = $this-&gt;items; $callback &amp;&amp; is_callable($callback) ? uasort($items, $callback) : asort($items, $callback ?? SORT_REGULAR); return new static($items); } /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR) { $items = $this-&gt;items; arsort($items, $options); return new static($items); } /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false) { if (is_array($callback) &amp;&amp; ! is_callable($callback)) { return $this-&gt;sortByMany($callback, $options); } $results = []; $callback = $this-&gt;valueRetriever($callback); // First we will loop through the items and get the comparator from a callback // function which we were given. Then, we will sort the returned values and // grab all the corresponding values for the sorted keys from this array. foreach ($this-&gt;items as $key =&gt; $value) { $results[$key] = $callback($value, $key); } $descending ? arsort($results, $options) : asort($results, $options); // Once we have sorted all of the keys in the array, we will loop through them // and grab the corresponding model so we can set the underlying items list // to the sorted version. Then we&rsquo;ll just return the collection instance. foreach (array_keys($results) as $key) { $results[$key] = $this-&gt;items[$key]; } return new static($results); } /** * Sort the collection using multiple comparisons. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt; $comparisons * @param int $options * @return static */ protected function sortByMany(array $comparisons = [], int $options = SORT_REGULAR) { $items = $this-&gt;items; uasort($items, function ($a, $b) use ($comparisons, $options) { foreach ($comparisons as $comparison) { $comparison = Arr::wrap($comparison); $prop = $comparison[0]; $ascending = Arr::get($comparison, 1, true) === true || Arr::get($comparison, 1, true) === &lsquo;asc&rsquo;; if (! is_string($prop) &amp;&amp; is_callable($prop)) { $result = $prop($a, $b); } else { $values = [data_get($a, $prop), data_get($b, $prop)]; if (! $ascending) { $values = array_reverse($values); } if (($options &amp; SORT_FLAG_CASE) === SORT_FLAG_CASE) { if (($options &amp; SORT_NATURAL) === SORT_NATURAL) { $result = strnatcasecmp($values[0], $values[1]); } else { $result = strcasecmp($values[0], $values[1]); } } else { $result = match ($options) { SORT_NUMERIC =&gt; intval($values[0]) &lt;=&gt; intval($values[1]), SORT_STRING =&gt; strcmp($values[0], $values[1]), SORT_NATURAL =&gt; strnatcmp((string) $values[0], (string) $values[1]), SORT_LOCALE_STRING =&gt; strcoll($values[0], $values[1]), default =&gt; $values[0] &lt;=&gt; $values[1], }; } } if ($result === 0) { continue; } return $result; } }); return new static($items); } /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}&gt;|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR) { if (is_array($callback) &amp;&amp; ! is_callable($callback)) { foreach ($callback as $index =&gt; $key) { $comparison = Arr::wrap($key); $comparison[1] = &lsquo;desc&rsquo;; $callback[$index] = $comparison; } } return $this-&gt;sortBy($callback, $options, true); } /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false) { $items = $this-&gt;items; $descending ? krsort($items, $options) : ksort($items, $options); return new static($items); } /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR) { return $this-&gt;sortKeys($options, true); } /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback) { $items = $this-&gt;items; uksort($items, $callback); return new static($items); } /** * Splice a portion of the underlying collection array. * * @param int $offset * @param int|null $length * @param array&lt;array-key, TValue&gt; $replacement * @return static */ public function splice($offset, $length = null, $replacement = []) { if (func_num_args() === 1) { return new static(array_splice($this-&gt;items, $offset)); } return new static(array_splice($this-&gt;items, $offset, $length, $this-&gt;getArrayableItems($replacement))); } /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit) { if ($limit &lt; 0) { return $this-&gt;slice($limit, abs($limit)); } return $this-&gt;slice(0, $limit); } /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value) { return new static($this-&gt;lazy()-&gt;takeUntil($value)-&gt;all()); } /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value) { return new static($this-&gt;lazy()-&gt;takeWhile($value)-&gt;all()); } /** * Transform each item in the collection using a callback. * * @param callable(TValue, TKey): TValue $callback * @return $this */ public function transform(callable $callback) { $this-&gt;items = $this-&gt;map($callback)-&gt;all(); return $this; } /** * Flatten a multi-dimensional associative array with dots. * * @return static */ public function dot() { return new static(Arr::dot($this-&gt;all())); } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot() { return new static(Arr::undot($this-&gt;all())); } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { if (is_null($key) &amp;&amp; $strict === false) { return new static(array_unique($this-&gt;items, SORT_REGULAR)); } $callback = $this-&gt;valueRetriever($key); $exists = []; return $this-&gt;reject(function ($item, $key) use ($callback, $strict, &amp;$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue&gt; */ public function values() { return new static(array_values($this-&gt;items)); } /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])-&gt;zip([4, 5, 6]); * =&gt; [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue&gt;|iterable&lt;array-key, TZipValue&gt; &hellip;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&raquo; */ public function zip($items) { $arrayableItems = array_map(fn ($items) =&gt; $this-&gt;getArrayableItems($items), func_get_args()); $params = array_merge([fn () =&gt; new static(func_get_args()), $this-&gt;items], $arrayableItems); return new static(array_map(&hellip;$params)); } /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue&gt; */ public function pad($size, $value) { return new static(array_pad($this-&gt;items, $size, $value)); } /** * Get an iterator for the items. * * @return \ArrayIterator&lt;TKey, TValue&gt; */ public function getIterator(): \Traversable { return new ArrayIterator($this-&gt;items); } /** * Count the number of items in the collection. * * @return int */ public function count(): int { return count($this-&gt;items); } /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int&gt; */ public function countBy($countBy = null) { return new static($this-&gt;lazy()-&gt;countBy($countBy)-&gt;all()); } /** * Add an item to the collection. * * @param TValue $item * @return $this */ public function add($item) { $this-&gt;items[] = $item; return $this; } /** * Get a base Support collection instance from this collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue&gt; */ public function toBase() { return new self($this); } /** * Determine if an item exists at an offset. * * @param TKey $key * @return bool */ public function offsetExists($key): bool { return isset($this-&gt;items[$key]); } /** * Get an item at a given offset. * * @param TKey $key * @return TValue */ public function offsetGet($key): mixed { return $this-&gt;items[$key]; } /** * Set the item at a given offset. * * @param TKey|null $key * @param TValue $value * @return void */ public function offsetSet($key, $value): void { if (is_null($key)) { $this-&gt;items[] = $value; } else { $this-&gt;items[$key] = $value; } } /** * Unset the item at a given offset. * * @param TKey $key * @return void */ public function offsetUnset($key): void { unset($this-&gt;items[$key]); } } ?&gt; &lt;?php class Product { private string $title; private string $description; private int $price; private string $currency; private string $category; private string $brand; private Collection $options; /** * @param string $title * @param string $description * @param int $price * @param string $currency * @param string $category * @param string $brand * @param Collection $options */ public function __construct(string $title, string $description, int $price, string $currency, string $category, string $brand, Collection $options) { $this-&gt;title = $title; $this-&gt;description = $description; $this-&gt;price = $price; $this-&gt;currency = $currency; $this-&gt;category = $category; $this-&gt;brand = $brand; $this-&gt;options = $options; } /** * @return string */ public function getTitle(): string { return $this-&gt;title; } /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @return string */ public function getDescription(): string { return $this-&gt;description; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @return int */ public function getPrice(): int { return $this-&gt;price; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } /** * @return string */ public function getCurrency(): string { return $this-&gt;currency; } /** * @param string $currency */ public function setCurrency(string $currency): void { $this-&gt;currency = $currency; } /** * @return string */ public function getCategory(): string { return $this-&gt;category; } /** * @param string $category */ public function setCategory(string $category): void { $this-&gt;category = $category; } /** * @return string */ public function getBrand(): string { return $this-&gt;brand; } /** * @param string $brand */ public function setBrand(string $brand): void { $this-&gt;brand = $brand; } /** * @return Collection */ public function getOptions(): array { return $this-&gt;options; } /** * @param Collection $options */ public function setOptions(Collection $options): void { $this-&gt;options = $options; } } class Option { private string $title; private string $description; private int $price; private Collection $items; /** * @param string $title * @param string $description * @param int $price * @param Collection $items */ public function __construct(string $title, string $description, int $price, Collection $items) { $this-&gt;title = $title; $this-&gt;description = $description; $this-&gt;price = $price; $this-&gt;items = $items; } /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } /** * @param Collection $items */ public function setItems(Collection $items): void { $this-&gt;items = $items; } } class OptionItem { private string $title; private string $description; private int $price; /** * @param string $title * @param string $description * @param int $price */ public function __construct(string $title, string $description, int $price) { $this-&gt;title = $title; $this-&gt;description = $description; $this-&gt;price = $price; } /** * @param string $title */ public function setTitle(string $title): void { $this-&gt;title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this-&gt;description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this-&gt;price = $price; } } $products = new Collection(); $start = microtime(true); for ($k = 0; $k &lt;= 1000; $k++) { $options = new Collection(); for ($j = 0; $j &lt;= 10; $j++) { $optionItems = new Collection(); for ($i = 0; $i &lt;= 100; $i++) { $optionItem = new Collection(new OptionItem(title: &lsquo;OptionItem&rsquo; . $i, description: &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, price: random_int(1000, 10000))); $optionItems-&gt;add($optionItem); } $option = new Collection(new Option(title: &lsquo;Option&rsquo; . $j, description: &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, price: random_int(1000, 10000), items: $optionItems)); $options-&gt;add($option); } $products-&gt;add(new Collection(new Product(title: &lsquo;Product&rsquo; . $k, description: &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, price: random_int(1000, 10000), currency: &lsquo;USD&rsquo;, category: &lsquo;Category&rsquo; . $k, brand: &lsquo;Brand&rsquo; . $k, options: $options))); } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br&gt;&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br&gt;&rsquo;;</td>
</tr>
</tbody>
</table>
]]></description></item><item><title>윈도우 컴포저 패키지 설치시 오류 처리 방법</title><link>http://blog.hodory.dev/2020/04/14/composer-error-on-windows/</link><pubDate>Tue, 14 Apr 2020 23:38:07 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2020/04/14/composer-error-on-windows/</guid><description><![CDATA[<h2 id="your-requirements-could-not-be-resolved-to-an-installable-set-of-packages" class="headerLink">
    <a href="#your-requirements-could-not-be-resolved-to-an-installable-set-of-packages" class="header-mark"></a>Your requirements could not be resolved to an installable set of packages.</h2><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Your requirements could not be resolved to an installable <span class="nb">set</span> of packages.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  Problem <span class="m">1</span>
</span></span><span class="line"><span class="cl">    - laravel/horizon v4.2.1 requires ext-pcntl * -&gt; the requested PHP extension pcntl is missing from your system.
</span></span><span class="line"><span class="cl">    - laravel/horizon v4.2.0 requires ext-pcntl * -&gt; the requested PHP extension pcntl is missing from your system.
</span></span><span class="line"><span class="cl">    - laravel/horizon 4.x-dev requires ext-pcntl * -&gt; the requested PHP extension pcntl is missing from your system.
</span></span><span class="line"><span class="cl">    - Installation request <span class="k">for</span> laravel/horizon ^4.2 -&gt; satisfiable by laravel/horizon<span class="o">[</span>4.x-dev, v4.2.0, v4.2.1<span class="o">]</span>.
</span></span></code></pre></div><p>Laravel Horizon을 windows에서 설치하려 할 때 위와 같은 오류가 발생하였습니다.</p>
<h2 id="해결방안" class="headerLink">
    <a href="#%ed%95%b4%ea%b2%b0%eb%b0%a9%ec%95%88" class="header-mark"></a>해결방안</h2><p>pcntl은 윈도우에서 지원이 되지 않으므로 Docker 또는 Vargrant와 같은 가상환경을 사용해야 합니다.
<a href="https://www.php.net/manual/en/pcntl.installation.php" target="_blank" rel="noopener noreferrer">Link</a></p>
<p>또는 아래와 같이 실행하여 설치를 완료 할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">composer require laravel/horizon --ignore-platform-reqs
</span></span></code></pre></div><p><code>--ignore-platform-reqs</code> 옵션의 설명은
해당 링크에서 확인할 수 있습니다. <a href="https://getcomposer.org/doc/03-cli.md" target="_blank" rel="noopener noreferrer">Link</a></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-plaintext" data-lang="plaintext"><span class="line"><span class="cl">ignore php, hhvm, lib-* and ext-* requirements and force the installation even if the local machine does not fulfill these. See also the platform config option.
</span></span></code></pre></div><p>패키지를 설치하는데 필요한 조건을 충족하지 못하더라도 무시하고 설치를 실행하는 옵션입니다.</p>
<p>필요 조건을 모두 충족하지 않은 경우이므로 정상동작에 실패 할 수 있습니다.</p>
]]></description></item><item><title>[PHP] InvalidArgumentException : Unable to locate factory with name [default]</title><link>http://blog.hodory.dev/2020/01/10/unable-to-locale-factory-with-name-default/</link><pubDate>Fri, 10 Jan 2020 00:36:54 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2020/01/10/unable-to-locale-factory-with-name-default/</guid><description><![CDATA[<h2 id="발단" class="headerLink">
    <a href="#%eb%b0%9c%eb%8b%a8" class="header-mark"></a>발단</h2><p>Laravel Framework로 TDD를 진행중에 Unit Test를 하기 위해 artisan 콘솔을 이용하여 <code>TaskTest</code> 라는 이름의 테스트 클래스를 생성하였습니다.</p>
<pre tabindex="0"><code class="language-shellscript" data-lang="shellscript">$ php artisan make:test TaskTest --unit
</code></pre><p>코드는 간단했습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nx">Tests\Unit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">App\Project</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Illuminate\Foundation\Testing\RefreshDatabase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TaskTest</span> <span class="k">extends</span> <span class="nx">TestCase</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="nx">RefreshDatabase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="sd">/**
</span></span></span><span class="line"><span class="cl"><span class="sd">     * @test
</span></span></span><span class="line"><span class="cl"><span class="sd">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">it_belongs_to_a_project</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$task</span> <span class="o">=</span> <span class="nx">factory</span><span class="p">(</span><span class="s1">&#39;App\Task&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">assertInstanceOf</span><span class="p">(</span><span class="nx">Project</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nv">$task</span><span class="o">-&gt;</span><span class="na">project</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>해당 테스트를 생성 후 아래와 같이 PHPUnit으로 해당 테스트를 실행하였더니</p>
<pre tabindex="0"><code class="language-shellscript" data-lang="shellscript">$ ./vendor/bin/phpunit --filter it_belongs_to_a_project
</code></pre><p>아래 이미지와 같은 에러가 나왔습니다.
<figure><img
        
        loading="lazy"
        src="/images/Unable-to-locale-factory-with-name-default/1.jpg"
        srcset="/images/Unable-to-locale-factory-with-name-default/1.jpg, /images/Unable-to-locale-factory-with-name-default/1.jpg 1.5x, /images/Unable-to-locale-factory-with-name-default/1.jpg 2x"
        sizes="auto"
        alt="/images/Unable-to-locale-factory-with-name-default/1.jpg"
        title="/images/Unable-to-locale-factory-with-name-default/1.jpg" ></figure></p>
<h2 id="invalidargumentexception--unable-to-locate-factory-with-name-default-apptask" class="headerLink">
    <a href="#invalidargumentexception--unable-to-locate-factory-with-name-default-apptask" class="header-mark"></a><code>InvalidArgumentException : Unable to locate factory with name [default] [App\Task]</code></h2><p>과연 무엇이 문제일까 싶어 해당 모델의 migration이 제대로 안된걸까요?</p>
<!-- raw HTML omitted -->
<p>migrate 명령어도 실행해보았고, Controller Test에서 사용할때에는 문제가 없었지만 factory 코드도 다시 작성 해보았습니다.</p>
<p>구글링으로 <a href="https://www.lesstif.com/pages/viewpage.action?pageId=26084077" target="_blank" rel="noopener noreferrer">정광섭님의 위키</a>를 참고했을때는 factory에 클래스가 제대로 설정된게 아닌 경우라 하여,<!-- raw HTML omitted -->
<code>factory('App\Task')</code> 와 <code>factory(Task::class)</code> 와 <code>factory(\App\Task::class)</code> 모두 테스트 해보았는데 모두 동작을 안했고,<!-- raw HTML omitted --></p>
<p>Laracast와 StackoverFlow에서는 phpunit의 setup 메소드를 상속하여,<!-- raw HTML omitted -->
<code>parent::setup()</code> 을 호출하고, factory를 호출하면 해결된다는 답변들도 확인하였으나, 제게 맞는 해결 방법은 아니였습니다.</p>
<p>하지만 라라캐스트 질문의 <a href="https://laracasts.com/discuss/channels/testing/unable-to-locate-factory-with-name-default?page=1#reply=400775" target="_blank" rel="noopener noreferrer">어떤 답변</a>에서는
<code>--unit</code>으로 생성한 테스트 클래스가 상속하는 TestCase 클래스가 <code>\Tests\TestCase</code> 가 아닌 <code>\PHPUnit\Framework\TestCase</code>여서 발생했다는 내용이 있었습니다.</p>
<h2 id="해결" class="headerLink">
    <a href="#%ed%95%b4%ea%b2%b0" class="header-mark"></a>해결</h2><p>저도 이걸 확인하고 바로 위의 코드를 아래와 같이 변경하였습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nx">Tests\Unit</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">App\Project</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Illuminate\Foundation\Testing\RefreshDatabase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">-</span> <span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="o">+</span> <span class="k">use</span> <span class="nx">Tests\TestCase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TaskTest</span> <span class="k">extends</span> <span class="nx">TestCase</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">use</span> <span class="nx">RefreshDatabase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="sd">/**
</span></span></span><span class="line"><span class="cl"><span class="sd">     * @test
</span></span></span><span class="line"><span class="cl"><span class="sd">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">it_belongs_to_a_project</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$task</span> <span class="o">=</span> <span class="nx">factory</span><span class="p">(</span><span class="s1">&#39;App\Task&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">create</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">assertInstanceOf</span><span class="p">(</span><span class="nx">Project</span><span class="o">::</span><span class="na">class</span><span class="p">,</span> <span class="nv">$task</span><span class="o">-&gt;</span><span class="na">project</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>네임스페이스를 확인할 생각은 전혀 하지 못했는데, 일반적인 테스트 클래스는 모두 <code>use Tests\TestCase;</code> 이렇게 선언되어있었으나<!-- raw HTML omitted -->
<code>--unit</code>으로 선언했을때는 <code>use PHPUnit\Framework\TestCase;</code>으로 자동 설정되어있었습니다.</p>
<p>아직까지 artisan에서 <code>--unit</code> 옵션을 사용하여 테스트 클래스를 만들었을때 namespace 변경 없이 하는 방법은 찾지 못하였는데,<!-- raw HTML omitted -->
<code>Illuminate\Foundation\Testing\TestCase</code> 에서 무언가 factory 메소드의 파라미터로 모델을 주입해주는 설정해주는것으로 보입니다.</p>
<blockquote>
<p>참고자료</p>
</blockquote>
<ul>
<li><a href="https://www.lesstif.com/pages/viewpage.action?pageId=26084077" target="_blank" rel="noopener noreferrer">정광섭님의 위키</a></li>
<li><a href="https://laracasts.com/discuss/channels/testing/unable-to-locate-factory-with-name-default?page=1#reply=400775" target="_blank" rel="noopener noreferrer">Laracast &ldquo;Unable to locate factory with name [default]??&rdquo;- amcsi</a></li>
</ul>
]]></description></item><item><title>PHPUnit Annotation 정리</title><link>http://blog.hodory.dev/2019/11/25/phpunit-annotations/</link><pubDate>Mon, 25 Nov 2019 01:18:24 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/11/25/phpunit-annotations/</guid><description><![CDATA[<h2 id="서론" class="headerLink">
    <a href="#%ec%84%9c%eb%a1%a0" class="header-mark"></a>서론</h2><hr>
<p>PHP Unit을 사용하면서도 잘 모르는 어노테이션을 PHPUnit v8.4 기준(2019-11-19 최신버전)으로 정리하였습니다.</p>
<h2 id="author" class="headerLink">
    <a href="#author" class="header-mark"></a>@author</h2><h3 id="테스트를-작성자별-그룹화-필터링-할-때" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8%eb%a5%bc-%ec%9e%91%ec%84%b1%ec%9e%90%eb%b3%84-%ea%b7%b8%eb%a3%b9%ed%99%94-%ed%95%84%ed%84%b0%eb%a7%81-%ed%95%a0-%eb%95%8c" class="header-mark"></a>테스트를 작성자별 그룹화 필터링 할 때</h3><hr>
<p><code>@group</code> 어노테이션의 별칭으로, 테스트를 작성자별로 그룹화하여 필터링 하는데 사용할 수 있습니다.</p>
<h2 id="after" class="headerLink">
    <a href="#after" class="header-mark"></a>@after</h2><h3 id="각-테스트가-끝난-뒤-실행-하려-할-때" class="headerLink">
    <a href="#%ea%b0%81-%ed%85%8c%ec%8a%a4%ed%8a%b8%ea%b0%80-%eb%81%9d%eb%82%9c-%eb%92%a4-%ec%8b%a4%ed%96%89-%ed%95%98%eb%a0%a4-%ed%95%a0-%eb%95%8c" class="header-mark"></a>각 테스트가 끝난 뒤 실행 하려 할 때</h3><hr>
<p>각 테스트 메소드들이 실행 된 후, 특정 메소드를 실행하고자 할때 사용할 수 있습니다.</p>
<p>각 테스트가 끝난 뒤 트랜잭션 커밋or롤백을 한다거나, 생성된 파일을 삭제하는 등의 처리를 하는데 사용하면 좋을 것 같습니다.</p>
<!-- raw HTML omitted -->
<pre><code>namespace Tests;

use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    /**
     * @after
     */
    public function afterDo()
    {
        echo &quot;After Method Called&quot; . PHP_EOL;
    }

    public function test1()
    {
        echo &quot;test1 Method Called&quot; . PHP_EOL;
        self::assertTrue(true);
    }

    public function test2()
    {
        echo &quot;test2 Method Called&quot; . PHP_EOL;
        self::assertTrue(true);
    }
}

// 출력 결과
test1 Method Called
After Method Called
test2 Method Called
After Method Called
```
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="afterclass" class="headerLink">
    <a href="#afterclass" class="header-mark"></a>@afterClass</h2><h3 id="모든-테스트가-끝난-후-실행-하려-할-때" class="headerLink">
    <a href="#%eb%aa%a8%eb%93%a0-%ed%85%8c%ec%8a%a4%ed%8a%b8%ea%b0%80-%eb%81%9d%eb%82%9c-%ed%9b%84-%ec%8b%a4%ed%96%89-%ed%95%98%eb%a0%a4-%ed%95%a0-%eb%95%8c" class="header-mark"></a>모든 테스트가 끝난 후 실행 하려 할 때</h3><hr>
<p>모든 테스트가 끝난 후, 공유된 자원들을 정리하기 위해 호출할 정적 메소드를 지정 할 수 있습니다.</p>
<p>해당 부분에서 테스트 실행시 만든 DB 커넥션을 회수하거나, 전체 트랜잭션을 처리 하거나, 소켓을 닫는 등의 처리를 할 수 있을것 같습니다.</p>
<!-- raw HTML omitted -->
<pre><code>namespace Tests;

use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    /**
     * @afterClass
     */
    public static function afterClassDo()
    {
        echo &quot;After Class Method Called&quot; . PHP_EOL;
    }

    public function test1()
    {
        echo &quot;test1 Method Called&quot; . PHP_EOL;
        self::assertTrue(true);
    }

    public function test2()
    {
        echo &quot;test2 Method Called&quot; . PHP_EOL;
        self::assertTrue(true);
    }
}

// 출력 결과
test1 Method Called
test2 Method Called
After Class Method Called
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="backupglobals" class="headerLink">
    <a href="#backupglobals" class="header-mark"></a>@backupGlobals</h2><h3 id="글로벌-변수를-유지하고-싶다면" class="headerLink">
    <a href="#%ea%b8%80%eb%a1%9c%eb%b2%8c-%eb%b3%80%ec%88%98%eb%a5%bc-%ec%9c%a0%ec%a7%80%ed%95%98%ea%b3%a0-%ec%8b%b6%eb%8b%a4%eb%a9%b4" class="header-mark"></a>글로벌 변수를 유지하고 싶다면</h3><hr>
<p>모든 글로벌 변수를 각 테스트 전에 백업하고, 각 테스트 이후 해당 백업을 복원시킵니다.</p>
<p>메소드 레벨에서 재정의가 가능합니다.</p>
<p>해당 설명만으로는 이해가 잘 되지 않아서 직접 예제 코드를 만들어 보았습니다.
클래스 스코프 밖에 정의된 글로벌 변수인 <code>$className</code>을 <code>@backupGlobals</code> 어노테이션이 enabled 되어 있는 테스트 코드에서는 실행이전 값을 백업하여두고 테스트가 끝나면 복원이 되어,
두번째 테스트코드에서도 &ldquo;MyTest&quot;라는 값을 가지고 있게됩니다.</p>
<!-- raw HTML omitted -->
<pre><code>namespace Tests;

use PHPUnit\Framework\TestCase;

$className = &quot;MyTest&quot;;

/**
 * @backupGlobals enabled
 */
class MyTest extends TestCase
{
    public function test_글로벌변수를_백업하고_변경()
    {
        global $className;
        $this-&gt;assertEquals($className, &quot;MyTest&quot;);
        $className = &quot;Foo&quot;;
    }

    /**
     * @backupGlobals disabled
     */
    public function test_글로벌변수를_백업하지_않고_변경()
    {
        global $className;
        $this-&gt;assertEquals($className, &quot;MyTest&quot;);
        $className = &quot;Bar&quot;;
    }

    public function test_글로벌변수를_백업되어있는지_체크()
    {
        global $className;
        $this-&gt;assertEquals($className, &quot;Bar&quot;);
    }
}
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="backupstaticattributes" class="headerLink">
    <a href="#backupstaticattributes" class="header-mark"></a>@backupStaticAttributes</h2><h3 id="정적-속성을-사용하려-할-때" class="headerLink">
    <a href="#%ec%a0%95%ec%a0%81-%ec%86%8d%ec%84%b1%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%98%eb%a0%a4-%ed%95%a0-%eb%95%8c" class="header-mark"></a><del>정적 속성을 사용하려 할 때</del></h3><hr>
<p><del>선언된 클래스들 안의 모든 정적 속성을 각 테스트 전에 백업하고, 각 테스트 후에 해당 백업을 복원 시킵니다.</del></p>
<p><del>클래스 레벨에도 선언 가능하며, 각 테스트 메소드에서 추가 제어 가능합니다.</del></p>
<!-- raw HTML omitted -->
<pre><code>use PHPUnit\Framework\TestCase;
        
/**
 * @backupStaticAttributes enabled
 */
class MyTest extends TestCase
{
    public function test_정적속성을_사용하는_테스트()
    {
        // ...
    }

    /**
     * @backupStaticAttributes disabled
     */
    public function test_정적속성을_사용하지_않는_테스트()
    {
        // ...
    }
}
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="before" class="headerLink">
    <a href="#before" class="header-mark"></a>@before</h2><h3 id="각-테스트-실행전에-실행-하려-할-때" class="headerLink">
    <a href="#%ea%b0%81-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%8b%a4%ed%96%89%ec%a0%84%ec%97%90-%ec%8b%a4%ed%96%89-%ed%95%98%eb%a0%a4-%ed%95%a0-%eb%95%8c" class="header-mark"></a>각 테스트 실행전에 실행 하려 할 때</h3><hr>
<p>각 테스트 메소드가 호출되기 전에 실행할 메소드를 지정할 수 있습니다.</p>
<p>아래와 같이 beforeMethod는 각 메소드 호출전에 실행되지만,
users 배열의 값이 증가되지는 않습니다.</p>
<!-- raw HTML omitted -->
<pre><code>class MyTest extends TestCase
{
    protected $users = [];

    /**
     * @before
     */
    public function beforeMethod()
    {
        echo &quot;Before Method Called&quot; . PHP_EOL;
        $this-&gt;users[] = [
            'name' =&gt; '홍길동'
        ];
    }

    public function test1()
    {
        echo &quot;test1 Method Called&quot; . PHP_EOL;
        self::assertCount(1, $this-&gt;users);
    }

    public function test2()
    {
        echo &quot;test2 Method Called&quot; . PHP_EOL;
        self::assertCount(1, $this-&gt;users);
    }
}

// 출력 결과
Before Method Called
test1 Method Called
Before Method Called
test2 Method Called
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="beforeclass" class="headerLink">
    <a href="#beforeclass" class="header-mark"></a>@beforeClass</h2><h3 id="테스트-실행전-공유-속성을-만들-때" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%8b%a4%ed%96%89%ec%a0%84-%ea%b3%b5%ec%9c%a0-%ec%86%8d%ec%84%b1%ec%9d%84-%eb%a7%8c%eb%93%a4-%eb%95%8c" class="header-mark"></a>테스트 실행전 공유 속성을 만들 때</h3><hr>
<p>해당 클래스에서 테스트가 실행되기전 공유 하기 위한 정보를 설정하기 위해 호출 할 static 메소드에 지정하여 사용할 수 있습니다.</p>
<!-- raw HTML omitted -->
<pre><code>class MyTest extends TestCase
{
    protected $users = [];

    /**
     * @beforeClass
     */
    public static function beforeClass()
    {
        echo &quot;Before Class Called&quot; . PHP_EOL;
    }

    /**
     * @before
     */
    public function beforeMethod()
    {
        echo &quot;Before Method Called&quot; . PHP_EOL;
        $this-&gt;users[] = [
            'name' =&gt; '홍길동'
        ];
    }

    public function test1()
    {
        echo &quot;test1 Method Called&quot; . PHP_EOL;
        self::assertCount(1, $this-&gt;users);
    }

    public function test2()
    {
        echo &quot;test2 Method Called&quot; . PHP_EOL;
        self::assertCount(1, $this-&gt;users);
    }
}

// 출력 결과
Before Class Called
Before Method Called
test1 Method Called
Before Method Called
test2 Method Called
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="codecoverageignore" class="headerLink">
    <a href="#codecoverageignore" class="header-mark"></a>@codeCoverageIgnore*</h2><hr>
<p>코드 커버리지 분석시 제외할 라인에 사용할 수 있습니다.</p>
<!-- raw HTML omitted -->
<pre><code>/**
 * @codeCoverageIgnore
 */
class Foo
{
    public function bar()
    {
    }
}

class Bar
{
    /**
     * @codeCoverageIgnore
     */
    public function foo()
    {
    }
}

if (false) {
    // @codeCoverageIgnoreStart
    print '*';
    // @codeCoverageIgnoreEnd
}

exit; // @codeCoverageIgnore
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="covers" class="headerLink">
    <a href="#covers" class="header-mark"></a>@covers</h2><h3 id="테스트-영역을-명시하려-할-때" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%98%81%ec%97%ad%ec%9d%84-%eb%aa%85%ec%8b%9c%ed%95%98%eb%a0%a4-%ed%95%a0-%eb%95%8c" class="header-mark"></a>테스트 영역을 명시하려 할 때</h3><hr>
<p>어떤 영역을 테스트 하고자 하는지 명시하고자 할 때 사용합니다.</p>
<p>이와 같이 명시 하면 IDE(PHPStorm)에서 연결되어 있어 ctrl+shift+T 를 이용해 테스트로 바로 이동이 가능해지고, usage로 찾을 수 있어 메소드명 수정시 같이 반영됩니다.</p>
<!-- raw HTML omitted -->
<h2 id="coversdefaultclass" class="headerLink">
    <a href="#coversdefaultclass" class="header-mark"></a>@coversDefaultClass</h2><h3 id="너무-긴-네임스페이스와-클래스명을-반복해서-쓰고-싶지-않을-때" class="headerLink">
    <a href="#%eb%84%88%eb%ac%b4-%ea%b8%b4-%eb%84%a4%ec%9e%84%ec%8a%a4%ed%8e%98%ec%9d%b4%ec%8a%a4%ec%99%80-%ed%81%b4%eb%9e%98%ec%8a%a4%eb%aa%85%ec%9d%84-%eb%b0%98%eb%b3%b5%ed%95%b4%ec%84%9c-%ec%93%b0%ea%b3%a0-%ec%8b%b6%ec%a7%80-%ec%95%8a%ec%9d%84-%eb%95%8c" class="header-mark"></a>너무 긴 네임스페이스와 클래스명을 반복해서 쓰고 싶지 않을 때</h3><hr>
<p>기본 네임스페이스나 클래스명을 명시하는데 사용할 수 있어, <code>@covers</code> 어노테이션에 긴 네임스페이스나, 클래스명을 반복해서 사용할 필요가 없어집니다.</p>
<p>해당 어노테이션에는 정규화 된 클래스명을 사용해야하기때문에,
모호하지 않도록 클래스명 맨 앞에 <code>\</code> 로 시작하는것을 추천합니다.</p>
<p>아래 예제 코드와 같이 <code>@covers \Foo\CoveredClass::publicMethod</code> 를 <code>@covers ::publicMethod</code>로 줄여 쓸 수 있는 이점을 얻게 됩니다.</p>
<!-- raw HTML omitted -->
<pre><code>/**
 * @coversDefaultClass \Foo\CoveredClass
 */
class CoversDefaultClassTest extends TestCase
{
    /**
     * @covers ::publicMethod
     */
    public function testSomething()
    {
        $o = new Foo\CoveredClass;
        $o-&gt;publicMethod();
    }
}
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="coversnothing" class="headerLink">
    <a href="#coversnothing" class="header-mark"></a>@coversNothing</h2><h3 id="작성예정" class="headerLink">
    <a href="#%ec%9e%91%ec%84%b1%ec%98%88%ec%a0%95" class="header-mark"></a>작성예정</h3><hr>
<p>클래스나 메소드레벨에서 사용할 수 있고 <code>@covers</code> 어노테이션을 덮어 씁니다.</p>
<h2 id="dataprovider" class="headerLink">
    <a href="#dataprovider" class="header-mark"></a>@DataProvider</h2><h3 id="메소드를-이용해-파라미터를-주입하고-싶을때" class="headerLink">
    <a href="#%eb%a9%94%ec%86%8c%eb%93%9c%eb%a5%bc-%ec%9d%b4%ec%9a%a9%ed%95%b4-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0%eb%a5%bc-%ec%a3%bc%ec%9e%85%ed%95%98%ea%b3%a0-%ec%8b%b6%ec%9d%84%eb%95%8c" class="header-mark"></a>메소드를 이용해 파라미터를 주입하고 싶을때</h3><hr>
<p><code>@dataProvider</code> 를 사용하면 메소드의 파라미터로 전달할 수 있습니다.
Java Junit 패키지에서 JunitParams를 이용하여 <code>@Parameters</code> 어노테이션을 사용하는것과 동일한 효과를 얻을 수 있습니다.</p>
<ul>
<li>예제 코드
<ul>
<li>
<p>아래 예제 코드와 같은 테스트는 배열의 각 값 들이 <code>$a</code>, <code>$b</code>, <code>$expected</code> 로 바인딩 되며,
총 4개의 배열이 자동 주입되어 테스트가 4회 수행됩니다.</p>
<ul>
<li>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl">  <span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl">  <span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">DataTest</span> <span class="k">extends</span> <span class="nx">TestCase</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="sd">/**
</span></span></span><span class="line"><span class="cl"><span class="sd">       * @dataProvider additionProvider
</span></span></span><span class="line"><span class="cl"><span class="sd">       */</span>
</span></span><span class="line"><span class="cl">      <span class="k">public</span> <span class="k">function</span> <span class="nf">testAdd</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$expected</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">assertSame</span><span class="p">(</span><span class="nv">$expected</span><span class="p">,</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">public</span> <span class="k">function</span> <span class="nf">additionProvider</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">          <span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
</li>
<li>
<p>아래와 같이 이름이 정의된 dataset을 사용할 수도 있습니다.</p>
<ul>
<li>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl">  <span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl">  <span class="k">use</span> <span class="nx">PHPUnit\Framework\TestCase</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="k">class</span> <span class="nc">DataTest</span> <span class="k">extends</span> <span class="nx">TestCase</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="sd">/**
</span></span></span><span class="line"><span class="cl"><span class="sd">       * @dataProvider additionProvider
</span></span></span><span class="line"><span class="cl"><span class="sd">       */</span>
</span></span><span class="line"><span class="cl">      <span class="k">public</span> <span class="k">function</span> <span class="nf">testAdd</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">,</span> <span class="nv">$expected</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">assertSame</span><span class="p">(</span><span class="nv">$expected</span><span class="p">,</span> <span class="nv">$a</span> <span class="o">+</span> <span class="nv">$b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">      <span class="k">public</span> <span class="k">function</span> <span class="nf">additionProvider</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="k">return</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;adding zeros&#39;</span>  <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;zero plus one&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;one plus zero&#39;</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">              <span class="s1">&#39;one plus one&#39;</span>  <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">          <span class="p">];</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="depends" class="headerLink">
    <a href="#depends" class="header-mark"></a>@depends</h2><h3 id="테스트-코드간의-종속성-정의" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%bd%94%eb%93%9c%ea%b0%84%ec%9d%98-%ec%a2%85%ec%86%8d%ec%84%b1-%ec%a0%95%ec%9d%98" class="header-mark"></a>테스트 코드간의 종속성 정의</h3><hr>
<p><code>@depends</code> 어노테이션 사용시 테스트 코드간의 종속성을 선언 할 수 있습니다.</p>
<p>실행순서를 정의하는것은 아니지만, <code>@depends</code>에 정의된 테스트의 리턴값의 레퍼런스를 전달합니다.</p>
<p>레퍼런스 전달이 아닌 값의 깊은 복사를 원할 경우  <code>@depends clone</code> 를 이용하고,
PHP에서 clone으로 불리는 얕은 복사를 원할 경우 <code>@depends shallowClone</code> 를 이용하면 됩니다.</p>
<h2 id="doesnotperformassertions" class="headerLink">
    <a href="#doesnotperformassertions" class="header-mark"></a>@doesNotPerformAssertions</h2><h3 id="값에-대한-assertion-없이-테스트-코드를-실행만-하고자-할때" class="headerLink">
    <a href="#%ea%b0%92%ec%97%90-%eb%8c%80%ed%95%9c-assertion-%ec%97%86%ec%9d%b4-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%bd%94%eb%93%9c%eb%a5%bc-%ec%8b%a4%ed%96%89%eb%a7%8c-%ed%95%98%ea%b3%a0%ec%9e%90-%ed%95%a0%eb%95%8c" class="header-mark"></a>값에 대한 assertion 없이 테스트 코드를 실행만 하고자 할때</h3><hr>
<p>아래와 같이 테스트를 수행하지 않을 경우 <code>This test did not perform any assertions</code>와 같은 Warning이 발생됩니다.</p>
<p>해당 어노테이션을 사용하면 Risky 없이 <code>OK (1 test, 0 assertions)</code>로 성공 처리됩니다.</p>
<!-- raw HTML omitted -->
<pre><code>namespace Tests;

use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    public function testAddSlashes()
    {
        echo addslashes(&quot;name='1'&quot;);
    }
}

// 출력 결과

This test did not perform any assertions

/opt/project/tests/MyTest.php:9
name=\'1\'

OK, but incomplete, skipped, or risky tests!
Tests: 1, Assertions: 0, Risky: 1.

&lt;?php

namespace Tests;

use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    /**
     * @doesNotPerformAssertions
     */
    public function testAddSlashes()
    {
        echo addslashes(&quot;name='1'&quot;);
    }
}
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="group" class="headerLink">
    <a href="#group" class="header-mark"></a>@group</h2><h3 id="테스트-코드에-태그를-달고-싶을때" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%bd%94%eb%93%9c%ec%97%90-%ed%83%9c%ea%b7%b8%eb%a5%bc-%eb%8b%ac%ea%b3%a0-%ec%8b%b6%ec%9d%84%eb%95%8c" class="header-mark"></a>테스트 코드에 태그를 달고 싶을때</h3><hr>
<p><code>@group</code>어노테이션을 이용하여, 테스트 코드에 1개 이상의 태그와 같이 묶음 필터를 추가할 수 있습니다.</p>
<p>XML 설정 파일 주입을 이용 하거나 CLI에서 실행시 <code>--group</code> 과 <code>--exclude-group</code> 를 이용해서 테스트 실행 대상 또는 제외그룹을 설정할 수 있습니다.</p>
<h2 id="large" class="headerLink">
    <a href="#large" class="header-mark"></a>@large</h2><h3 id="60초-이상-실행-되면-실패-처리-하고자-할-때" class="headerLink">
    <a href="#60%ec%b4%88-%ec%9d%b4%ec%83%81-%ec%8b%a4%ed%96%89-%eb%90%98%eb%a9%b4-%ec%8b%a4%ed%8c%a8-%ec%b2%98%eb%a6%ac-%ed%95%98%ea%b3%a0%ec%9e%90-%ed%95%a0-%eb%95%8c" class="header-mark"></a>60초 이상 실행 되면 실패 처리 하고자 할 때</h3><hr>
<p><code>@group large</code>의 별칭으로,<code>PHP_Invoker</code> 패키지가 설치되어 있고, strict mode가 실행되어 있으면 <strong>60초</strong> 이상 실행 될 경우 실패 처리됩니다.
해당 타임아웃에 관한 정보는 설정 정보 XML의 <code>timeoutForLargeTests</code>속성을 통해 설정 할 수 있습니다.</p>
<h2 id="medium" class="headerLink">
    <a href="#medium" class="header-mark"></a>@medium</h2><h3 id="10초-이상-실행-되면-실패-처리-하고자-할-때" class="headerLink">
    <a href="#10%ec%b4%88-%ec%9d%b4%ec%83%81-%ec%8b%a4%ed%96%89-%eb%90%98%eb%a9%b4-%ec%8b%a4%ed%8c%a8-%ec%b2%98%eb%a6%ac-%ed%95%98%ea%b3%a0%ec%9e%90-%ed%95%a0-%eb%95%8c" class="header-mark"></a>10초 이상 실행 되면 실패 처리 하고자 할 때</h3><hr>
<p><code>@group medium</code>의 별칭으로, <code>PHP_Invoker</code> 패키지가 설치되어 있고, strict mode가 실행되어 있으면 <strong>10초</strong> 이상 실행 될 경우 실패 처리됩니다.
해당 타임아웃에 관한 정보는 설정 정보 XML의 <code>timeoutForMediumTests</code>속성을 통해 설정 할 수 있습니다.</p>
<p>Medium 테스트는 <code>@large</code> 테스트에 의존적이여서는 안됩니다.</p>
<h2 id="preserveglobalstate" class="headerLink">
    <a href="#preserveglobalstate" class="header-mark"></a>@preserveGlobalState</h2><h3 id="테스트가-별도의-프로세스에서-실행될때-직렬화-오류-방지" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8%ea%b0%80-%eb%b3%84%eb%8f%84%ec%9d%98-%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ec%97%90%ec%84%9c-%ec%8b%a4%ed%96%89%eb%90%a0%eb%95%8c-%ec%a7%81%eb%a0%ac%ed%99%94-%ec%98%a4%eb%a5%98-%eb%b0%a9%ec%a7%80" class="header-mark"></a>테스트가 별도의 프로세스에서 실행될때 직렬화 오류 방지</h3><hr>
<p>테스트가 별도의 프로세스에서 실행될 때, PHPUnit은부모 프로세스에서 글로벌 state를 직렬화 한 값을 자식 프로세스에서 역직렬화하여 상태를 보존합니다.</p>
<p>부모 프로세스에서 직렬화 할 수 없는 글로벌 state가 있는 경우, 해당 옵션을 <code>disable</code> 처리하여 방지할 수 있습니다.</p>
<h2 id="requires" class="headerLink">
    <a href="#requires" class="header-mark"></a>@requires</h2><h3 id="특정-조건일때만-테스트를-수행하고자-할-때" class="headerLink">
    <a href="#%ed%8a%b9%ec%a0%95-%ec%a1%b0%ea%b1%b4%ec%9d%bc%eb%95%8c%eb%a7%8c-%ed%85%8c%ec%8a%a4%ed%8a%b8%eb%a5%bc-%ec%88%98%ed%96%89%ed%95%98%ea%b3%a0%ec%9e%90-%ed%95%a0-%eb%95%8c" class="header-mark"></a>특정 조건일때만 테스트를 수행하고자 할 때</h3><hr>
<p>PHP의 버전이나 extensions 설치여부 등 전제 조건을 체크하여 테스트를 건너뛸 수 있습니다.</p>
<p><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>=</code>, <code>==</code>, <code>!=</code>, <code>&lt;&gt;</code> 등의 비교 연산자를 사용하여 버전을 비교할 수 있습니다.</p>
<p>해당 어노테이션을 이용해 체크 가능한 항목은 아래와 같습니다.</p>
<ul>
<li>체크 가능한 조건
<ul>
<li>PHP
<ul>
<li>PHP 버전</li>
</ul>
</li>
<li>PHPUnit
<ul>
<li>PHP Unit 버전</li>
</ul>
</li>
<li>OS
<ul>
<li><code>PHP_OS</code> 상수와 정규식으로 매칭되는 값입니다.
ex) WIN32|WINNT</li>
</ul>
</li>
<li>OSFAMILY
<ul>
<li><code>PHP_OS_FAMILY</code> 상수와 매칭되는 값으로 PHP 7.2.0부터 사용가능합니다.
ex) Windows</li>
</ul>
</li>
<li>function
<ul>
<li>함수 존재 여부 → function_exists()</li>
</ul>
</li>
<li>extension
<ul>
<li>extension 설치 여부 및 버전 체크</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<pre><code>/**
 * @requires extension mysqli
 */
class DatabaseTest extends TestCase
{
    /**
     * @requires PHP &gt;= 5.3
     */
    public function testConnection()
    {
                // 해당 테스트는 mysqli 확장프로그램이 설치되어 있고, PHP 버전이 5.3 이상일때 실행됩니다.
    }

    // 추가적인 테스트를 작성하였을때에도 mysqli 확장프로그램이 필요합니다.
}
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="runtestsinseparateprocesses" class="headerLink">
    <a href="#runtestsinseparateprocesses" class="header-mark"></a>@runTestsInSeparateProcesses</h2><h3 id="테스트-클래스-내의-모든-테스트-메소드가-별도-php프로세스에서-테스트코드를-실행-하는것을-명시할-때" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ed%81%b4%eb%9e%98%ec%8a%a4-%eb%82%b4%ec%9d%98-%eb%aa%a8%eb%93%a0-%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%a9%94%ec%86%8c%eb%93%9c%ea%b0%80-%eb%b3%84%eb%8f%84-php%ed%94%84%eb%a1%9c%ec%84%b8%ec%8a%a4%ec%97%90%ec%84%9c-%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%bd%94%eb%93%9c%eb%a5%bc-%ec%8b%a4%ed%96%89-%ed%95%98%eb%8a%94%ea%b2%83%ec%9d%84-%eb%aa%85%ec%8b%9c%ed%95%a0-%eb%95%8c" class="header-mark"></a>테스트 클래스 내의 모든 테스트 메소드가 별도 PHP프로세스에서 테스트코드를 실행 하는것을 명시할 때</h3><hr>
<p>해당 테스트 클래스 내의 모든 테스트 메소드들이 별도의 PHP 프로세스에서 실행되어야 함을 표시 할 때 사용합니다.</p>
<p>PHPUnit은 직렬화를 통해 Global state를 유지하려 하기 때문에, 직렬화가 불가능한 부분은 <code>@preserveGlobalState</code>를 참조하세요.</p>
<h2 id="runinseparateprocess" class="headerLink">
    <a href="#runinseparateprocess" class="header-mark"></a>@runInSeparateProcess</h2><hr>
<p>해당 테스트 메소드가 별도의 PHP 프로세스에서 실행되어야 함을 표시 할 때 사용합니다.</p>
<p>PHPUnit은 직렬화를 통해 Global state를 유지하려 하기 때문에, 직렬화가 불가능한 부분은 <code>@preserveGlobalState</code>를 참조하세요.</p>
<h2 id="small" class="headerLink">
    <a href="#small" class="header-mark"></a>@small</h2><hr>
<p><code>@group small</code>의 별칭으로, <code>PHP_Invoker</code> 패키지가 설치되어 있고, strict mode가 실행되어 있으면 <strong>1초</strong> 이상 실행 될 경우 실패 처리됩니다.
해당 타임아웃에 관한 정보는 설정 정보 XML의 <code>timeoutForSmallTests</code>속성을 통해 설정 할 수 있습니다.</p>
<p>Medium 테스트는 <code>@large</code> 와 <code>@medium</code>로 마킹된 테스트에 의존적이여서는 안됩니다.</p>
<p>※ <strong>테스트의 실행 시간 제어를 하고자 할 때, <code>@small</code>, <code>@medium</code>, <code>@large</code> 와 같은 어노테이션을 명시적으로 사용해야합니다.</strong></p>
<h2 id="test" class="headerLink">
    <a href="#test" class="header-mark"></a>@test</h2><h3 id="테스트-메소드명을-test로-시작하고싶지-않을-때" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%a9%94%ec%86%8c%eb%93%9c%eb%aa%85%ec%9d%84-test%eb%a1%9c-%ec%8b%9c%ec%9e%91%ed%95%98%ea%b3%a0%ec%8b%b6%ec%a7%80-%ec%95%8a%ec%9d%84-%eb%95%8c" class="header-mark"></a>테스트 메소드명을 test로 시작하고싶지 않을 때</h3><hr>
<p>테스트 메소드는 메소드명의 prefix로 test를 사용합니다.</p>
<p>테스트 메소드명의 prefix로 <code>test</code>를 사용하지 않는 대안으로, 주석에 <code>@test</code> 어노테이션을 사용하면 테스트 메소드라고 인식됩니다.</p>
<p><figure><img
        
        loading="lazy"
        src="/images/phpunit-annotations/eeb49a85-fdd7-40ee-99df-60579993b1a3.png"
        srcset="/images/phpunit-annotations/eeb49a85-fdd7-40ee-99df-60579993b1a3.png, /images/phpunit-annotations/eeb49a85-fdd7-40ee-99df-60579993b1a3.png 1.5x, /images/phpunit-annotations/eeb49a85-fdd7-40ee-99df-60579993b1a3.png 2x"
        sizes="auto"
        alt="/images/phpunit-annotations/eeb49a85-fdd7-40ee-99df-60579993b1a3.png"
        title="/images/phpunit-annotations/eeb49a85-fdd7-40ee-99df-60579993b1a3.png" ></figure></p>
<p><figure><img
        
        loading="lazy"
        src="/images/phpunit-annotations/cbdae160-7e46-49e4-9d93-0a3584597625.png"
        srcset="/images/phpunit-annotations/cbdae160-7e46-49e4-9d93-0a3584597625.png, /images/phpunit-annotations/cbdae160-7e46-49e4-9d93-0a3584597625.png 1.5x, /images/phpunit-annotations/cbdae160-7e46-49e4-9d93-0a3584597625.png 2x"
        sizes="auto"
        alt="/images/phpunit-annotations/cbdae160-7e46-49e4-9d93-0a3584597625.png"
        title="/images/phpunit-annotations/cbdae160-7e46-49e4-9d93-0a3584597625.png" ></figure></p>
<h2 id="testdox" class="headerLink">
    <a href="#testdox" class="header-mark"></a>@testdox</h2><h3 id="testdox-옵션으로-생성되는-문서의-설명을-대체하려-할-때" class="headerLink">
    <a href="#testdox-%ec%98%b5%ec%85%98%ec%9c%bc%eb%a1%9c-%ec%83%9d%ec%84%b1%eb%90%98%eb%8a%94-%eb%ac%b8%ec%84%9c%ec%9d%98-%ec%84%a4%eb%aa%85%ec%9d%84-%eb%8c%80%ec%b2%b4%ed%95%98%eb%a0%a4-%ed%95%a0-%eb%95%8c" class="header-mark"></a>testdox 옵션으로 생성되는 문서의 설명을 대체하려 할 때</h3><hr>
<p><code>--testdox</code>를 옵션으로 주었을때, 메소드의 이름으로부터 만들어진 설명을 오버라이딩 할 수 있습니다.</p>
<p>클래스 또는 메소드의 설명을 더 명확히 만들어 agile document를 만들 수 있습니다.</p>
<p><strong>주의할 점으로는 PHPUnit v7.0까지는 어노테이션 파싱 오류로, @test로 인식되어 동작합니다.</strong></p>
<h2 id="testwith" class="headerLink">
    <a href="#testwith" class="header-mark"></a>@testWith</h2><h3 id="주석을-이용해-파라미터를-주입하고-싶을때" class="headerLink">
    <a href="#%ec%a3%bc%ec%84%9d%ec%9d%84-%ec%9d%b4%ec%9a%a9%ed%95%b4-%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0%eb%a5%bc-%ec%a3%bc%ec%9e%85%ed%95%98%ea%b3%a0-%ec%8b%b6%ec%9d%84%eb%95%8c" class="header-mark"></a>주석을 이용해 파라미터를 주입하고 싶을때</h3><hr>
<p><code>@dataProvider</code>는 호출될 메소드를 필요로 하지만, 주석만을 이용해 테스트하고자 할 때에는
<code>@testWith</code>를 사용할 수 있습니다.</p>
<p>JSON 포맷은 연관배열로 주입됩니다.</p>
<p><strong>주의 할 점은 여러개의 dataset을 정의할 때에는 라인당 하나씩 지정해야합니다.</strong></p>
<p>아래의 두개의 코드는 동일하게 동작합니다.</p>
<!-- raw HTML omitted -->
<pre><code>/**
 * @param string    $input
 * @param int       $expectedLength
 *
 * @testWith        [&quot;test&quot;, 4]
 *                  [&quot;longer-string&quot;, 13]
 */
public function testStringLength(string $input, int $expectedLength)
{
    $this-&gt;assertSame($expectedLength, strlen($input));
}

/**
 * @param string    $input
 * @param int       $expectedLength
 *
 * @dataProvider    additionProvider
 */
public function testStringLengthWithDataProvider(string $input, int $expectedLength)
{
    $this-&gt;assertSame($expectedLength, strlen($input));
}

public function additionProvider()
{
        return [
                [&quot;test&quot;, 4],
                [&quot;longer-string&quot;, 13]
        ];
}

/**
 * @param array     $array
 * @param array     $keys
 *
 * @testWith        [{&quot;day&quot;: &quot;monday&quot;, &quot;conditions&quot;: &quot;sunny&quot;}, [&quot;day&quot;, &quot;conditions&quot;]]
 */
public function testArrayKeys($array, $keys)
{
    $this-&gt;assertSame($keys, array_keys($array));
}

/**
 * @param array     $array
 * @param array     $keys
 *
 * @dataProvider    additionProvider
 */
public function testArrayKeysWithDataProvider($array, $keys)
{
    $this-&gt;assertSame($keys, array_keys($array));
}

public function additionProvider()
{
        return [
                [[&quot;day&quot; =&gt; &quot;monday&quot;, &quot;conditions&quot; =&gt; &quot;sunny&quot;], [&quot;day&quot;, &quot;conditions&quot;]]
        ];
}
```
</code></pre>
<!-- raw HTML omitted -->
<h2 id="ticket" class="headerLink">
    <a href="#ticket" class="header-mark"></a>@ticket</h2><h3 id="ticket-idjira-이슈-코드와-같은로-테스트를-필터링-할-때" class="headerLink">
    <a href="#ticket-idjira-%ec%9d%b4%ec%8a%88-%ec%bd%94%eb%93%9c%ec%99%80-%ea%b0%99%ec%9d%80%eb%a1%9c-%ed%85%8c%ec%8a%a4%ed%8a%b8%eb%a5%bc-%ed%95%84%ed%84%b0%eb%a7%81-%ed%95%a0-%eb%95%8c" class="header-mark"></a>Ticket ID(JIRA 이슈 코드와 같은)로 테스트를 필터링 할 때</h3><hr>
<p><code>@group</code> 어노테이션의 별칭. ticket ID를 이용하여 테스트를 필터링 할 수 있도록 하여줍니다.</p>
<h2 id="uses" class="headerLink">
    <a href="#uses" class="header-mark"></a>@uses</h2><hr>
<p>테스트에 의해 실행될 코드를 지정합니다.</p>
<p>좋은 예제는 아래와 같이 유닛 테스트 코드에 필요한 Object 값 입니다.</p>
<!-- raw HTML omitted -->
<p>해당 어노테이션에는 정규화 된 클래스명을 사용해야하기때문에,
모호하지 않도록 클래스명 맨 앞에 <code>\</code> 로 시작하는것을 추천합니다.</p>
]]></description></item><item><title>［PHP］Monolog와 함께 로그를 시작하자 - 1</title><link>http://blog.hodory.dev/2019/05/10/php-logging-with-monolog-1/</link><pubDate>Fri, 10 May 2019 00:27:05 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/05/10/php-logging-with-monolog-1/</guid><description><![CDATA[<h3 id="php에서-로그-남기기" class="headerLink">
    <a href="#php%ec%97%90%ec%84%9c-%eb%a1%9c%ea%b7%b8-%eb%82%a8%ea%b8%b0%ea%b8%b0" class="header-mark"></a>PHP에서 로그 남기기</h3><p>PHP에서는 주로 JS에서 <code>console.log | console.debug</code> 와 유사하게 <!-- raw HTML omitted -->
<code>var_dump | print_r | echo | sys_log | error_log</code> 등 다양한 방식으로 로그를 남기고 있습니다.</p>
<h3 id="monolog란" class="headerLink">
    <a href="#monolog%eb%9e%80" class="header-mark"></a>Monolog란?</h3><p><a href="https://hodory.github.io/2018/04/18/what-is-psr/#PSR-3-Logger-Interface" target="_blank" rel="noopener noreferrer">PSR-3</a>을 준수하고 있는 로깅 프레임워크로,<!-- raw HTML omitted -->
거의 대부분의 로깅 플랫폼과 연결할 수 있는 핸들러(Slack, ElasticSearch, Mail, NewRelic 등)를 제공하고 있습니다.</p>
<p><a href="http://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener noreferrer">RFC 5424</a>(Syslog Protocol이라고 하는데 더 공부해봐야할 것 같습니다.)에 정의된 로그 레벨을 모두 지원하고 있습니다.</p>
<ul>
<li>DEBUG(100)</li>
<li>INFO(200)</li>
<li>NOTICE(250)</li>
<li>WARNING(300)</li>
<li>ERROR(400)</li>
<li>CRITICAL(500)</li>
<li>ALERT(550)</li>
<li>EMERGENCY(600)</li>
</ul>
<!-- raw HTML omitted -->
<h3 id="코어-컨셉httpsgithubcomseldaekmonologblobmasterdoc01-usagemdcore-concepts" class="headerLink">
    <a href="#%ec%bd%94%ec%96%b4-%ec%bb%a8%ec%85%89httpsgithubcomseldaekmonologblobmasterdoc01-usagemdcore-concepts" class="header-mark"></a><a href="https://github.com/Seldaek/monolog/blob/master/doc/01-usage.md#core-concepts" target="_blank" rel="noopener noreferrer">코어 컨셉</a></h3><p>간단하게 Logger Instance에 Record를 추가하면,<!-- raw HTML omitted -->
해당 인스턴스에 추가 해두었던 핸들러에 이벤트를 전파하는 것으로 보입니다.(한개의 로그를 여러곳에 저장할 수 있는 이점을 가지고 있습니다.)</p>
<h3 id="설치-방법" class="headerLink">
    <a href="#%ec%84%a4%ec%b9%98-%eb%b0%a9%eb%b2%95" class="header-mark"></a>설치 방법</h3><p>PHP Composer로 관리할 수 있는 라이브러리이므로 Composer를 이용하여 설치합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-perl" data-lang="perl"><span class="line"><span class="cl"><span class="n">composer</span> <span class="k">require</span> <span class="nn">monolog</span><span class="o">/</span><span class="n">monolog</span>
</span></span></code></pre></div><h3 id="사용방법" class="headerLink">
    <a href="#%ec%82%ac%ec%9a%a9%eb%b0%a9%eb%b2%95" class="header-mark"></a>사용방법</h3><p>우선적으로 use를 사용하여 사용할 Namespace를 추가합니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Monolog\Logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Monolog\Handler\StreamHandler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Monolog\Handler\FirePHPHandler</span><span class="p">;</span>
</span></span></code></pre></div><p>Logging Channel의 이름을 설정하여 객체를 생성합니다.</p>
<pre tabindex="0"><code>// Create the logger
$logger = new Logger(&#39;Application&#39;);
</code></pre><p>로그를 전파할 핸들러를 추가합니다.</p>
<ul>
<li>php:stderr 또는 원격이나 로컬 파일 기타에 사용할 <code>Stream Handler</code>를 설정합니다.</li>
<li>Slack Webhook Url으로 보내기 위해 <code>Slack WebHook Handler</code>를 설정합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// Now add some handlers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$logger</span><span class="o">-&gt;</span><span class="na">pushHandler</span><span class="p">(</span><span class="k">new</span> <span class="nx">StreamHandler</span><span class="p">(</span><span class="no">__DIR__</span> <span class="o">.</span> <span class="s1">&#39;/app.log&#39;</span><span class="p">,</span> <span class="nx">Logger</span><span class="o">::</span><span class="na">DEBUG</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nv">$logger</span><span class="o">-&gt;</span><span class="na">pushHandler</span><span class="p">(</span><span class="k">new</span> <span class="nx">SlackWebhookHandler</span><span class="p">({{</span><span class="nx">WEBHOOK_URL</span><span class="p">}},</span> <span class="p">{{</span><span class="nx">CHANNEL</span><span class="p">}},</span> <span class="p">{{</span><span class="nx">USERNAME</span><span class="p">}},</span> <span class="k">false</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="nx">Logger</span><span class="o">::</span><span class="na">INFO</span><span class="p">));</span>
</span></span></code></pre></div><p>아래와 같은 함수를 호출하여 로그를 쌓을 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// You can now use your logger
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$logger</span><span class="o">-&gt;</span><span class="na">info</span><span class="p">(</span><span class="s1">&#39;Welcome To Monolog&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="sd">/*********
</span></span></span><span class="line"><span class="cl"><span class="sd"> * app.log
</span></span></span><span class="line"><span class="cl"><span class="sd"> *********/</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [2019-05-10 17:03:10] Application.INFO: Welcome To Monolog [] []
</span></span></span></code></pre></div><p>Legacy한 프로젝트에서는 주로 컨테이너 객체라는 개념이 없는 경우가 많은데,<!-- raw HTML omitted -->
프로젝트 내부에서도 글로벌 변수에 담아서 Logger 객체를 사용해야하나 고민하였습니다.
문서를 확인하다보니 이를 위한 <code>Monolog\Registry</code>라는 유틸 클래스가 있었고,
이와 같이 사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="sd">/****************
</span></span></span><span class="line"><span class="cl"><span class="sd"> * bootstrap.php
</span></span></span><span class="line"><span class="cl"><span class="sd"> ****************/</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Monolog\Handler\StreamHandler</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Monolog\Logger</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Monolog\Registry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$logger</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Logger</span><span class="p">(</span><span class="s1">&#39;Application&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nv">$logger</span><span class="o">-&gt;</span><span class="na">pushHandler</span><span class="p">(</span><span class="k">new</span> <span class="nx">StreamHandler</span><span class="p">(</span><span class="no">__DIR__</span> <span class="o">.</span> <span class="s1">&#39;/app.log&#39;</span><span class="p">,</span> <span class="nx">Logger</span><span class="o">::</span><span class="na">DEBUG</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="nx">Registry</span><span class="o">::</span><span class="na">addLogger</span><span class="p">(</span><span class="nv">$logger</span><span class="p">,</span><span class="s1">&#39;ApplicationLog&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="sd">/****************
</span></span></span><span class="line"><span class="cl"><span class="sd"> * foo.php
</span></span></span><span class="line"><span class="cl"><span class="sd"> ****************/</span>
</span></span><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">Monolog\Registry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">require_once</span> <span class="no">__DIR__</span> <span class="o">.</span> <span class="s2">&#34;/bootstrap.php&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">function</span> <span class="nf">logInfo</span><span class="p">(</span><span class="nv">$message</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$logger</span> <span class="o">=</span> <span class="nx">Registry</span><span class="o">::</span><span class="na">getInstance</span><span class="p">(</span><span class="s1">&#39;ApplicationLog&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$logger</span><span class="o">-&gt;</span><span class="na">info</span><span class="p">(</span><span class="nv">$message</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">logInfo</span><span class="p">(</span><span class="s1">&#39;I am Global Logging&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="sd">/*********
</span></span></span><span class="line"><span class="cl"><span class="sd"> * app.log
</span></span></span><span class="line"><span class="cl"><span class="sd"> *********/</span>
</span></span><span class="line"><span class="cl"><span class="c1">// [2019-05-10 17:03:10] Application.INFO: I am Global Logging [] []
</span></span></span></code></pre></div><p>이와 같이 bootstrap.php 파일에서 Register에 등록한 Logger 객체는<!-- raw HTML omitted -->
global 변수를 사용하지 않아도 클래스 / 함수 상관 없이 어디에서든지 사용 가능해집니다.</p>
<p>더 좋은 활용 방법이 있으시다면 공유 부탁드리겠습니다.</p>
<p>자세한 사항은 <a href="https://github.com/Seldaek/monolog/blob/master/doc/01-usage.md" target="_blank" rel="noopener noreferrer">Monolog-Usage</a>에서 확인 하실 수 있습니다.</p>
]]></description></item><item><title>［Laravel］with() | has() | whereHas() 뭐가 다를까</title><link>http://blog.hodory.dev/2019/04/27/eloquent-orm-with-has-where-has/</link><pubDate>Sat, 27 Apr 2019 00:15:24 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/04/27/eloquent-orm-with-has-where-has/</guid><description><![CDATA[<p>ORM도 익숙하지 않지만, Eloquent ORM은 처음 접해보면서,</p>
<p>쿼리빌더를 사용하는것은 ORM스럽지 못하다 느껴 최대한 ORM으로 풀고 싶었습니다</p>
<p>검색으로 알아보던중 <a href="https://laravel.kr/docs/5.8/eloquent-relationships" target="_blank" rel="noopener noreferrer">Eloquent:Relations</a>에 대해 알게되었습니다.</p>
<p><a href="https://laravel.kr/docs/5.8/eloquent-relationships#%EA%B4%80%EA%B3%84%EC%9D%98%20%EC%A1%B4%EC%9E%AC%20%EC%97%AC%EB%B6%80%20%EC%BF%BC%EB%A6%AC%20%EC%A7%88%EC%9D%98%ED%95%98%EA%B8%B0" target="_blank" rel="noopener noreferrer">라라벨 공식 문서 : 관계의 존재 여부 쿼리 질의하기</a></p>
<p>예를들어 <code>User</code>가 여러개의 <code>Post</code> 를 가지고 있다면,<!-- raw HTML omitted -->
<code>User</code> 클래스에 <code>$this-&gt;hasMany('App\Post');</code>를 설정해 두었을 것이라는 가정하에 설명을 진행하도록 하겠습니다.</p>
<!-- raw HTML omitted -->
<h2 id="with" class="headerLink">
    <a href="#with" class="header-mark"></a>with()</h2><ul>
<li>user
<ul>
<li>id</li>
<li>name</li>
</ul>
</li>
<li>post
<ul>
<li>id</li>
<li>user_id</li>
<li>title
이와 같은 테이블 구조에서 유저가 작성한 글의 제목을 조회하려면</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="nv">$users</span> <span class="o">=</span> <span class="nx">selectAll</span><span class="p">(</span><span class="s2">&#34;select * from `user`);
</span></span></span><span class="line"><span class="cl"><span class="s2">foreach (</span><span class="si">$users</span><span class="s2"> as </span><span class="si">$user</span><span class="s2">) {
</span></span></span><span class="line"><span class="cl"><span class="s2">    </span><span class="si">$user[&#39;post_title&#39;]</span><span class="s2"> = selectOne(&#34;</span><span class="nx">select</span> <span class="sb">`title`</span> <span class="nx">from</span> <span class="sb">`post`</span> <span class="nx">where</span> <span class="sb">`post`</span><span class="o">.</span><span class="sb">`user_id`</span> <span class="o">=</span> <span class="p">{</span><span class="nv">$user</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]}</span><span class="s2">&#34;);
</span></span></span><span class="line"><span class="cl"><span class="s2">}
</span></span></span></code></pre></div><p>회원을 조회하고, 회원들을 순회하며 게시물을 조회하는 코드입니다.<!-- raw HTML omitted -->
이 경우 회원이 1000명일 경우 쿼리는 1001번 실행하게 됩니다.<!-- raw HTML omitted -->
이것을 <a href="https://zetawiki.com/wiki/N%2B1_%EC%BF%BC%EB%A6%AC_%EB%AC%B8%EC%A0%9C" target="_blank" rel="noopener noreferrer">N+1쿼리 문제</a> 라고 합니다.</p>
<p>사람들에 따라 직관적이여서 선호하기도 하고,<!-- raw HTML omitted -->
join으로 실행시 쿼리가 오래 걸리면 이와 같이 분리하여 사용하기도 합니다.
또는 join으로 해결할 수 없는 상황에서도 사용합니다.</p>
<p>이 문제를 해결 하기 위해</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="err">$</span><span class="n">users</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">selectAll</span><span class="p">(</span><span class="s2">&#34;select `user`.*,`post`.`title` as post_title from `user` left join `post` on `post`.`user_id` = `user`.`id`&#34;</span><span class="p">);</span><span class="w"> 
</span></span></span></code></pre></div><p>join으로 해결할 수 없는 경우를 제외 하고는 위와 같이 join을 사용해서 조회 할 수 있습니다.</p>
<p>또한 이 문제는 ORM에서 주로 발생 합니다.<!-- raw HTML omitted -->
ORM을 사용하면 user와 post의 관계를 설정하고, 아래와 같이 사용할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="nx">User</span><span class="o">::</span><span class="na">all</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$user</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">echo</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">post</span><span class="o">-&gt;</span><span class="na">title</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>해당 코드는</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="p">;</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">....</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">...</span><span class="w">
</span></span></span></code></pre></div><p>user를 조회하고, user의 수 만큼 post를 조회합니다.<!-- raw HTML omitted -->
위의 N+1 문제와 같은 문제입니다.</p>
<p>이 문제를 해결 하기 위한 방안으로는 <a href="https://zetawiki.com/wiki/%EC%A6%89%EC%8B%9C_%EB%A1%9C%EB%94%A9" target="_blank" rel="noopener noreferrer">즉시 로딩(Eager Loading)</a>이 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">foreach</span> <span class="p">(</span><span class="nx">User</span><span class="o">::</span><span class="na">with</span><span class="p">(</span><span class="s1">&#39;posts&#39;</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$user</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">echo</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">post</span><span class="o">-&gt;</span><span class="na">title</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이와같이 <code>with()</code>를 사용하면 미리 선언한 관계를 사용하여 같이 가져올수있습니다.<!-- raw HTML omitted -->
언뜻 보기엔 별 다를바 없어 보이는 코드이지만 with 메소드를 사용하면, user와 연관된 post를 미리 로드합니다.</p>
<p>실행되는 쿼리는</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="p">;</span><span class="w"> </span><span class="o">#</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">....</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w">
</span></span></span></code></pre></div><p>위와 같이 쿼리 2개만 실행이 되어 쿼리 실행을 최소화 할 수 있습니다.</p>
<p><code>with()</code> 메소드의 2번째 파라미터를 사용해 제한 할 수도 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">foreach</span><span class="p">(</span><span class="nx">User</span><span class="o">::</span><span class="na">with</span><span class="p">([</span><span class="s1">&#39;posts&#39;</span> <span class="o">=&gt;</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$query</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">where</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;치킨%&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">])</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">()</span> <span class="k">as</span> <span class="nv">$user</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">echo</span> <span class="nv">$user</span><span class="o">-&gt;</span><span class="na">post</span><span class="o">-&gt;</span><span class="na">title</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">;</span>
</span></span></code></pre></div><p><code>user</code>를 조회할 때, <code>치킨</code>으로 시작하는 <code>post</code>를 같이 미리 로드 할 수 있습니다.</p>
<h2 id="has" class="headerLink">
    <a href="#has" class="header-mark"></a>has()</h2><p><code>has()</code> 메소드를 이용하면, 해당 관계에서 최소 한개를 가지고 있는 결과를 조회합니다</p>
<p><code>User::has('posts')-&gt;get();</code>을 사용하면 post를 한개라도 작성한 회원을 조회할것입니다.</p>
<p>쿼리로 표현한다면, 아래와 비슷할것 같습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">join</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">user_id</span><span class="o">`</span><span class="w">
</span></span></span></code></pre></div><p>has 메소드는 2번째 파라미터에 <code>operator</code> 와 3번째 파라미터에 <code>count</code>를 사용할 수 있습니다.<!-- raw HTML omitted --></p>
<p>이 파라미터를 사용하면 예로 5개 이상의 글을 작성한 회원을 찾을 수 있습니다.
Eloquent를 사용하면 이와같이 작성 할 수 있습니다.<!-- raw HTML omitted -->
<code>User::has('posts', '&gt;=', 5)-&gt;get();</code></p>
<h2 id="wherehas" class="headerLink">
    <a href="#wherehas" class="header-mark"></a>whereHas()</h2><p>그렇다면 <code>whereHas()</code>는 뭐가 다를까요? <!-- raw HTML omitted -->
<code>whereHas()</code> 메소드는 두번째 파라미터로 콜백을 받아 더 복잡한 쿼리를 처리할 수 있습니다.</p>
<p>위와 같은 모델링에서 게시글의 제목이 <code>치킨</code>으로 시작하는 글을 작성한 회원을 찾는다면 아래와 같을것 입니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="nx">User</span><span class="o">::</span><span class="na">whereHas</span><span class="p">(</span><span class="s1">&#39;posts&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$query</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$query</span><span class="o">-&gt;</span><span class="na">where</span><span class="p">(</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="s1">&#39;like&#39;</span><span class="p">,</span> <span class="s1">&#39;치킨%&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">})</span><span class="o">-&gt;</span><span class="na">get</span><span class="p">();</span>
</span></span></code></pre></div><p>쿼리로 표현한다면</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">join</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">on</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">user_id</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">and</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">title</span><span class="o">`</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="s1">&#39;치킨%&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">OR</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">from</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="k">join</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="o">`</span><span class="k">user</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">id</span><span class="o">`</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">user_id</span><span class="o">`</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">where</span><span class="w"> </span><span class="o">`</span><span class="n">post</span><span class="o">`</span><span class="p">.</span><span class="o">`</span><span class="n">title</span><span class="o">`</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="s1">&#39;치킨%&#39;</span><span class="w">
</span></span></span></code></pre></div><p>이와 같이 표현할 수 있을것 같습니다.</p>
<blockquote>
<p>참고자료</p>
</blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/30231862/laravel-eloquent-has-with-wherehas-what-do-they-mean?answertab=votes#tab-top" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">Stack Overflow -&gt; Laravel - Eloquent “Has”, “With”, “WhereHas” - What do they mean?</a></li>
<li><a href="https://laravel.kr/docs/5.8/eloquent-relationships" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">Laravel 공식 문서 -&gt; Eloquent: Relationships - 관계</a></li>
</ul>
]]></description></item><item><title>［PHP］배열 key의 min 또는 max 구하기</title><link>http://blog.hodory.dev/2018/10/27/php-array-column/</link><pubDate>Sat, 27 Oct 2018 15:23:32 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2018/10/27/php-array-column/</guid><description><![CDATA[<p>PHP로 개발을 하다보면, 연관 배열을 많이 쓰게되는데요</p>
<p>아래와 같은 배열에서 cnt의 max값과 min값을 구하려면 어떻게 해야할까요?</p>
<!-- raw HTML omitted -->
<p>또는 이러한 배열에서 특정 키값의 값만 뽑아 배열로 만들고싶다면 어떻게 해야할까요?</p>
<pre tabindex="0"><code>array(3) {
  [0]=&gt;
  array(3) {
    [&#34;title&#34;]=&gt;
    string(5) &#34;apple&#34;
    [&#34;cnt&#34;]=&gt;
    int(1) &#34;5&#34;
    [&#34;color&#34;]=&gt;
    string(5) &#34;green&#34;
  }
  [1]=&gt;
  array(3) {
    [&#34;name&#34;]=&gt;
    string(4) &#34;pear&#34;
    [&#34;cnt&#34;]=&gt;
    int(1) &#34;8&#34;
    [&#34;color&#34;]=&gt;
    string(6) &#34;yellow&#34;
  }
</code></pre><p>배열을 순회하여 해당 키의 값을 뽑아 배열을 만들고,</p>
<p>최소 또는 최대값이 필요하면 min 또는 max 함수를 적용해야 한다 생각했습니다.</p>
<p>그런 코드는 만들고 싶지 않아 검색을 하다보니</p>
<p>PHP 5.5버전부터는 <a href="http://php.net/manual/en/function.array-column.php" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">array_column</a>을 사용하면 쉽게 처리할 수 있었습니다.</p>
<p><code>array array_column ( array $input , mixed $column_key [, mixed $index_key = NULL ] )</code> 와 같은 구조로</p>
<p>첫번째 파라미터에 해당 배열을 넣고, 두번째 파라미터에 뽑아낼 key를 넣으면 됩니다.</p>
<p>예를들어 아래와 같은 연관 배열에서 cnt로만 배열을 만들려면 이와 같이 할 수 있습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="nv">$arr</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;title&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;title1&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;cnt&#39;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;color&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;title&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;title2&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;cnt&#39;</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;color&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$cntArr</span> <span class="o">=</span> <span class="nx">array_column</span><span class="p">(</span><span class="nv">$arr</span><span class="p">,</span> <span class="s1">&#39;cnt&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">var_dump</span><span class="p">(</span><span class="nv">$cntArr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">### Result 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">int</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">int</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>또한 세번째 파라미터로는 index_key를 넣을 수 있는데요</p>
<p>return 할 배열의 키로 사용할 값을 넣으면 됩니다 예를들어 이렇게 쓸 수 있을것 같았습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="c1">// example code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nv">$arr</span> <span class="o">=</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;idx&#39;</span> <span class="o">=&gt;</span> <span class="mi">2555</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;title&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;title1&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;cnt&#39;</span><span class="o">=&gt;</span><span class="mi">2</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;color&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="p">[</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;idx&#39;</span> <span class="o">=&gt;</span> <span class="mi">2982</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;title&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;title2&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;cnt&#39;</span><span class="o">=&gt;</span><span class="mi">3</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="s1">&#39;color&#39;</span><span class="o">=&gt;</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl"><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$cntArr</span> <span class="o">=</span> <span class="nx">array_column</span><span class="p">(</span><span class="nv">$arr</span><span class="p">,</span> <span class="s1">&#39;cnt&#39;</span><span class="p">,</span> <span class="s1">&#39;idx&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">var_dump</span><span class="p">(</span><span class="nv">$cntArr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">### Result
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">2555</span><span class="p">]</span><span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">int</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">[</span><span class="mi">2982</span><span class="p">]</span><span class="o">=&gt;</span>
</span></span><span class="line"><span class="cl">  <span class="nx">int</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>이와같이 사용하면 해당 idx의 cnt를 뽑을 수 있어 더 효율적으로 사용할 수 있을거 같습니다.</p>
<p>더 좋은 사용 방안 있으시면 댓글로 부탁드리겠습니다.</p>
<blockquote>
<p>참고자료</p>
</blockquote>
<ul>
<li><a href="https://stackoverflow.com/questions/17339421/find-highest-value-in-multidimensional-array" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">StackOverFlow - Find highest value in multidimensional array</a></li>
<li><a href="https://secure.php.net/manual/en/function.array-column.php" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">PHP 공식문서 - array_column()</a></li>
</ul>
]]></description></item><item><title>［PHP］ PHP4.x 버전과 PHP 5.x 버전 비교(Comparison between PHP4 and PHP5)</title><link>http://blog.hodory.dev/2018/04/20/php4-vs-php5/</link><pubDate>Fri, 20 Apr 2018 02:04:12 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2018/04/20/php4-vs-php5/</guid><description><![CDATA[<h3 id="php5에서-무엇이-바뀌었을까" class="headerLink">
    <a href="#php5%ec%97%90%ec%84%9c-%eb%ac%b4%ec%97%87%ec%9d%b4-%eb%b0%94%eb%80%8c%ec%97%88%ec%9d%84%ea%b9%8c" class="header-mark"></a>PHP5에서 무엇이 바뀌었을까?</h3><ul>
<li>젠드엔진2가 내장되었습니다.</li>
<li>PHP GCI 버전이 <code>php.exe</code> 에서 <code>php-cgi.exe</code> 로 변경되었습니다.</li>
<li>PHP CLI 버전이 <code>cli/php.exe</code> 에서 주 디렉토리로 변경되었습니다.</li>
<li>PHP CLI 버전은 <code>php.ini</code> 지시어 설정과 상관없이 항상 전역 <code>$argv</code>(Array of arguments passed to script) 와 <code>$argc</code>(The number of arguments passed to script) 변수를 가지며, <code>register_argc_argv</code>(argv와 argc 변수를 선언할지 여부 설정)를 <code>off</code>로 설정해도 영향을 미치지 않습니다.</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>ISAPI 모듈들의 이름이 php4xxx에서 php5xxx로 바뀌었습니다.</li>
<li>프로퍼티가 없는 객체를 &ldquo;빈&rdquo; 것으로 판단하지 않습니다.</li>
<li>인터페이스 등을 사용할 경우, 사용 전 선언해야합니다.</li>
<li>포함한 파일에 함수정의가 있을경우, 그 파일이 두번 포함 되었을 때,PHP5에서는 치명적인 오류가 발생합니다. include_once를 사용하길 권장합니다.</li>
<li>키워드
<ul>
<li>예외처리(try()-catch()-finally()[v5.5~])</li>
<li>네임스페이스[v5.3~]</li>
<li>인터페이스(interface,implements)</li>
<li>추상클래스(abstract)</li>
<li>접근제어자(private,protected,public)</li>
<li>instanceof : 객체의 클래스 확인</li>
<li>clone : 객체 복제</li>
<li>컴파일 상수
<ul>
<li><code>__NAMESPACE__</code> [v5.3~]</li>
<li><code>__DIR__</code> [v5.3~]</li>
</ul>
</li>
</ul>
</li>
<li>DataBase
<ul>
<li>MySQL 클라이언트 라이브러리를 포함하지 않습니다.</li>
<li>MySQL 4.1 이상에서 동작하는 <a href="https://php.net/manual/kr/ref.mysqli.php" title="공식 문서로 이동" target="_blank" rel="noopener noreferrer">MySQLi</a>가 추가되었습니다.</li>
<li><a href="https://php.net/manual/kr/ref.sqlite.php" target="_blank" rel="noopener noreferrer">SQLite</a> 확장 모듈이 포함됩니다.</li>
</ul>
</li>
<li>새로운 함수가 추가되었습니다.(New Functions)
<ul>
<li>배열 (9개)
<ul>
<li><a href="https://php.net/manual/kr/function.array-combine.php" target="_blank" rel="noopener noreferrer">array_combine()</a> : 하나의 배열은 키로, 하나의 배열은 값으로 가지는 배열 생성 합니다.</li>
<li><a href="https://php.net/manual/kr/function.array-walk-recursive.php" target="_blank" rel="noopener noreferrer">array_walk_recursive()</a> : 배열의 모든 원소에 사용자 함수를 적용합니다.</li>
<li>이 외의 7개 함수</li>
</ul>
</li>
<li>iconv (7개)
<ul>
<li><a href="https://php.net/manual/kr/function.iconv-strlen.php" target="_blank" rel="noopener noreferrer">iconv_strlen()</a> : 문자열의 문자 수를 반환 합니다.</li>
<li><a href="https://php.net/manual/kr/function.iconv-strpos.php" target="_blank" rel="noopener noreferrer">iconv_strpos()</a> : haystack에서 needle이 처음으로 나타나는 위치를 찾습니다.</li>
<li><a href="https://php.net/manual/kr/function.iconv-strrpos.php" target="_blank" rel="noopener noreferrer">iconv_strrpos()</a> : haystack에서 needle이 마지막으로 나타나는 위치를 찾습니다.</li>
<li><a href="https://php.net/manual/kr/function.iconv-substr.php" target="_blank" rel="noopener noreferrer">iconv_substr()</a> : 문자열의 일부를 잘라냅니다.</li>
<li>이 외의 3개 함수</li>
</ul>
</li>
<li>스트림 (8개)
<ul>
<li><a href="https://php.net/manual/kr/function.stream-copy-to-stream.php" target="_blank" rel="noopener noreferrer">stream_copy_to_stream()</a> : 한 스트림의 데이터를 다른 스트림으로 복제합니다.</li>
<li><a href="https://php.net/manual/kr/function.stream-get-line.php" target="_blank" rel="noopener noreferrer">stream_get_line()</a> : 스트림 자원에서 주어진 구분자로 나타나는 열을 얻습니다.</li>
<li>이 외의 6개 함수</li>
</ul>
</li>
<li>날짜와 시간 관련 (4개)
<ul>
<li><a href="https://php.net/manual/kr/function.idate.php" target="_blank" rel="noopener noreferrer">idate()</a> : 지역 날짜/시간을 정수로 바꿉니다.</li>
<li><a href="https://php.net/manual/kr/function.date-sunset.php" target="_blank" rel="noopener noreferrer">date_sunset()</a> : 주어진 날짜와 위치의 일몰 시간을 반환합니다.</li>
<li><a href="https://php.net/manual/kr/function.date-sunrise.php" target="_blank" rel="noopener noreferrer">date_sunrise()</a> : 주어진 날짜와 위치의 일출 시간을 반환합니다.</li>
<li><a href="https://php.net/manual/kr/function.time-nanosleep.php" target="_blank" rel="noopener noreferrer">time_nanosleep()</a> : 초와 나노초의 수만큼 지연합니다.</li>
</ul>
</li>
<li>문자열 (3개)
<ul>
<li><a href="https://php.net/manual/kr/function.str-split.php" target="_blank" rel="noopener noreferrer">str_split()</a> : 문자열을 배열로 변환합니다.</li>
<li><a href="https://php.net/manual/kr/function.strpbrk.php" target="_blank" rel="noopener noreferrer">strbrk()</a> : 문자열에서 문자 세트에 있는 문자를 검색합니다.(대소문자 구분하여 세트중 한글자라도 먼저 나오는것을 찾습니다.)</li>
<li><a href="https://php.net/manual/kr/function.substr-compare.php" target="_blank" rel="noopener noreferrer">substr_compare()</a> : 두 문자열을 offset부터 length까지(대소문자 구분없이:옵션) 바이너리로 안전하게 비교합니다.</li>
</ul>
</li>
<li>인터베이스 (19개)</li>
<li>기타 (30개)
<ul>
<li><a href="https://php.net/manual/kr/function.file-put-contents.php" target="_blank" rel="noopener noreferrer">file_put_contents()</a> : 문자열을 파일로 씁니다.</li>
<li><a href="https://php.net/manual/kr/function.get-headers.php" target="_blank" rel="noopener noreferrer">get_headers()</a> : HTTP 요청의 응답으로 서버가 보낸 모든 헤더를 가져옵니다.</li>
<li><a href="https://php.net/manual/kr/function.http-build-query.php" target="_blank" rel="noopener noreferrer">http_build_query()</a> : 배열을 이용하여 URL-encode한 쿼리 문자열을 생성합니다.</li>
<li><a href="https://php.net/manual/kr/function.scandir.php" target="_blank" rel="noopener noreferrer">scandir()</a> : 지정한 경로 안에 파일과 디렉토리 목록을 배열로 반환합니다.</li>
<li>이 외의 27개 함수</li>
</ul>
</li>
<li>자세한 내용은 <a href="https://php.net/manual/kr/migration5.functions.php" target="_blank" rel="noopener noreferrer">해당링크</a>에서 확인 하실 수 있습니다.</li>
</ul>
</li>
<li>새로운 지시어 (<code>php.ini</code> 지시어)
<ul>
<li>mail.force_extra_parameter</li>
<li><a href="https://php.net/manual/kr/ini.core.php#ini.register-long-arrays" target="_blank" rel="noopener noreferrer">register_long_arrays</a></li>
<li><a href="https://php.net/manual/kr/session.configuration.php#ini.session.hash-function" target="_blank" rel="noopener noreferrer">session.hash_function</a> : 해시 함수 선택(MD5 or SHA-1)</li>
<li><a href="https://php.net/manual/kr/session.configuration.php#ini.session.hash-bits-per-character" target="_blank" rel="noopener noreferrer">session.hash_bits_per_character</a></li>
<li><a href="https://php.net/manual/kr/ini.core.php#ini.zend.ze1-compatibility-mode" target="_blank" rel="noopener noreferrer">zend.ze1_compatibility_mode</a> : 젠드엔진1 (PHP 4)호환모드 활성화</li>
</ul>
</li>
</ul>
<h5 id="기타-자세한-사항은-해당링크httpsphpnetmanualkrmigration5php에서-확인-하실-수-있습니다" class="headerLink">
    <a href="#%ea%b8%b0%ed%83%80-%ec%9e%90%ec%84%b8%ed%95%9c-%ec%82%ac%ed%95%ad%ec%9d%80-%ed%95%b4%eb%8b%b9%eb%a7%81%ed%81%achttpsphpnetmanualkrmigration5php%ec%97%90%ec%84%9c-%ed%99%95%ec%9d%b8-%ed%95%98%ec%8b%a4-%ec%88%98-%ec%9e%88%ec%8a%b5%eb%8b%88%eb%8b%a4" class="header-mark"></a>기타 자세한 사항은 <a href="https://php.net/manual/kr/migration5.php" target="_blank" rel="noopener noreferrer">해당링크</a>에서 확인 하실 수 있습니다.</h5><blockquote>
<p>참고자료</p>
</blockquote>
<ul>
<li><a href="https://php.net/manual/kr/migration5.php" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">PHP 공식문서 - PHP4에서 PHP 5.0.x로 이행</a></li>
</ul>
]]></description></item><item><title>［PHP］ PSR(PHP Standards Recommendations)이란?</title><link>http://blog.hodory.dev/2018/04/18/what-is-psr/</link><pubDate>Wed, 18 Apr 2018 02:28:50 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2018/04/18/what-is-psr/</guid><description><![CDATA[<h3 id="psr이란" class="headerLink">
    <a href="#psr%ec%9d%b4%eb%9e%80" class="header-mark"></a>PSR이란?</h3><p>PHP Standards Recommendations의 약자로 <a href="https://www.php-fig.org/" title="PHP-FIG로 이동" target="_blank" rel="noopener noreferrer">PHP-FIG(PHP-FrameWork Interop Group)</a>에서 만든 표준 권고안입니다.</p>
<ul>
<li><a href="#PSR-0-DEPRECATED-Autoloading-Standard" rel="">PSR-0</a></li>
<li><a href="#PSR-1-Basic-Coding-Standard" rel="">PSR-1</a></li>
<li><a href="#PSR-2-Coding-Style-Guide" rel="">PSR-2</a></li>
<li><a href="#PSR-3-Logger-Interface" rel="">PSR-3</a></li>
<li><a href="#PSR-4-Autoloader" rel="">PSR-4</a></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>작성예정 목록
<ul>
<li>PSR-6</li>
<li>PSR-7</li>
<li>PSR-11</li>
<li>PSR-13</li>
<li>PSR-15</li>
<li>PSR-16</li>
</ul>
</li>
</ul>
<h4 id="psr-0-deprecated--autoloading-standard" class="headerLink">
    <a href="#psr-0-deprecated--autoloading-standard" class="header-mark"></a>PSR-0 (DEPRECATED) : Autoloading Standard</h4><p>오토로딩 표준으로 PSR-4가 제정되며 DEPRECATED 되었습니다.</p>
<ul>
<li><code>\&lt;Vendor Name&gt;\(&lt;NameSpace&gt;\)*&lt;Class Name&gt;</code>의 구조를 따릅니다.</li>
<li>각 네임스페이스는 <code>(&quot;Vendor Name&quot;)</code>이 최상위 네임스페이스로 있어야합니다.</li>
<li>각 네임스페이스는 원하는 만큼 하위 네임스페이스를 가질 수 있습니다.</li>
<li>각 네임스페이스 구분자는 파일시스템에서 로딩될때 <code>DIRECTORY_SEPARATOR</code>로 변환됩니다.</li>
<li>클래스명의 각 <code>_</code> 문자는 <code>DIRECTORY_SEPARATOR</code>로 변환됩니다.</li>
<li>기타 자세한 사항은 <a href="https://www.php-fig.org/psr/psr-0/" title="PSR-0 문서로 이동" target="_blank" rel="noopener noreferrer">PSR-0</a>에서 확인 가능합니다.</li>
</ul>
<h5 id="example" class="headerLink">
    <a href="#example" class="header-mark"></a>Example)</h5><p><code>\Doctrine\Commone\IsolatedClassLoader</code>
<code>=&gt;/path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php</code>
<code>\Symfony\Core\Request</code>
<code>=&gt;/path/to/project/lib/vendor/Symfony/Core/Request.php</code></p>
<h4 id="psr-1--basic-coding-standard" class="headerLink">
    <a href="#psr-1--basic-coding-standard" class="header-mark"></a>PSR-1 : Basic Coding Standard</h4><p>PHP 코드를 공유하는데 있어 기술적 상호 운용성을 위해 고려 해야 할 표준 코딩 가이드입니다.</p>
<ul>
<li>
<p><code>&lt;?php</code> 와  <code>&lt;?=</code> 태그만 사용해야합니다.</p>
</li>
<li>
<p>PHP 코드에는 BOM(Byte Order Mark) 없이 UTF-8로만 사용해야합니다.</p>
</li>
<li>
<p>네임스페이스와 클래스는 PSR(PSR-0, PSR-4)의 오토로딩을 따라야합니다.</p>
<ul>
<li>클래스명은 <code>StudlyCaps</code> 와 같이 첫글자를 대문자로 합니다.</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="c1">// PHP 5.3 이후 버전
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">namespace</span> <span class="nx">Vendor\Model</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Foo</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// PHP 5.3 이전 버전
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Vendor_Model_Foo</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>상수는 <code>_</code>를 구분자로 대문자로 선언해야합니다. <code>ex)const CURRENT_VERSION = 1.0;</code></p>
</li>
<li>
<p>프로퍼티명에 대한 규칙은 정해져 있지않으나, 스코프에서 일관적이어야합니다.</p>
</li>
<li>
<p>메소드는 카멜케이스를 사용해야합니다. <code>ex)camelCase()</code></p>
</li>
</ul>
<h4 id="psr-2--coding-style-guide" class="headerLink">
    <a href="#psr-2--coding-style-guide" class="header-mark"></a>PSR-2 : Coding Style Guide</h4><p>PSR-1의 확장으로 표준 코딩 스타일 가이드를 다룹니다.</p>
<ul>
<li>
<p>PSR-1을 따라야합니다.</p>
</li>
<li>
<p>들여쓰기 할때는 탭을 사용하지 않고 스페이스 4개를 사용합니다.</p>
</li>
<li>
<p>라인 수에 대한 엄격한 제한은 아니지만, 한 줄에는 120자 이하, 라인 수는 80개 이하로 작성합니다.</p>
</li>
<li>
<p>namespace선언과 use 선언들 후에는 한줄을 띄워 작성합니다.</p>
</li>
<li>
<p>클래스와 메소드들의 여는 괄호는 다음줄에 작성하고, 닫는 괄호는 내용이 끝난 다음 줄에 작성합니다.</p>
<ul>
<li>ex)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nx">Vendor\Package</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">BazClass</span> <span class="k">as</span> <span class="nx">Baz</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">OtherVendor\OtherPackage\BazClass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">TestClass</span> <span class="k">extends</span> <span class="nx">Baz</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">alert</span><span class="p">(</span><span class="nv">$msg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">echo</span> <span class="nv">$msg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
<li>
<p>모든 프로퍼티와 메소드는 접근제어자가 선언되어야합니다.</p>
<ul>
<li>abstract와 final 키워드는 접근제어자 이전에 선언되고, static 키워드는 접근제어자 이후에 선언되어야합니다.</li>
</ul>
</li>
<li>
<p>제어문은 사이에 스페이스가 있어야합니다.</p>
<ul>
<li>메소드와 함수호출은 그렇지 않습니다.</li>
<li>ex)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span> <span class="k">function</span> <span class="nf">Foo</span><span class="p">(</span><span class="nv">$a</span><span class="p">,</span> <span class="nv">$b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="nv">$a</span> <span class="o">===</span> <span class="nv">$b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">echo</span> <span class="s2">&#34;equal&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">Foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span></code></pre></div></li>
<li>
<p>PHP 파일은 빈 줄로 끝나야 하며, PHP로만 이루어진 파일은 닫는 태그인 <code>?&gt;</code>를 생략해야합니다.</p>
</li>
</ul>
<h4 id="psr-3--logger-interface" class="headerLink">
    <a href="#psr-3--logger-interface" class="header-mark"></a>PSR-3 : Logger Interface</h4><p>로깅 라이브러리의 공통적인 인터페이스를 명세합니다.
라이브러리가 <code>Psr\Log\LoggerInterface</code>의 객체를 받아 간편하고 보편적인 방법으로 그것에 로그를 작성할 수 있도록 하는것이 목표입니다.</p>
<ul>
<li>로거 인터페이스는 8개의 <a href="https://tools.ietf.org/html/rfc5424" target="_blank" rel="noopener noreferrer">RFC 5424</a> 레벨(debug, info, notice, warning, error, critical, alert, emergency)로 로그 작성을 하기 위한 메소드를 제공합니다.</li>
<li>9번째 메소드인 <code>log</code>는 첫번째 인자로 로그 레벨을 받고, 호출시 해당 레벨의 메소드를 호출하는것과 같은 결과를 가집니다.
<ul>
<li>해당 레벨의 메소드가 정의되어 있지 않는 경우, <code>Psr\Log\InvalidArgumentException</code> 에러를 보내야합니다.</li>
</ul>
</li>
<li>모든 메소드는 string 형식의 메시지를 받거나, __toString() 처리 된 object를 받습니다.</li>
<li>컨텍스트에 주어진 값을 execption에 보내거나, php error나 warning, notice로 보내면 안됩니다.</li>
</ul>
<h4 id="psr-4--autoloader" class="headerLink">
    <a href="#psr-4--autoloader" class="header-mark"></a>PSR-4 : Autoloader</h4><p>파일 경로를 통해 클래스를 오토로딩 하기위한 명세로, PSR-0를 포함하고 있습니다.</p>
<ul>
<li><code>class</code>라는 용어는 클래스와 인터페이스, 트레이트 또는 다른 비슷한 구조들을 의미합니다.</li>
<li>정규화 된 클래스명의 형식은 다음을 따릅니다.
<ul>
<li><code>\&lt;NamespaceName&gt;(\&lt;SubNamespaceNames&gt;)*\&lt;ClassName&gt;</code>
<ul>
<li>네임스페이스의 맨 처음은 &ldquo;Vendor namespace&quot;로 알려진것으로 시작합니다.</li>
<li>하나 이상의 서브네임스페이스명을 가집니다.</li>
<li>끝을 클래스명으로 작성 합니다.</li>
<li>소문자와 대문자의 조합을 혼합하여 작성할 수 있습니다.</li>
<li>대소문자를 구분하여 참조해야합니다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="c1">// guzzle/src/ClientInterface.php
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">namespace</span> <span class="nx">GuzzleHttp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">GuzzleHttp\Exception\GuzzleException</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">interface</span> <span class="nx">ClientInterface</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>GuzzleHttp\Exception\GuzzleException은
GuzzleHttp의 Base-Directory(src) 안에 있는 Exception\GuzzleException.php에 위치합니다.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<blockquote>
<p>참고자료</p>
</blockquote>
<ul>
<li><a href="https://www.php-fig.org/psr/" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">PSR 공식문서</a></li>
<li><a href="https://www.lesstif.com/pages/viewpage.action?pageId=24445325" title="해당 링크로 이동" target="_blank" rel="noopener noreferrer">PHP 표준 권고(PSR) - 정광섭님</a></li>
</ul>
]]></description></item><item><title>［PHP］ 에러 보여주기</title><link>http://blog.hodory.dev/2017/11/17/php-view-error/</link><pubDate>Fri, 17 Nov 2017 15:12:22 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2017/11/17/php-view-error/</guid><description><![CDATA[<h5 id="배포-서버에서는-권장하지-않는-설정입니다" class="headerLink">
    <a href="#%eb%b0%b0%ed%8f%ac-%ec%84%9c%eb%b2%84%ec%97%90%ec%84%9c%eb%8a%94-%ea%b6%8c%ec%9e%a5%ed%95%98%ec%a7%80-%ec%95%8a%eb%8a%94-%ec%84%a4%ec%a0%95%ec%9e%85%eb%8b%88%eb%8b%a4" class="header-mark"></a>배포 서버에서는 권장하지 않는 설정입니다.</h5><h5 id="테스트-서버에서-에러-메세지를-확인하고-싶을때" class="headerLink">
    <a href="#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%84%9c%eb%b2%84%ec%97%90%ec%84%9c-%ec%97%90%eb%9f%ac-%eb%a9%94%ec%84%b8%ec%a7%80%eb%a5%bc-%ed%99%95%ec%9d%b8%ed%95%98%ea%b3%a0-%ec%8b%b6%ec%9d%84%eb%95%8c" class="header-mark"></a>테스트 서버에서 에러 메세지를 확인하고 싶을때</h5><h5 id="해당-php-파일의-최상위나-공통파일의-최상위에-이-소스코드를-넣어주시면-됩니다" class="headerLink">
    <a href="#%ed%95%b4%eb%8b%b9-php-%ed%8c%8c%ec%9d%bc%ec%9d%98-%ec%b5%9c%ec%83%81%ec%9c%84%eb%82%98-%ea%b3%b5%ed%86%b5%ed%8c%8c%ec%9d%bc%ec%9d%98-%ec%b5%9c%ec%83%81%ec%9c%84%ec%97%90-%ec%9d%b4-%ec%86%8c%ec%8a%a4%ec%bd%94%eb%93%9c%eb%a5%bc-%eb%84%a3%ec%96%b4%ec%a3%bc%ec%8b%9c%eb%a9%b4-%eb%90%a9%eb%8b%88%eb%8b%a4" class="header-mark"></a>해당 php 파일의 최상위나 공통파일의 최상위에 이 소스코드를 넣어주시면 됩니다.</h5><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl">    <span class="nx">error_reporting</span><span class="p">(</span><span class="k">E_ALL</span><span class="p">);</span> <span class="c1">//모든 PHP 에러를 리포팅함
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">ini_set</span><span class="p">(</span><span class="s2">&#34;display_errors&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">//php.ini 파일의 &#39;display_errors&#39;를 활성화 시킴
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">?&gt;</span><span class="err">
</span></span></span></code></pre></div>]]></description></item><item><title>［PHP］삼항 연산자</title><link>http://blog.hodory.dev/2017/09/01/conditional-ternary-operator/</link><pubDate>Fri, 01 Sep 2017 10:09:11 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2017/09/01/conditional-ternary-operator/</guid><description><![CDATA[<p>삼항연산자(?:)는 조건식 ? 참일때 실행할로직 : 거짓일때 실행할 로직; 과 같이쓴다. (if-else를 짧게 줄인것)</p>
<p>a 변수값이 있는지 검사한후 값이 있으면 foo값을 반환, 없으면 bar라는 값을 반환</p>
<p><code>ex)</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="nv">$a</span> <span class="o">=</span> <span class="s1">&#39;foo&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$b</span> <span class="o">=</span> <span class="nv">$a</span> <span class="o">?:</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">echo</span> <span class="nv">$b</span><span class="p">;</span>    <span class="c1">// foo
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">?&gt;</span><span class="err">
</span></span></span></code></pre></div>]]></description></item><item><title>［PHP］ 0001과 같이 번호 지정 하기</title><link>http://blog.hodory.dev/2017/08/31/php-str-pad/</link><pubDate>Thu, 31 Aug 2017 21:51:38 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2017/08/31/php-str-pad/</guid><description><![CDATA[<h4 id="php에서-0001과-같이-번호-지정하기" class="headerLink">
    <a href="#php%ec%97%90%ec%84%9c-0001%ea%b3%bc-%ea%b0%99%ec%9d%b4-%eb%b2%88%ed%98%b8-%ec%a7%80%ec%a0%95%ed%95%98%ea%b8%b0" class="header-mark"></a>PHP에서 0001과 같이 번호 지정하기</h4><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="o">&lt;?</span><span class="nx">php</span>
</span></span><span class="line"><span class="cl"><span class="nv">$count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nv">$count</span> <span class="o">=</span> <span class="nx">str_pad</span><span class="p">(</span><span class="nv">$count</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="nx">STR_PAD_LEFT</span><span class="p">);</span> <span class="c1">//0001
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">?&gt;</span><span class="err">
</span></span></span></code></pre></div><p><code>01이나 001 같이 사용할 때는 두번째 파라미터 값에 2(01) 또는 3(001)을 사용하면 된다.</code></p>
]]></description></item></channel></rss>