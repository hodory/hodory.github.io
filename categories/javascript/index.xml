<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Javascript - Category - Web Developer Hodory</title><link>http://blog.hodory.dev/categories/javascript/</link><description>Javascript - Category - Web Developer Hodory</description><generator>Hugo -- gohugo.io</generator><language>ko-KR</language><lastBuildDate>Sun, 05 Jan 2020 18:16:44 +0000</lastBuildDate><atom:link href="http://blog.hodory.dev/categories/javascript/" rel="self" type="application/rss+xml"/><item><title>[JS]Document.ready 의 대안</title><link>http://blog.hodory.dev/2020/01/05/document-ready-alternative/</link><pubDate>Sun, 05 Jan 2020 18:16:44 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2020/01/05/document-ready-alternative/</guid><description>jQuery를 사용할 때, DOM이 로드된 후 처리를 위해 아래와 같은 구문을 많이 사용해왔습니다.
$(function(){ }); // or $(document).ready(function(){ }); 이와 같은 동작을 jQuery 없이 사용 할 수 없을까 찾아 보았는데,
document.addEventListener(&amp;#39;DOMContentLoaded&amp;#39;, () =&amp;gt; { }) 위와 같이 작성하면 됩니다.
DOMContentLoaded는 최초로 HTML 문서가 완전히 로드 및 파싱 되었을때 발생되므로, 모든 리소스(이미지, 스크립트, 스타일 시트 등)가 로드 된 후 발생하는 load 이벤트 보다는 먼저 호출됩니다.
그렇다면 왜 DOMContentLoaded 이벤트 리스너 대신 $(document).</description></item><item><title>［JS］jQuery 두번째 파라미터가 뭐지?</title><link>http://blog.hodory.dev/2019/12/13/what-is-jquery-second-parameter/</link><pubDate>Fri, 13 Dec 2019 18:56:02 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/12/13/what-is-jquery-second-parameter/</guid><description><![CDATA[jQuery로 작성된 코드를 보는데, $(&quot;selectorA&quot;, &quot;selectorB&quot;) 와 같은 코드가 있었습니다. 당연히 기존에 자주 접하던 $(&quot;selectorA, selectorB&quot;) 와 같은 코드인줄 알았으나, 예상과 다르게 동작하여 문서를 확인해 보았습니다.
jQuery 문서에 따르면, A DOM Element, Document, or jQuery to use as context 가 기재되어있다.
해당 영역에는 DOM element가 올 수 있는데 Selector Context를 확인해보면
selector context is implemented with the .find() method, so $( &ldquo;span&rdquo;, this ) is equivalent to $( this ).find( &ldquo;span&rdquo; ).]]></description></item><item><title>［JS］Object literal 보다 JSON.parse()가 더 빠르다</title><link>http://blog.hodory.dev/2019/11/26/json-parse-is-faster-than-object-literal/</link><pubDate>Tue, 26 Nov 2019 22:51:44 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/11/26/json-parse-is-faster-than-object-literal/</guid><description>서론 웹에서 몇 kb 크기의 객체를 초기에 렌더링 하는것은 생각보다 많습니다.
이 javascript 객체가 로드될때까지 클라이언트는 빈 화면을 보게 될 수 있습니다.
이러한 문제를 해결하기 위해, 서버사이드 렌더링을 활용 하는 방법도 있겠지만 다른 방법은 없을까요?
Chrome Dev Summit에서는 객체를 JSON으로 직렬화 하고, 문자열 리터럴로 변환해 Javscript 객체에 전달하는 것이 성능 향상에 도움이 된다고 이야기합니다.
무슨 소리일까? 아래의 두 코드는 동일한 객체를 생성하지만, Javascript 엔진의 경우, JSON 예제를 스캔하고, 파싱만 하기 때문에 빠르다고합니다.</description></item><item><title>［JS］jQuery 없이 Selectbox에서 여러개 선택된 option의 값 추출하기</title><link>http://blog.hodory.dev/2019/05/12/how-to-get-multiple-selected-options-with-vanillajs/</link><pubDate>Sun, 12 May 2019 14:29:38 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/05/12/how-to-get-multiple-selected-options-with-vanillajs/</guid><description><![CDATA[DOM을 다룰때 jQuery를 사용하면 매우 편리합니다.
물론 크로스 브라우저 이슈로도 제이쿼리를 많이 사용합니다.
하지만 DOM을 핸들링하기 위해서만 jQuery를 쓴다면, 편리함은 챙기겠지만 낭비 아닐까싶습니다.
저는 위와 같은 생각으로, 주로 DOM 핸들링에는 jQuery 의존성을 줄이고자 순수 자바스크립트를 사용하려 노력하고 있습니다.
또한, document.querySelector와 document.querySelectorAll 를 이용한다면, jQuery에서 사용하던 복잡한 DOM Selector도 쉽게 사용할 수 있습니다.
&lt;select id=&#34;user&#34; name=&#34;user[]&#34; multiple=&#34;multiple&#34;&gt; &lt;option&gt;선택&lt;/option&gt; &lt;option value=&#34;foo&#34;&gt;Foo&lt;/option&gt; &lt;option value=&#34;bar&#34;&gt;Bar&lt;/option&gt; &lt;option value=&#34;baz&#34;&gt;Baz&lt;/option&gt; &lt;/select&gt; 위와 같은 Multiple SelectBox에서 여러개가 선택되었을 경우 값을 어떻게 가져올까요?]]></description></item><item><title>［JS］Knex와 Webpack을 같이 쓰면서 발생한 오류 처리</title><link>http://blog.hodory.dev/2019/04/18/knex-with-webpack/</link><pubDate>Thu, 18 Apr 2019 19:10:52 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/04/18/knex-with-webpack/</guid><description><![CDATA[ERROR in &#39;./node_modules/knex/lib/dialects/mssql/index.js&#39; Module not found: Error : Can&#39;t resolve &#39;mssql/lib/base&#39; 프로젝트에 웹팩을 도입하여 사용중, knex 라이브러리를 넣고 나서 웹팩으로 빌드시 해당 에러가 나와서 빌드에 실패 했습니다.
해당 오류를 검색 하였는데, 역시나 깃허브 이슈가 있었고(감사합니다), webpack의 config에 아래의 내용을 추가 하였습니다.
externals: { knex: &#39;commonjs knex&#39; } 해당 작업 후 빌드는 성공했지만, 노드 서버에서 실행시 knex 모듈을 찾을 수 없다는 오류가 나왔습니다.
{ &#34;errorMessage&#34;: &#34;Cannot find module &#39;knex&#39;&#34;, &#34;errorType&#34;: &#34;Error&#34;, &#34;stackTrace&#34;: [ &#34;Function.]]></description></item><item><title>［VueJS］vue.js에서 이벤트 버스 사용하기</title><link>http://blog.hodory.dev/2018/08/27/vuejs-eventbus/</link><pubDate>Mon, 27 Aug 2018 16:51:38 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2018/08/27/vuejs-eventbus/</guid><description>MPA(Multi Page Application)에서 Vue를 적용 시키던중
부모-자식간의 관계가 아닌 컴포넌트 간의 동작에 따른 데이터 변화와 이벤트 처리가 필요해졌습니다.
주로 공통 데이터를 다루기 위해 사용하는 부분이라 Vuex를 써볼까도 했지만,
Vuex 튜토리얼에서 앱이 단순하다면 Vuex없이는 괜찮을 것입니다. 간단한 글로벌 이벤트 버스만 있으면됩니다 라는 글귀를 읽고, 글로벌 이벤트 버스를 사용하자로 마음을 굳혔습니다.
아래와 같이 공통으로 사용할 이벤트버스 js 파일을 생성합니다. Vue EventBus 객체를 생성하여 export 하여 다른 파일에서도 로드하여 사용 할 수 있도록 합니다.</description></item><item><title>［JS］ ES5와 ES6 뭐가 다를까?</title><link>http://blog.hodory.dev/2018/04/17/es5-vs-es6/</link><pubDate>Tue, 17 Apr 2018 01:26:53 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2018/04/17/es5-vs-es6/</guid><description>ES5와 ES6를 비교 할겸 ES6를 사용할때 자주 쓰이는 부분만 정리해보았습니다.
Const Variables let Variables Block-Scoped Function Arrow Function Default Parameter Rest Parameter Spread Operator Template Literals Ehhanced Object Properties Property Shorthand Computed Property Names Method Properties Export / Import Class Definition Promise Promise all Const 변수Immutable varibale인 Const 변수(상수 변수)를 지원합니다.(블록-스코프 변수)
const PI = 3.141592 console.log(PI) // 3.141592 let 변수기존의 함수-스코프였던 변수와 다르게 Hoisting 없는 블록-스코프 변수를 지원합니다.
// ES5 console.</description></item><item><title>［Node.js］Express.js로 NodeJS 시작하기</title><link>http://blog.hodory.dev/2018/03/11/start-nodejs/</link><pubDate>Sun, 11 Mar 2018 21:57:18 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2018/03/11/start-nodejs/</guid><description>express 제너레이터 설치npm install express-generator ejs 템플릿을 이용하여 myapp 디렉토리에 생성express myapp --view=ejs myapp 디렉토리로 이동하여 npm install(패키지 설치)$ cd myapp &amp;amp; npm install 서버 실행$ npm start POST전송시 필요한 body-parser와 express-session 설치$ npm install body-parser express-session 기존에는 NodeJS에서 POST 요청 데이터를 추출 할 수 있도록 하기 위하여 bodyParser를 설치해야 했는데 express-generator에 추가 되었다</description></item></channel></rss>