{"posts":[{"title":"［Algorithm］반복문 없이 1부터 10까지 합 구하기","text":"1부터 10까지 합 구하기 먼저 방법은 무엇이 있을까? 등차 수열의 합 재귀함수 방식 기타 등등… 하나씩 구현해보자 등차 수열 등차 수열이란 ?연속하는 두 항의 차이가 모두 일정한 수열. 등차 수열의 합 공식 (출처 : 위키피디아) 코드 구현1234addFunction = (start, end) =&gt; { return (end-start+1)*(start+end)/2}addFunction(1,10) 재귀함수 방식 재귀 함수란?자기 자신을 재 참조 하는 함수 재귀함수 구조(출처 : 위키피디아) ex) 123456factorial = (v) =&gt; { if (v &lt;= 1) return 1 else return v * factorial(v-1)} 코드 구현 ex) 123456addFunction = (v) =&gt; { if (v &lt;= 1) return 1 else return v + addFunction(v-1)} 참고자료 위키백과 - 등차수열 위키백과 - 재귀함수","link":"/2018/04/18/1-to-10-calc-without-for-loop/"},{"title":"2019년 상반기 회고","text":"일년이 어떻게 흘러간지 한해가 지날수록 더 기억이 안 나서정리의 필요성을 느껴, 올해부터는 회고를 진행해볼까 합니다. 💼 회사 01월~02월서버리스 아키텍쳐 구현 마무리 12월부터 설계 및 개발을 진행하였던 서버리스 아키텍처를 12월 중순쯤 배포하였으나,이슈 사항들이 많아 마무리 짓는데 생각보다 오래 걸렸습니다. 외부 싱크 여부를 판단하기 위한 데이터들을 Insert 또는 Update 하다 보니,RDS 콘솔 상에서 IOPS 쓰기가 1000 이상이 되는 경우가 발생했습니다. 해당 데이터를 레디스(Elastic Cache)나 noSQL(DynamoDB)에 쌓은 후, 다시 RDS로 옮기는 것도 검토해보았지만, 실제 구현할 경우 관리 포인트가 너무 많이 발생하게 되어 연동 속도를 줄이더라도 Lambda의 동시성을 조절하는 것으로 처리하였습니다. 02월~03월 On-The-Fly 동적 이미지 리사이징 구현 기존 서비스에서는 이미지 파일을 올릴 때 도메인별로 고정된 크기로 이미지를 리사이징하고 있었습니다. 다양한 해상도에 대한 대응이 어려웠고, 서버에서 동기식으로 이미지를 리사이징 하다 보니 파일 업로드의 응답 시간이 느려지는 문제가 있었습니다. 위 문제의 해결책으로 AWS Lambda를 이용한 이미지 리사이징을 검토하게 되었고,[VCNC] 온디맨드 이미지 리사이징 발표 자료와 [당근마켓] 온디맨드 이미지 리사이징 포스팅을 보았습니다. 해당 방식은 원본 이미지와 변환된 이미지를 모두 가지고 있을 수 있다는 이점이 있으나,다양한 해상도를 모두 제공하는 데에는 비용적 문제가 있다고 판단하여,CloudFront Cache를 이용한 On-The-Fly를 도입하기로 하였습니다. [당근마켓]AWS Lambda@Edge에서 실시간 이미지 리사이즈 &amp; WebP 형식으로 변환 포스팅과 [후이서울]Lambda 한개로 만드는 On-demand Image Resizing 포스팅을 참고하여, Lambda@Edge 서비스를 이용하였습니다. 최초 이미지 생성에 Latency가 발생하나, 캐시 될 경우 빠르게 리사이징 된 이미지를 제공 할 수 있었습니다. 이와 같은 도입으로 이미지 최적화를 통해 모바일 사이트에서 이미지 용량을 최대 1/3까지 줄일 수 있었습니다. 03월~05월해외 업체 예약 API 연동 작년부터 회사에서 서비스를 모놀리식 아키텍처(PHP)에서 마이크로서비스 아키텍쳐(Java Spring Boot)로 마이그레이션중이였습니다. 자바는 학부생때 배웠지만, 스프링을 해 본적이 없어서 개인 시간에 Spring Boot 책도 읽고,정말 간단하게 회원 관리 시스템을 구성하여 AWS Elastic Beanstalk에 배포하는 등 API 연동 작업을 하기 위해 미리 준비를 좀 해두었습니다. 기존에 다른분들이 작성한 코드를 참고하여 작업을 하려했는데,다른분들은 REST API로 작성하였으나, 제가 맡게 된 API는 XML SOAP으로 제공되고 있었습니다…. 기존에 PHP에서는 SOAP을 설치해서 사용해서, 자바 서비스가 실행중인 서버에도 SOAP을 서버에 설치해야하나 고민했습니다만 다행히도 XML 포맷으로만 보내면 HTTP로 요청이 가능했습니다. JAXB를 이용하여 Java 객체 &lt;-&gt; XML 을 처리하였는데,해당 API가 SOAP Body의 특정 스키마부터는 htmlEsacpe를 해서 보내야하거나, 받아야하는 특이한 API 였습니다. 이 연동을 하며, 말로만 듣던 Retrofit 라이브러리도 사용해 보았고, 실제 서비스에서 JPA도 다루어 볼 수 있는 기회가 되었습니다.또한 PHP에서는 클래스의 멤버변수에 값을 주입해서 쓰는 경우가 많았는데,Spring Application Context에서 관리되는 Bean들이 싱글톤으로 관리 되어 발생하였던 문제도 경험도 할 수 있던 좋은 기회였습니다. Webhook 서비스 구축 PHP와 Java를 같이 가져가는 구조에서 백오피스는 기존 그대로 PHP를 유지하고 있는데,외부 업체들에 상품 변경 내역을 실시간으로 웹훅과 같이 전달하는 기능이 요구사항이 생겼습니다. AWS Lambda로 서버리스 아키텍처로 구현하였던 경험을 바탕으로 이번에는 Typescript 템플릿을 사용하여 해당 기능을 빠르게 구현 할 수 있었습니다. 06월모놀리식 서비스 마이그레이션 시작 작년에 PHP에서 쿠폰 서비스를 고도화 작업을 진행하여, 어느정도 도메인에 대한 이해가 있다 생각하여 쿠폰 서비스를 자바로 마이그레이션 하는 작업을 진행했습니다. 우선적으로 개발 해야 했던 기능이 상품 전용 쿠폰을 사용 했을때 할인될 가격을 가져오는 부분인데,제가 개발한 이후로 다국어 서비스 및 다중 통화 지원 서비스가 생겨서 예상치 못했던 변수들이 너무 많았습니다. 해당 부분을 작업 하셨던분들께 여쭤보며 해당 작업을 진행하였습니다. 현재 스프링으로 개발한 서비스들의 인프라 구성이 모두 동일하기 때문에, 인프라 구성은 기존에 서비스를 만들고 계시는 다른 자바 개발자 분들의 도움을 받아 동일하게 구성하였습니다. 사내 인프라 구성에 대해 배울 수 있는 좋은 기회였습니다. 신규 기능 개발 상품에 접근하는 방식을 개선하고자 상품을 새롭게 그룹핑하여 노출하는 신규 서비스가 요구 되었습니다. 프론트와 백엔드 서비스를 분리하는 시작으로 생각하여, 프론트 개발자분과 프론트 서비스 인프라를 어떻게 구성하는게 좋을지 같이 논의하여, 다양한 아이디어를 주고 받아최종적으로는 SEO 지원을 고려하여 Next.js를 이용해 서버사이드 렌더링을하고 기존 서비스에는 영향이 없도록 하기 위해 AWS ELB를 활용하는 방향으로 설계하였습니다. 주요 도메인 설계는 다른분이 진행하여 주시고, 저는 서브로 퍼블릭 서비스에서 해당 데이터를 받아 조합하는 작업을 진행 하였는데, 기존에 도메인간 의존 관계가 너무 커서 퍼블릭 서비스보다 프라이빗 서비스가 모든 처리를 하는 방향으로 개발하게 되어 일정상 특정 기능을 제가 구현해야 하는 상황이 되었습니다. 해당 서비스의 도메인 설계와 구현 해야할 것에 대해 인수인계 받아 작업을 진행 하였고,우여곡절 끝에 7월이 되어서야 빠른검색(가제) 서비스 릴리즈를 완료했습니다. 📒 블로그 어썸데브 블로그 국내 개발자들 블로그를 구독하고 있었는데, 내 포스팅도 많이 노출되어서 많은 피드백을 받았으면 좋겠다 싶어서, 해당 서비스가 어썸데브블로그의 피드를 사용하기때문에 국내 개발자로 등록을 하였습니다. 등록하고 바로 포스팅을 올렸는데 어날리틱스 기준으로 처음으로 블로그 1일 방문자수가 20을 넘었습니다.해당 그래프를 보는게 재밌어서 포스팅을 계속해서 올렸었고, 아래와 같은 그래프를 그릴 수 있었습니다. 노출 수가 많아질수록 더 읽고 싶은글, 읽기 좋은 글 또는 관심가질만한 글들을 써야겠다고 생각하게 되었습니다. 블로그 배포 방식 변경기존에 hexo-cli를 이용해서 배포를 하다가 매번 커맨드를 치는것도 귀찮다 생각하여, package.json에 스크립트를 작성해두었습니다. 팀원에게 Codeship 서비스로 깃허브 블로그 배포 자동화 하는 방법을 소개해주어 팀원분은 이걸 적용했는데,저는 드롭박스로 코드를 관리하고 있었고소스 전용 레포지토리도 따로 관리하고 있었기 때문에 큰 필요성을 못 느꼈습니다. 하지만 hexo deploy 와 소스 전용 브랜치에 커밋&amp;푸시를 별도로 하는게 딱히 메리트가 있다고 생각이 들어 바로 작업을 진행하게 되었습니다. Codeship으로 배포할까 하다가 이번에는 플러그인처럼 프라이빗 repo에서도 깃허브와 연동시 무료로 제공되는 Travis CI를 이용하기로 하였습니다. ChangJoo Park님의 포스팅 Travis CI를 이용한 Github Pages + Hexo 블로그 자동 배포하기을 참조하여 작업을 진행하였고,빈 파일이 올라가는 문제도 겪었지만 블로그 소스 코드 관리 및 배포를 조금 더 간결하게 할 수 있어서의미있는 작업이였다고 생각합니다. Github Actions 서비스가 현재 베타 서비스중이여서 나중에는 이걸로 갈아타지 않을까 생각합니다 도메인 연결과 깃허브 아이디 변경 기존에 Github Page를 이용하여 github.io 도메인을 사용했는데, 지인의 추천을 받아 그날 바로 dev 도메인(hodory.dev)을 구매한 후 엄청난 삽질을 진행하였습니다. 원래는 서브 도메인(blog.hodory.dev)으로 블로그임을 더 확실히 하고 싶어서 서브도메인만 쓰려 했는데, 구글 애드센스때문에 루트도메인도 리디렉션 처리를 했습니다. 도메인을 여기저기 잘 활용하고 있어서, 도메인을 구입한거에 대해서는 전혀 후회하지 않습니다. 아쉬운점이라면 구글 서치 콘솔에 쌓인 2년간의 데이터를 잃어버린점이지만 크게 의미 있는 데이터는 아니였다고 생각합니다.(기존의 구글 검색에 노출되는 포스팅은 전부 현재 도메인으로 리디렉션 시켰습니다.) 🏃 일상 💪 운동 앉아서만 일을 하다보니 활동량이 줄어들어 계속해서 체중이 증가하고 있었습니다. 체력적으로도 문제가 될 수 있겠다 싶어, 4월부터 회사 근처에서 운동을 다니기 시작하였는데,운동을 안하는 날에도 열심히 먹었지만 오히려 보상 심리로 운동이 끝난 후 더 많이 먹어서 체중이 늘어난거 같습니다… 꾸준히 다녀야지 하고 시작했던 운동인데, 간간히 운동 빠지는 재미가 쏠쏠합니다… 🔧 프로젝트 인스타그램으로 맛집을 많이 찾아 돌아 다녔는데 광고가 많아져서 몇번 데이고 나니,제가 필요해서 프라이빗한 SNS를 만들어볼까? 생각하고 대학 동기들과 프로젝트를 진행하였습니다. 당시 스프링을 공부하고 있어서 스프링 부트로 서비스를 만들고, 기획도 진행하고, PM 역할까지 같이 했는데 중간에 슬럼프도 오고 각자의 사정으로 잠시 중단한 상태입니다. 하반기에는 위에 작성한 SNS 프로젝트를 다시 진행하고 싶은데, 같이 프로젝트를 진행하던 팀원들이 다들 바빠져서 가능할지 모르겠습니다. 면접에서 좋은 면접관님을 만나 평소에 생각하지 않았던 것들에 대한 좋은 질문을 받을 수 있는 기회가 있었는데, 굉장히 긍정적인 경험이였습니다.하반기에는 이러한것들을 함께 고민해 볼 수 있는 자리를 찾아 볼까 합니다. 이직을 하게 되었는데, 우선적으로 새로운 회사에 빠르게 적응 해야 할 것 같습니다. 경력이 이제 3년이 되어 가는데, 아직까진 주위에서 &quot;잘하고 있다.&quot; &quot;잘한다.&quot;라는 좋은 이야기들을 들으며 일해 왔는데, 주관적으로 보았을때에도 아직 경력에 비해서도 모자른게 많이 느껴집니다.3년이면 프레임워크정도는 혼자서 만들 수 있고, 사이드 프로젝트로 서비스 하나 정도는 릴리즈 하거나, 오픈 소스에 기여할 수 있을줄 알았는데이정도 년차에 잘 하시는 분들은 이미 위의 세개중 하나에서 두개정도는 하시는것 같아서 더 분발해야할 것 같습니다. 알고리즘과 자료구조, 네트워크 지식 등 기본 지식들을 공부해야지... 공부해야지... 라고 말만 3년째 하고 있는것 같습니다. 물론 실무를 경험하며, 면접을 준비 하며, 블로그를 보다가 배우는 것들도 있긴한데 하나를 알아도 제대로 알아야 할 것 같습니다. 최근에 블로그를 찾아서 아는것만으로는 공부가 아니다라는 말씀을 들어 저처럼 본인이 아는걸 작성하고 공유한 글인데, 무분별하게 받아 들이던 제 자신을 반성하게 되었습니다.출판 서적으로 공부하는게 정석이라고는 생각은 하면서 실천하지 못해, 하반기에는 노력해야 할 것 같습니다.","link":"/2019/07/10/2019%EB%85%84-%EC%83%81%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0/"},{"title":"2019년 하반기 회고","text":"상반기 회고 당시에는 하반기에는 분기별 회고를 해서 더 잘 정리해야겠다 생각했는데,하반기 회고 조차 늦어지게 되었습니다. 💼 회사 새 회사로 이직을 하게 되면서, 인수인계 기간이 지난 후 약 3주정도 휴가를 즐겼습니다. 여행도 다녀오고, 쉬는 기간동안 카페 투어도 하고 이곳 저곳 돌아다녔지만 생각보다 생산성 있는 휴가는 아니여서아직 아쉬움이 남아있습니다. 새 회사로 오게되어 회사에 적응하는 시간을 보내고 실무에 투입되었습니다.이정도 규모의 회사에서는 어떻게 서비스를 하고 있고, 현재 서비스에서 어떤 문제를 가지고 있어서 그것을 해결하기 위해 어떤 고민을 하고 있는지, 앞으로 어떤 계획이 있는지 등을 어깨넘어 보면서 새로운것들을 알아가고 있습니다.생각보다 많은 일들이 동시에 빠르게 진행 되고 있으면서도 아쉬움이 느껴졌습니다. 무엇보다 업무적 문서화가 아닌 공유 목적의 개인적인 문서화와 일정 관리 체계가 이렇게 잘 되어 있는 기업에서 일해본 경험이 처음이라 이러한 부분은 너무 만족스럽습니다. 최근에 스타트업에서 성장한다는 주니어의 착각 이라는 포스팅을 접하게 되었습니다.해당 글을 보며 과연 이전 회사에서 내가 느끼고 있었던 나는 이곳과 함께 빠르게 성장하고 있다 라는 생각이 어찌보면 혼자만의 착각이 아니였을까 다시 한번 돌아보는 기회를 준 고마운 글이었습니다. 지금은 스타트업에서 근무할때 처럼 기존의 것이 문제가 된다면 새로운걸 빠르게 도입하고 결과물을 확인하고 기존의 것은 대체 할 수 있는것은 아니지만,오히려 많은 사람들이 쓰고 있는 솔루션에서 호환성 유지를 위해 문제 없이 기능을 개선하면서도과연 최적의 방법일까 다시 한 번 더 고민해보면서 얻고 있는 이점들이 있습니다. 📒 블로그 블로그 배포 방식 변경상반기에는 Travis CI로 블로그를 배포하도록 변경하였는데, Github Actions 신청이 가능해지면서 배포 방식을 Github Actions로 옮겼습니다. Travis CI에서 Private Repo Free 제한이 Codeship 서비스와 동일하게 월 100회인줄 알았으나, 토탈 100회인것을 알고 시간여유가 있을때 빠르게 옮겨야겠다 싶었습니다. 코드는 이전과 동일하게 Dropbox에서 동기화 하면서도 Github Private Repo로 형상관리 하고있습니다. 해당 내용은 Github Actions를 이용하여 Hexo 블로그 배포하기 에 포스팅 되어있습니다만,허원철님의 Github Actions 를 사용하는게 더 빠르게 설정하기 좋은것 같습니다. TIL Repo 생성새로 알게 된 것들, 오류를 해결한 경험 등을 블로그에 포스팅해서 한글로 공유하고 싶었으나,오히려 포스팅이다보니 어느정도 갖춰 작성하려는것에 대한 부담감으로 작성을 미루게 되는 문제점이 발생했습니다. 이를 해결하고자 기존에 Notion에 간단하게 정리하거나 가볍게 정리할 내용을TIL 레포지토리 에 작성하고 있습니다. 🏃 일상 💪 운동상반기에 잠시나마 운동을 시작 했는데, 퇴사 시기와 맞물리게 헬스장도 끝나서 아직까지 운동을 안하고 있습니다. 운동을 할 때는 운동을 해도 왜 이렇게 체력은 늘지 않고 피곤할까 하며 몰랐는데,안 하면서 저질 체력을 더 크게 느끼고 있습니다…. 이동욱님의 하반기 회고록 포스팅을 보며 자극되는점이 너무 많았고,더 오래 오래 지금 하고 있는 일을 하기 위해서는 건강이 제일 우선이기때문에 상반기에는 다시 운동을 시작해야겠습니다. 신년 계획 1일 1커밋12월즈음부터 1일 1커밋을 진행하고 있는데, 이걸로 얻을 수 있는 장점은 잠시나마 커밋을 하기 위해 시간을 내고 있다는것었습니다. 하지만 한달쯤 진행 해 보았는데 이것을 깨뜨리지 않기 위해 오히려 의미없는 커밋을 하고 있는건 아닌가라는 것을 고민하게 되었습니다. 그래도 이것을 이어가기 위해서 무언가 정리하고 공부하게 된다 라는점은 이점으로 자리잡고 있어,상반기에는 지속하는게 목표이긴하나, 이것때문에 무언가를 포기한다거나 하는식으로 너무 얽매이지는 않도록 해야겠습니다. 프로젝트매번 흐지부지 되는 프로젝트가 너무 많아서 그저 강의를 따라해서 만들어낸 결과물이 아닌,혼자서 무언가 만들어낸 결과물이 나올 수 있는 프로젝트를 진행하는게 목표입니다. 진행할 아이템은 많으나 가볍게 시작해서 빠르게 결과물을 내어볼 수 있는게 이중에 무엇일지 생각해보고,만들어보고싶습니다. 운동자극제남들과 나 자신을 비교하는 제 성격이 장점은 아니나, 이 부분을 자극제로 사용할 수 있는 방향으로 긍정적으로 활용 해왔습니다.그리고 감사하게도 항상 제 가까이에 제가 자극이 될 수 있는 좋은분들이 계셔주셔서 지금의 제가 있을 수 있지 않았을까 생각합니다. 이동욱 개발자님 이 유튜브에서 진행하여 주신 인터뷰나 회고록 등을 보며 더 열심히, 그리고 꾸준히 해야겠다는 자극을 얻을 수 있었습니다.특히나 더 오래 잘 하고 싶어서 본인에게 투자하신다는 부분에서는 뭔가 대단하시다고 느껴졌습니다. 하지만 다른사람이 편한 신발이 내게도 편할 수 없는것처럼 곧이 곧대로 따라하는게 아니라저에게 맞는 방식을 찾아서 제게 좋은 자극이 되어주시는 분들과 같이 꾸준히, 그리고 열심히 해야겠습니다. 일정관리내가 해오던 것, 해야할 것, 하고싶은것과 개인적인 캘린더 일정 들을 이곳 저곳에 따로 정리하다보니매번 내가 지금 무엇을 해야할지 무엇을 하기로 했는지를 잊는 경우가 많습니다. 회사 다이어리(미팅 내용정리 및 공유 내용 정리와 일정 기입), Notion(개인적인 일정 또는 내용 정리), 캘린더 앱, 카카오톡 캘린더 등을 모두 따로 관리 하는게 필요한 것만 볼 수 있다는 장점이 있지만,오늘 무엇을 하기로 했지? 라는 생각이 들 때는 모든것을 들여다 보아야한다는 단점을 요즘들어 느끼고 있습니다. 또한 개인적으로 무언가를 진행해야하고 진행할것이다 라는것이 주어지면 큰 틀만 잡고 잘게 나누지 않아,기한이 없어 계속 진행이 늘어지는 문제가 있어서 개인적인 일정도 기한을 정하는게 좋을 것 같습니다. 독서원래부터 책을 가까이 하지 않았었고 책을 읽을 시간이 있다면 관심 있는 기술 서적을 더 많이 읽는 편인데,정리되지 않은 상태로 말을 하고 글을 적는것을 고치는데 도움이 되지 않을까 싶어두달에 한권정도는 업무 외의 책을 읽을 수 있지 않을까 생각하고 있습니다.","link":"/2020/01/11/2019%EB%85%84-%ED%95%98%EB%B0%98%EA%B8%B0-%ED%9A%8C%EA%B3%A0/"},{"title":"AWS Dev Day Seoul, 2019 메모","text":"틀린 내용이 있다면 제가 졸아서 잘못 메모했을 수 있습니다….. AWS Fargate를 사용한 서버리스 컨테이너 활용 하기 - 삼성전자 개발자 포털 사례 ECS EKS Fargate for ECS Fargate for EKS (on the roadmap) ECS쿠베 없이 간단하게 사용가능 EC2 인스턴스를 직접관리해야하는 단점 Fargate를 활용해 해결 가능 서버가 없는 컨테이너 환경 서비스와 컨테이너에대한설정만 관리 ECS 대비 EC2 관리에대한 부담만 덜어짐 ECR을 이용해 이미지를 배포할 수 있음 Networking - aws LayerStorage - task당 10GB VolumeStorage - 공용 볼륨 QA Automation을 중점적으로 CI/CD를 구축함 SRE 아키텍쳐 ECS 클러스터를 이용함. Fargate 활용시 → 무중단배포전략 기본 탑재, 빠르게 deploy 가능, 비용 절감 ECS의 EC2옵션에 비해 45%절감(compute 비용만) task 별로 관리가 가능하기때문 워크스페이스를 CloudFoundry playform 오픈 소스를 사용하여 구현프로메테우스기반으로 VALET 대시보드 구현 task가 runtime으로 넘어갔을때만 과금이 됨. 클러스터안에 서비스가 매핑 활용 사례백엔드기준 서치, k-v DB, API 클러스터세팅 TG,vpc,subnet,SG task cpu : 1024 MB , 512 task CPU Events 탭을 이용하여, 이벤트 발생 확인 가능 build.sh → upload.sh (ECR에 업로드) ECS workshop - https://ecsworkshop.com/ 실시간 데이터 처리를 위한 현대적 애플리케이션 개발 방법AmplifyCLI 툴체인 및 UI 구성요소 포함하는 클라이언트 프레임워크전체 앱 구축 테스트 배포 및 호스팅을 위한 dev tool 제공 AppSync관리형 서버리스 gQL 서비스다양한 데이터 소스 활용 가능디바이스가 오프라인일 경우에도 가능오프라인시 변경된 데이터만 동기화처리 queries → getmutation → create | updatesubscriptions → pub | sub CognitoIAM을 모두 제공할 수 없음 KinesisDocumentDB엘라스틱서치 DB 랑 유사하게보임몽고 DB와 호환됨초당 수백만건 요청 처리 가능컴퓨팅과 스토리지 레이어를 분리하여 컴퓨팅 리소스만 확장 가능, 스토리지는 오토스케일됨데이터를 파티션으로 분산저장(3개의 AZ에 복제) AppSync를 활용하여 query와 mutation 분리 DevOps 개발자가 되기 위한 쿠버네티스 핵심 활용 예제 알아보기3개의 az에 마스터 노드 배포az당 두개의 인스턴스 배포c타입 인스턴스로 배포됨 deprecated 되는 시점에 마스터노드를 강제 업데이트함.Latest 버전부터 3개 이내의 버전으로 관리되도록 aws에서 관리해줌 EKS는 명령형 인프라가 아닌 선언형 인프라 VPC ink → Network load Balancer How To Connect with Kubernetes 쿠버네티스에서 제공하는 로드밸런서 ALB ingress → IP가 유동적이라 Lambda에서 처리할 수 있으나 번거로움 쿠버네티스의 Node Port 이용 kube2Iam을 이용해 IAM을 관리 HPA → pod 오토스케일링 Cluster autoscaler → 노드 오토스케일링(pod를 더 이상 배치할 공간이 없을때) Monitoring 프로메테우스를 통해 수집 → 그라파나를 통해 → cloudwatch 메트릭을 사용해 대시보드 제공 로그 : 엘라스틱서치와 클라우드워치 fluentD 클라우드워치를 두고 로그패턴을 이용해 노티 가능 → 엘라스틱서치로 전송 엘라스틱 서치 Authentication은 cognito nginx 리버스프록시로 사용해 키바나접근 AWS Xray를 이용해 APM 체크 배포는 Spinnaker를 이용해서 쿠버네티스 배포할때 용이 pod는 엔드포인트도 계속 변경됨eks 자체 기능으로 IAM과 쿠버네티스의 IAM을 연결하는 기능 제공예정 Monitor기존에는 가장 성능 좋은 쿠버네티스 로깅 플랫폼 fluentd(루비로 작성됨)→ fluent Bit이 C로 만들어진 더 고성능을 요구할때 사용할 수 있는 플랫폼 Networking어노테이션만으로 nlb alb 등 선택 가능ALB는 L7형태로 ingress controller에서 해석해서 처리 LoggingEFKpod → fluentd → cloudwatch→ kibanaFluentBit을 사용하면 더 Optimized 할 수 있다. Application Mesh기존 서비스 Mesh는 envoy proxy를 사용AppMesh는 EKS만 쓸 수 있는게 아닌 Fargate ECS EC2 EKS Kube on EC2등에서도 사용가능 Distribute Logging전체 콜스택 모니터링하기 어려움X-Ray를 활용모든 쿼리스트링 모니터링 가능 코드 기반 인프라(IaC)를 활용한 현대 애플리케이션 개발 가속화, 우리도 할 수 있어요Re-host데이터센터 → EC2 Re-platform가상머신 → 컨테이너 Re-factor모놀리스 → 마이크로 서비스 Re-invent호스트플릿 → 서버리스 자동화 인프라 구성 자동화 서비스에 필요한 리소스 프로비저닝 애플리케이션 배포 자동화 애플리케이션을 더 효율적, 안전하며, 빠르게 배포 애플리케이션을 빌드, 테스트, 배포 코드기반 인프라의 목적인프라 변경 사항을 반복적이고 예측 가능하게 함. CloudFormation클라우드 인프라 템플릿을 정의하기 위한 언어 - JSON | YAML 1234$ cdk init$ cdk diff$ cdk deploy [paramter]# if you type &quot;y&quot;, deploy the app CDK Deploy 를 활용하면 Cloudformation을 활용해 배포하게됨 cdk를 사용하면 table.grantReadWriteData(fn); 과 같은 함수를 통해 권한을 얻을 수 있음APIGateway.LambdaRestApi()를 사용하면 API Gateway에 대한 IAM 권한을 가질 수 있음.→ serverless framework 사용시 serverless.yml 파일에 iam을 설정하던 부분을 함수로 명시 하는거였음. LoaderECS Clustuer, ECS Fargate를 이용해 클러스터 생성(규모에 상관없이 재사용가능하도록함) Monitorcdk-watchful를 활용하여 cloud watch와 연결 가능 jsii →js로 만든것을 다른언어에서 사용가능하도록 해줌 cdk에서 활용됨 프로세스Code Commit → CDK 앱과 Lambda 함수 코드는 동일한 리포지토리에 저장됨 Code Build → CdkCodeBuild 프로젝트는 CDK 앱을 synthesize하여 CloudFormation 템플릿을 생성 배포환경은 동일하게 로컬환경은 개발자 본인만을 위한것이다.클라우드9이나 CloudFormation, 도커등 동일한 환경을 제공할 수 있어야함. 점심 도시락닭강정, 새우튀김, 갈비찜?돼지고기찜? + 된장국 (나머진 안 먹어봐서 모르겠습니다) 굿즈(SWAGS) 티셔츠 머그컵 방향제 담요 보틀 디퓨저 다이어리","link":"/2019/09/26/AWS-DEVDAY-2019-%EB%A9%94%EB%AA%A8/"},{"title":"[JS]Document.ready 의 대안","text":"jQuery를 사용할 때, DOM이 로드된 후 처리를 위해 아래와 같은 구문을 많이 사용해왔습니다. 123456789$(function(){ });// or$(document).ready(function(){ }); 이와 같은 동작을 jQuery 없이 사용 할 수 없을까 찾아 보았는데, 123document.addEventListener('DOMContentLoaded', () =&gt; {}) 위와 같이 작성하면 됩니다. DOMContentLoaded는 최초로 HTML 문서가 완전히 로드 및 파싱 되었을때 발생되므로,모든 리소스(이미지, 스크립트, 스타일 시트 등)가 로드 된 후 발생하는 load 이벤트 보다는 먼저 호출됩니다. 그렇다면 왜 DOMContentLoaded 이벤트 리스너 대신 $(document).ready()를 사용했을까 알아 보았는데, CAN-I-USE-DOMContentLoaded를 확인하였더니, IE8까지는 지원을 하지 않았습니다.물론 jQuery가 아닌 대안들도 있었겠지만, 브라우저 호환성을 위해 jQuery를 써오던 입장에서는 간단하게 사용할 수 있던 방안이었으리라고 봅니다. 참고자료 MDN-DOMContentLoaded CAN-I-USE-DOMContentLoaded","link":"/2020/01/05/Document-Ready-Alternative/"},{"title":"[PHP] InvalidArgumentException : Unable to locate factory with name [default]","text":"발단Laravel Framework로 TDD를 진행중에 Unit Test를 하기 위해 artisan 콘솔을 이용하여 TaskTest 라는 이름의 테스트 클래스를 생성하였습니다. 1$ php artisan make:test TaskTest --unit 코드는 간단했습니다. 123456789101112131415161718192021&lt;?phpnamespace Tests\\Unit;use App\\Project;use Illuminate\\Foundation\\Testing\\RefreshDatabase;use PHPUnit\\Framework\\TestCase;class TaskTest extends TestCase{ use RefreshDatabase; /** * @test */ public function it_belongs_to_a_project() { $task = factory('App\\Task')-&gt;create(); $this-&gt;assertInstanceOf(Project::class, $task-&gt;project); }} 해당 테스트를 생성 후 아래와 같이 PHPUnit으로 해당 테스트를 실행하였더니 1$ ./vendor/bin/phpunit --filter it_belongs_to_a_project 아래 이미지와 같은 에러가 나왔습니다. InvalidArgumentException : Unable to locate factory with name [default] [App\\Task]과연 무엇이 문제일까 싶어 해당 모델의 migration이 제대로 안된걸까요? migrate 명령어도 실행해보았고, Controller Test에서 사용할때에는 문제가 없었지만 factory 코드도 다시 작성 해보았습니다. 구글링으로 정광섭님의 위키를 참고했을때는 factory에 클래스가 제대로 설정된게 아닌 경우라 하여,factory('App\\Task') 와 factory(Task::class) 와 factory(\\App\\Task::class) 모두 테스트 해보았는데 모두 동작을 안했고, Laracast와 StackoverFlow에서는 phpunit의 setup 메소드를 상속하여,parent::setup() 을 호출하고, factory를 호출하면 해결된다는 답변들도 확인하였으나, 제게 맞는 해결 방법은 아니였습니다. 하지만 라라캐스트 질문의 어떤 답변에서는--unit으로 생성한 테스트 클래스가 상속하는 TestCase 클래스가 \\Tests\\TestCase 가 아닌 \\PHPUnit\\Framework\\TestCase여서 발생했다는 내용이 있었습니다. 해결저도 이걸 확인하고 바로 위의 코드를 아래와 같이 변경하였습니다. 12345678910111213141516171819202122&lt;?phpnamespace Tests\\Unit;use App\\Project;use Illuminate\\Foundation\\Testing\\RefreshDatabase;- use PHPUnit\\Framework\\TestCase;+ use Tests\\TestCase;class TaskTest extends TestCase{ use RefreshDatabase; /** * @test */ public function it_belongs_to_a_project() { $task = factory('App\\Task')-&gt;create(); $this-&gt;assertInstanceOf(Project::class, $task-&gt;project); }} 네임스페이스를 확인할 생각은 전혀 하지 못했는데, 일반적인 테스트 클래스는 모두 use Tests\\TestCase; 이렇게 선언되어있었으나--unit으로 선언했을때는 use PHPUnit\\Framework\\TestCase;으로 자동 설정되어있었습니다. 아직까지 artisan에서 --unit 옵션을 사용하여 테스트 클래스를 만들었을때 namespace 변경 없이 하는 방법은 찾지 못하였는데,Illuminate\\Foundation\\Testing\\TestCase 에서 무언가 factory 메소드의 파라미터로 모델을 주입해주는 설정해주는것으로 보입니다. 참고자료 정광섭님의 위키 Laracast “Unable to locate factory with name [default]??”- amcsi","link":"/2020/01/09/Unable-to-locale-factory-with-name-default/"},{"title":"［JS］jQuery 두번째 파라미터가 뭐지?","text":"jQuery로 작성된 코드를 보는데, $(&quot;selectorA&quot;, &quot;selectorB&quot;) 와 같은 코드가 있었습니다.당연히 기존에 자주 접하던 $(&quot;selectorA, selectorB&quot;) 와 같은 코드인줄 알았으나, 예상과 다르게 동작하여 문서를 확인해 보았습니다. jQuery 문서에 따르면, A DOM Element, Document, or jQuery to use as context 가 기재되어있다. 해당 영역에는 DOM element가 올 수 있는데 Selector Context를 확인해보면 selector context is implemented with the .find() method, so $( “span”, this ) is equivalent to $( this ).find( “span” ). 이와 같이 말하고 있습니다. jQuery .find() vs. context selector 해당 링크에서 퍼포먼스 확인을 해보면아래 이미지와 같이 context selector를 사용 하는 것 보다, 아주 조금이나마 더 빠릅니다.","link":"/2019/12/13/What-Is-jQuery-Second-Parameter/"},{"title":"［Notion］Notion과 Github Actions로 가계부 자동화 하기 - (1)","text":"시작하기에 앞서 해당 포스트는 ［Notion］Notion과 Zapier로 가계부 자동화 하기의 후속편입니다. 해당 포스트에서는 토스의 소비 서비스를 기반으로 Google Drive, Naver OCR, Github Actions, Notion API 를 사용합니다. 왜 Github Actions로 변경하게 되었을까? 기존에 가계부 자동화로 맨처음 고려 했던 방식은 Github Actions + Naver OCR을 이용한 가계부 자동화 방식이였습니다. 하지만 가계부를 쓰기 위해 코딩을 하는게 맞나? 싶은 생각에 솔루션들을 사용하기로 하였고플랫폼들을 이용한 기존에 구성한 스택은 다음과 같습니다. Google Drive : 캡쳐 이미지 저장소 Zapier : Google Drive 이미지 업로드시 정해진 프로세스를 진행하도록 하기 위한 플랫폼 Nanonets : 이미지에 OCR을 동작시켜 이미지에서 필요한 영역의 데이터를 뽑아낼 수 있음. 해당 스택으로 구성하였을때 무엇보다 좋았던 점은 코드를 한줄도 작성하지 않아도 가능하기 때문에,개발자가 아니더라도 충분히 따라서 할 수 있다 였습니다. 하지만 해당 스택으로 구성하였을때 개발자로써 한계가 더 쉽게 다가왔고, 제가 느꼈던 문제점은 다음과 같습니다. Zapier (자동화 플랫폼) 무료 플랜사용시에는 월 100회 실행 무료이며, 1개의 자동화(zap)당 1개의 작업만 설정이 가능합니다.저의 경우 아래 두가지 자동화로 나뉘게 되어, 하나의 항목 업로드시 무료 횟수가 2회씩 차감이 됩니다. 구글 드라이브에 이미지가 업로드 되면 OCR 분석을 실행 OCR 분석이 완료되면 Notion DB에 저장. 자동화는 15분 간격으로 실행되기때문에, 위와 같이 2개가 처리되면 최악의 경우 30분이 걸리게 됩니다. Notion의 Database에 항목(Property)이 많으면 일부만 노출되는 문제가 있어 원하는대로 매핑을 할 수 없습니다. 데이터 포맷 변환 또한 Zap을 새로 추가해야해서 비용이 발생함. 날짜 포맷이 토스에서는 2022년 1월 1일 14:40 이지만, Notion에는 ISO8601의 날짜 포맷인 2022/01/01 이 아니면 데이터가 오늘 날짜로 입력됩니다. Nanonets (이미지 글자 인식 OCR 플랫폼) 해외 플랫폼의 한계로 한글 인식률이 부족합니다. 한글의 경우 글자사이에 띄어쓰기가 계속 추가되는 문제도 있습니다. 무료 플랜에서는 월 100회 이미지 인식 제한이 있습니다. 모델학습을 여러번 해보았지만 영역이 잘못 잡혀서 값이 누락되는 케이스가 있습니다. 날짜 인식이 잘못되어 데이터가 잘못 들어감. 위와 같은 한계로 초기에 고려한 방식을 사용한다면 직접 개발해야 하는 문제를 뺀다면,훨씬 높은 자유도를 얻어 원하는대로 설정할 수 있고각 서비스의 API의 무료 한도도 Naver OCR의 API 한도인 300회만 고려하면 되기 때문에한달의 가계부를 쓰기에 충분할것이라 판단하였습니다. 서비스 구성 이와 같이 구성하여 작성하였습니다. 각 영역에 대한 상세한 내용은 다음편에서 작성 예정입니다","link":"/2022/01/02/account-book-with-notion-and-github-actions/"},{"title":"［Notion］Notion과 Zapier로 가계부 자동화 하기","text":"왜 가계부를 쓰나요?저는 예전부터 가계부를 써서 돈의 사용처를 기록하고 카테고리화 해서 어디에 돈을 많이 쓰고 있는지 흐름을 보는것을 좋아했습니다. 가계부를 Notion으로 쓰는 이유첫 가계부는 편한 가계부라는 어플을 사용했고, 그 이후 핀테크쪽 서비스가 커지면서 뱅크샐러드를 사용했었습니다.뱅크 샐러드는 느리긴 했지만 제가 필요하다 생각했던 모든 것들을 제공 해주고 있었습니다.토스에서 소비 라는 탭으로 연동된 계좌들의 소비 내역을 보여주는 기능도 출시하여 엄청나게 빠른 속도로 스크래핑이 되었습니다. 문제는 결혼 이후로는 제 지출 내역만 관리하는게 아니라 아내의 지출 내역도 관리가 필요했습니다. 저는 위에 가계부를 쓰는 이유가 돈의 흐름을 보고 싶은 것이라 통계들을 볼 수 없는 종이 가계부는 쓰고 싶지 않았고,언제든 접근할 수 있고 두사람이 같이 온라인으로 관리 할 수 있는 가계부가 필요했습니다.개발자 답게 직접 서비스를 만드는것도 고려했으나 주 목적인 가계부를 쓰기 위해 서버를 관리하고, 비용을 내고 해야한다는것이 점점 야크 털 깎기가 되어 가는 느낌이였습니다.이러한 이유로 새로운 방법을 찾아보기 시작합니다. 앱을 알아봤을때 iOS 에는 Buboo 가계부라는 어플이 있었는데,웬만한 공유 가계부 서비스들이 서비스 중단된 케이스가 많아서, 모든 데이터를 작은 서비스에 의존할 수 없겠다는 판단을 했습니다. 주위에 자문을 구했을때, 엑셀 템플릿을 구하여 엑셀 또는 구글 스프레드 시트를 이용하여 가계부를 쓰는 기혼자 분들이 많이 있었습니다.그분들을 따라 블로그들을 돌아다니며 템플릿을 수집하고 가장 제가 쓰기 편한것을 3개월정도 사용했습니다. 여기서도 발견된 문제점은 제가 엑셀을 잘 사용하지 않다보니, 만들어진 템플릿을 커스텀하는데 드는 리소스가 너무 컸습니다.여기서도 엑셀을 배우는것보단 제가 원래 많이 사용하는 노션으로 가계부를 옮기게 됩니다.직접 만들 수도 있었지만 템플릿은 노션 강좌 유튜브에서 구해서 사용했습니다. 자동화를 하게 된 계기 생활비 통장 실제 결제에 사용하는 카드 N개 위와 같이 나누어 쓰고 사용한 금액을 생활비 통장에서 차감하는 방식으로 사용합니다.처음에는 노션에만 가계부를 작성을 했는데 누락되는 케이스가 있어서 보조수단으로 토스 메모 기능을 활용했습니다. 카드로 결제를 하면 어떤것을 결제했는지(PG결제 같이 사업자명이 안 나오거나 실제 매장명과 거래처명이 다른 경우가 많음) 토스 소비 탭에서 메모를 작성을 하고,토스에 있는 내역을 기반으로 노션에 가계부를 작성을 하고 있었습니다. 이렇게 하다보니 똑같은 일을 결제 내역당 두번씩 하고 있었습니다.하루에 1~2건이라면 문제가 없지만 하루에 결제내역이 많으면 10건까지도 있는 경우가 있다보니 제가 해야 할 반복 작업은 N(결제건수)*2가 되어버립니다. 이를 어떻게 해결하면 좋을까 고민하다보니 제가 하는 작업은 아래와 같습니다. 토스 소비탭에서 결제 내역에 메모를 추가한다. 노션 가계부에 1의 내용을 바탕으로 저장한다. 생활비 통장에서 금액을 차감하고 결제수단을 업데이트 한다.(월별 생활비 추가) 3번 동작은 송금 기능도 들어가기때문에 자동화가 애매하지만, 2번 동작은 1번 동작에 상당히 의존적이였습니다.그렇다면 1번이 다 되었을 때, 해당 내용을 읽어들여 최근에 나온 Notion API를 사용하면 되지 않을까? 라고 생각하게 됩니다. 어떻게 연결 하였을까Zapier라는 서비스에서는 구글드라이브의 이벤트와 Nanonets OCR 이라는 서비스를 연결 할 수 있었습니다. Google Drive to Nanonets 설정Nanonet에서 Modeling이라고 말하는 영역별 라벨링을 아래와 같이 해줍니다. 아쉽게도 해외 서비스이다보니 한국어를 인식할때에는 메모를 남겨보세요 와 같은 문구는 메모 를 남겨 보세요 와 같이 띄어쓰기가 잘못 들어 가는 경우가 많습니다.계속해서 모델을 학습 시키면 제대로 인식 시킬거라는 기대감과 함께 문구를 수정하여 줬습니다. 그 이후 Zapier에서는 아래와 같이 설정하였습니다. 가장 헷갈렸던 부분은 Nanonets OCR 설정에서 Google Drive의 파일의 output중 어떤 값을 사용할지 였는데, 기본값인 File을 사용하면 읽기가 가능했습니다. TIPNanonets to Notion 설정Nanonets 자체에서 OCR 처리 이후 Database(Mysql, MsSql, MariaDB 등)에 데이터를 넣을 수 있도록 하거나 Webhooks를 통해 처리할 수 있도록 자체적인 Integration을 제공하고 있습니다. 하지만 제가 필요한 동작은 notion에 값을 매핑하여 넣는것이기 때문에 zapier를 사용하였습니다. Zapier에서 formatter Zap을 이용하여 포맷을 설정할 수 있으면 가장 좋겠지만, 이것 또한 비용이 되어 직접 처리하도록 하였습니다. 필요한 값중 매핑이 정상적으로 되지 않을 수 있으므로, Content 값에 필요한 값이 입력되도록 매핑하였습니다. 마무리하며최대한 코딩을 하지 않고 인프라도 구성하지 않으며 사용하고 싶었습니다. 하지만 제가 알아본 서비스들은 OCR을 지원하는 서비스가 거의 없었으며 플랜도 아래와 같았습니다. Zapier 100회/Multi-Action 지원 안함 Automate 300회/Multi-Action 지원 안함 IFTTT Multi-Action 지원 안함 위와 같은 이유로 OCR을 지원하고 있던 Zapier를 선택하여 nanonets를 연동하였으나, nanonets의 한글 인식 미흡한점은 감안할 수 있었으나Zapier/Nanonets의 API Limit으로 일주일만에 절반 이상을 사용하여 해당 방식으로는 어려울것 같아, NCloud OCR이 300회를 제공하고 있어 해당 방식을 연동할 계획을 가지고 있습니다. 최근들어 각종 금융사 및 핀테크 서비스에서 마이데이터 서비스를 이용하여 자산 관리를 제공하고 있는데, 해당 서비스에서 관리한 데이터를 API로 받아 볼 수 있는날이 언젠가 오길 고대합니다.","link":"/2021/12/29/acoount-book-with-notion-and-zapier/"},{"title":"［Algorithm］이진탐색 알고리즘(Binary Search Algorithm)","text":"이진탐색 정의 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 것. 오름차순으로 정렬된 리스트일 경우에만 사용할 수 있다는 단점이 있지만, 절반씩 줄여가며 탐색하기 때문에 매우 빠르다. 구현 해당 배열에서 가운데 값을 찾고, 그 값과 비교하여 해당 인덱스에서의 배열의 값이 찾는 값 보다 클때는 앞쪽에서 찾고, 작을때는 뒤쪽에서 찾으면 된다. 코드 123456789101112131415161718192021// 해당 인덱스를 출력해주는 알고리즘 입니다.binarSearch = (data, value) =&gt; { let start = data[0], end = data.slice(-1)[0], index = 0, last = data.length-1 if (value &lt; start || value &gt; end) return -1; while (index &lt;= last) { let center = parseInt((index+last) / 2) if (data[center] === value) return center; else if(data[center] &gt; value) // 해당 인덱스의 배열값이 더 크기때문에 최대 인덱스를 줄인다. last = center - 1 else // 해당 인덱스의 배열값이 더 작기때문에 최소 인덱스를 늘린다. index = center + 1 }}// 호출binarSearch([1,5,7,11,25],25) // 4binarSearch([1,5,7,11,14,16,18,25],18) // 6 참고자료 위키백과 나무위키","link":"/2018/04/19/binary-search/"},{"title":"윈도우 컴포저 패키지 설치시 오류 처리 방법","text":"Your requirements could not be resolved to an installable set of packages.1234567Your requirements could not be resolved to an installable set of packages. Problem 1 - laravel/horizon v4.2.1 requires ext-pcntl * -&gt; the requested PHP extension pcntl is missing from your system. - laravel/horizon v4.2.0 requires ext-pcntl * -&gt; the requested PHP extension pcntl is missing from your system. - laravel/horizon 4.x-dev requires ext-pcntl * -&gt; the requested PHP extension pcntl is missing from your system. - Installation request for laravel/horizon ^4.2 -&gt; satisfiable by laravel/horizon[4.x-dev, v4.2.0, v4.2.1]. Laravel Horizon을 windows에서 설치하려 할 때 위와 같은 오류가 발생하였습니다. 해결방안pcntl은 윈도우에서 지원이 되지 않으므로 Docker 또는 Vargrant와 같은 가상환경을 사용해야 합니다.Link 또는 아래와 같이 실행하여 설치를 완료 할 수 있습니다. 1composer require laravel/horizon --ignore-platform-reqs --ignore-platform-reqs 옵션의 설명은해당 링크에서 확인할 수 있습니다. Link 1ignore php, hhvm, lib-* and ext-* requirements and force the installation even if the local machine does not fulfill these. See also the platform config option. 패키지를 설치하는데 필요한 조건을 충족하지 못하더라도 무시하고 설치를 실행하는 옵션입니다. 필요 조건을 모두 충족하지 않은 경우이므로 정상동작에 실패 할 수 있습니다.","link":"/2020/04/14/composer-error-on-windows/"},{"title":"［PHP］삼항 연산자","text":"삼항연산자(?:)는 조건식 ? 참일때 실행할로직 : 거짓일때 실행할 로직; 과 같이쓴다. (if-else를 짧게 줄인것) a 변수값이 있는지 검사한후 값이 있으면 foo값을 반환, 없으면 bar라는 값을 반환 ex) 12345&lt;?php$a = 'foo';$b = $a ?: 'bar';echo $b; // foo?&gt;","link":"/2017/09/01/conditional-ternary-operator/"},{"title":"Github Actions를 이용하여 Hexo 블로그 배포하기","text":"기존의 Travis-CI를 이용하여 Hexo 블로그를 배포하기 위해, ChangJoo Park님의 포스팅인 Travis CI를 이용한 Github Pages + Hexo 블로그 자동 배포하기를 참고하여 아래와 같은 YAML 파일을 작성하여 Travis CI 서비스를 이용해서 배포하였습니다. 기존의 코드 123456789101112131415161718192021# .travis.ymllanguage: node_jsnode_js: - &quot;10&quot;# Hexo source 코드는 master branch에서 작업되고 있어야합니다.branches: only: - masterbefore_install: - npm install -g hexoinstall: - npm installbefore_script: - git config --global user.name &quot;INPUT_YOUR_USER_NAME&quot; - git config --global user.email &quot;INPUT_YOUR_EMAIL&quot; - sed -i &quot;s/__GITHUB_TOKEN__/${__GITHUB_TOKEN__}/&quot; _config.yml# 블로그를 빌드 후 배포합니다.script: - hexo clean - hexo generate - hexo deploy Github에서 자체적으로 Github Actions라는 기능을 베타로 제공중이여서 신청을 해두었고, 어제 승인되어 repo에 아래 이미지와 같은 탭이 생겼습니다.🎉 해당 기능을 이용해 보기 위해 travis.yml 파일을 Github Actions에 맞게 아래와 같이 바꾸어보았습니다. 변경사항 1234567891011121314151617181920212223242526272829303132333435363738394041# .github/workflows/hexo-deploy.ymlname: Node CIon: push: branches: - masterjobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [12.x] steps: - uses: actions/checkout@v1 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} - name: Hexo-Cli Install run: npm i -g hexo - name : Change Environment env: GITHUB_TOKEN: &quot;INPUT_YOUR_GITHUB_ACCECSS_TOKEN&quot; run: | git config --global user.name &quot;INPUT_YOUR_USER_NAME&quot; git config --global user.email &quot;INPUT_YOUR_EMAIL&quot; sed -i &quot;s/__GITHUB_TOKEN__/${GITHUB_TOKEN}/&quot; _config.yml - name: NPM Install run: npm install - name: Hexo Clean run: hexo clean - name: Hexo Generate run: hexo g - name: Hexo Deploy run: hexo d Github Actions문서에 따르면 기존의 Secret Config 부분은 repo의 아래의 탭에서 지정이 가능합니다. 해당 Secrets를 사용시에는 사용하려는 step에서 with 키워드를 이용해 설정하거나, env 를 이용해서 아래와 같이 설정 할 수 있습니다. 123456steps:- name: Test Set Secret With with: ${{ secrets.YOUR_SECRET }}- name: Test Set Secret Env env: my_secret : ${{ secrets.YOUR_SECRET }} 사담 Github Actions는 이미 만들어진 환경을 사용 할 수도 있고, Github Repo에 있는 도커 스크립트를 이용할 수도 있는것으로 보입니다. 123456steps: - uses: actions/setup-node@74bc508 # 특정 커밋을 지정 - uses: actions/setup-node@v1.0 # 특정 릴리즈 버전 지정 - uses: actions/setup-node@master # 브랜치 지정 - uses: docker://alpine:3.8 # Docker Hub에서 제공하는 이미지와 태그 지정 - uses: ./.github/actions/my-action # 해당 repo 안에 정의된 파일 지정 또한, if 제어문도 사용이 가능하고, 쉘을 선택하여 처리한다거나 Cron-Job등이 사용가능하고 jobs.&lt;job_id&gt;.strategy.matrix를 활용하여 os와 실행환경(ex. node | php) 버전을 조합하여 빌드 테스트가 가능하다고 합니다. 123456789runs-on: ${{ matrix.os }}strategy: matrix: node: [6, 8, 10] os: [ubuntu-16.04, ubuntu-18.04]steps:- uses: actions/setup-node@v1 with: node-version: ${{ matrix.node }} 이와 같이 정의할 경우에는 3개의 노드버전과 2개의 os 버전을 조합하여 6가지의 job이 실행됩니다. 이외에도 다양한 기능을 제공하여 깃허브를 이용하고 있다면 한번쯤은 이용해봐도 좋을 서비스라고 생각합니다.","link":"/2019/08/23/deploy-hexo-blog-with-github-actions/"},{"title":"［GCP］ Nuxt.js GAE에 배포 이슈사항","text":"502 Bad Gateway배포 후 링크 접속시 502 Bad Gateway 에러가 발생하였는데 에러 로그를 보니 localhost:8080로 접근하고 있었다 검색 결과 NuxtJS의 실행 포트를 변경할 수 있는 방법이 소개 되어있었다. package.json에 다음과 같이 작성하면 된다. 123456789{ ... &quot;config&quot;: { &quot;nuxt&quot;: { &quot;host&quot;: &quot;0.0.0.0&quot;, &quot;port&quot;: &quot;8080&quot; } }} 또는 123456{ &quot;scripts&quot;: { ... &quot;start&quot;: &quot;HOST=0.0.0.0 PORT=8080 nuxt build &amp;&amp; nuxt start&quot; }} 으로 작성하여 다시 deploy 하면 정상적으로 동작한다. 참고자료 NuxtJS Github ISSUE - 334(Google Cloud Deployment) NuxtJS FAQ - host 와 port 번호를 변경하려면?","link":"/2018/07/20/deploy-nuxt-to-GAE/"},{"title":"［Docker］명령어 정리","text":"이미지 다운로드 1$ docker pull [다운로드 할 이미지명]: latest 이미지를 컨테이너로 만들때 1$ docker run -i -t --name [컨테이너명] -d [이미지명] 컨테이너상태 확인 (&quot;a&quot;옵션은 정지된 컨테이너도 보여줌) 1$ docker ps [-a] 컨테이너를 실행 1$ docker start [컨테이너명] 컨테이너에 별칭을 주기 12$ docker run -it --name &lt;별칭&gt; &lt;이미지명&gt;ex) $ docker run -it --name nginx richarvey/nginx-php-fpm 컨테이너 특정 포트 연결 12$ docker run -p &lt;로컬 포트 번호&gt;:&lt;컨테이너 포트 번호&gt; &lt;이미지명&gt;ex) $ docker run -p 8000:80 richarvey/nginx-php-fpm 컨테이너 정지 1$ docker stop [컨테이너명] bash shell로 명령실행가능하게함 1$ docker exec -it &lt;컨테이너 이름&gt; /bin/bash 컨테이너 삭제 1$ docker rm &lt;컨테이너이름&gt; 태그를 입력하지않으면 모든태그가 삭제됨 1$ docker rmi &lt;이미지 이름&gt;:&lt;태그&gt; 윈도우 드라이브 공유 12docker run -v &lt;윈도우 경로&gt;:&lt;컨테이너 경로&gt; -it &lt;컨테이너명&gt;ex) $ docker run -v /c/User/Administrator/PHP:/home/hodory -it nginx 아래와 같이 여러가지 조합도 가능하다 12docker run -it --name &lt;별칭&gt; -d -p &lt;로컬포트&gt;:&lt;컨테이너포트&gt; -v &lt;로컬경로&gt;:&lt;컨테이너경로&gt; &lt;이미지명&gt;ex) $ docker run -it --name nginx -d -p 8000:80 -v /c/User/Administrator/PHP:/home/hodory richarvey/nginx-php-fpm","link":"/2017/09/01/docker-command/"},{"title":"［Laravel］with() | has() | whereHas() 뭐가 다를까","text":"ORM도 익숙하지 않지만, Eloquent ORM은 처음 접해보면서, 쿼리빌더를 사용하는것은 ORM스럽지 못하다 느껴 최대한 ORM으로 풀고 싶었습니다 검색으로 알아보던중 Eloquent:Relations에 대해 알게되었습니다. 라라벨 공식 문서 : 관계의 존재 여부 쿼리 질의하기 예를들어 User가 여러개의 Post 를 가지고 있다면,User 클래스에 $this-&gt;hasMany('App\\Post');를 설정해 두었을 것이라는 가정하에 설명을 진행하도록 하겠습니다. with() user id name post id user_id title이와 같은 테이블 구조에서 유저가 작성한 글의 제목을 조회하려면1234$users = selectAll(&quot;select * from `user`);foreach ($users as $user) { $user['post_title'] = selectOne(&quot;select `title` from `post` where `post`.`user_id` = {$user['id']}&quot;);} 회원을 조회하고, 회원들을 순회하며 게시물을 조회하는 코드입니다.이 경우 회원이 1000명일 경우 쿼리는 1001번 실행하게 됩니다.이것을 N+1쿼리 문제 라고 합니다. 사람들에 따라 직관적이여서 선호하기도 하고,join으로 실행시 쿼리가 오래 걸리면 이와 같이 분리하여 사용하기도 합니다.또는 join으로 해결할 수 없는 상황에서도 사용합니다. 이 문제를 해결 하기 위해 1$users = selectAll(&quot;select `user`.*,`post`.`title` as post_title from `user` left join `post` on `post`.`user_id` = `user`.`id`&quot;); join으로 해결할 수 없는 경우를 제외 하고는 위와 같이 join을 사용해서 조회 할 수 있습니다. 또한 이 문제는 ORM에서 주로 발생 합니다.ORM을 사용하면 user와 post의 관계를 설정하고, 아래와 같이 사용할 수 있습니다. 123foreach (User::all() as $user) { echo $user-&gt;post-&gt;title;} 해당 코드는 123456select * from `user`; # 1, 2, 3, 4, 5, 6....select * from `post` where id = 1;select * from `post` where id = 2;select * from `post` where id = 3;select * from `post` where id = 4;... user를 조회하고, user의 수 만큼 post를 조회합니다.위의 N+1 문제와 같은 문제입니다. 이 문제를 해결 하기 위한 방안으로는 즉시 로딩(Eager Loading)이 있습니다. 123foreach (User::with('posts')-&gt;get() as $user){ echo $user-&gt;post-&gt;title;} 이와같이 with()를 사용하면 미리 선언한 관계를 사용하여 같이 가져올수있습니다.언뜻 보기엔 별 다를바 없어 보이는 코드이지만 with 메소드를 사용하면, user와 연관된 post를 미리 로드합니다. 실행되는 쿼리는 12select * from `user`; # 1, 2, 3, 4, 5, 6....select * from `post` where `id` in (1, 2, 3, 4, 5, 6, ...); 위와 같이 쿼리 2개만 실행이 되어 쿼리 실행을 최소화 할 수 있습니다. with() 메소드의 2번째 파라미터를 사용해 제한 할 수도 있습니다. 1234567foreach(User::with(['posts' =&gt; function ($query) { $query-&gt;where('title', 'like', '치킨%') }])-&gt;get() as $user) { echo $user-&gt;post-&gt;title;}; user를 조회할 때, 치킨으로 시작하는 post를 같이 미리 로드 할 수 있습니다. has()has() 메소드를 이용하면, 해당 관계에서 최소 한개를 가지고 있는 결과를 조회합니다 User::has('posts')-&gt;get();을 사용하면 post를 한개라도 작성한 회원을 조회할것입니다. 쿼리로 표현한다면, 아래와 비슷할것 같습니다. 123select *from `user` join `post` on `user`.`id` = `post`.`user_id` has 메소드는 2번째 파라미터에 operator 와 3번째 파라미터에 count를 사용할 수 있습니다. 이 파라미터를 사용하면 예로 5개 이상의 글을 작성한 회원을 찾을 수 있습니다.Eloquent를 사용하면 이와같이 작성 할 수 있습니다.User::has('posts', '&gt;=', 5)-&gt;get(); whereHas()그렇다면 whereHas()는 뭐가 다를까요? whereHas() 메소드는 두번째 파라미터로 콜백을 받아 더 복잡한 쿼리를 처리할 수 있습니다. 위와 같은 모델링에서 게시글의 제목이 치킨으로 시작하는 글을 작성한 회원을 찾는다면 아래와 같을것 입니다. 123User::whereHas('posts', function ($query) { $query-&gt;where('title', 'like', '치킨%');})-&gt;get(); 쿼리로 표현한다면 12345678910111213select *from `user` join `post` on `user`.`id` = `post`.`user_id` and `post`.`title` like '치킨%'ORselect *from `user` join `post` on `user`.`id` = `post`.`user_id`where `post`.`title` like '치킨%' 이와 같이 표현할 수 있을것 같습니다. 참고자료 Stack Overflow -&gt; Laravel - Eloquent “Has”, “With”, “WhereHas” - What do they mean? Laravel 공식 문서 -&gt; Eloquent: Relationships - 관계","link":"/2019/04/26/eloquent-orm-with-has-where-has/"},{"title":"[Git] Git Merge 또는 Git checkout 오류 해결하기","text":"문제 상황git pull origin master 또는 git checkout master 와 같이 브랜치를 변경하거나, 원격저장소에서 pull을 받을때아래와 같은 오류가 나온적 경험이 한번쯤은 있을것 입니다. 1234error: Your local changes to the following files would be overwritten by checkout: themes/icarus/layout/widget/recent_posts.ejsPlease commit your changes or stash them before you switch branches.Aborting error: Your local changes to the following files would be overwritten by merge:error: Your local changes to the following files would be overwritten by checkout: 위와 같은 오류와 함께 pull이나 checkout이 동작하지 않습니다. 처음 Git을 사용하였을때는 집과 회사를 오가면서 깃허브를 이용해서 push도 하고 pull도 하고 잘 사용하다가이런 오류가 나오면 어떻게 해야할지 모르겠고, 커밋을 해야하는것 같은데무의미한 커밋을 하고 싶지는 않아서 다른 폴더로 clone을 하고 다시 작업을 했었는데요. 해결 방법 에러 메세지를 자세히 보면 해결 방법이 나와있습니다.Please commit your changes or stash them before you merge. 그리고Please commit your changes or stash them before you switch branches. 라는 문구가 있습니다.메세지 그대로 merge 또는 switch branch 이전에 변경사항을 commit 하거나 stash 하라고 합니다. 위에서도 말했지만 저는 쓸데 없는 커밋을 하고싶지 않아 방법을 모르고 새 프로젝트를 실행했지만이때는 git stash 명령어를 사용하면 됩니다. stash는 간단하게 버전관리 되는 대상들을 잠시동안 임시저장 해두는 방법이라고 말할 수 있습니다. 그래서 어떻게 하라는건가요? 위와 같은 상황에서는 아래와 같이 사용하면 됩니다. 123456# 현재 Staging 영역에 있는 파일의 변경사항을 스택에 넣어둡니다. $ git stash# 아래 명령어와 같이 원격 저장소의 master에서 pull을 하거나, git checkout master와 같이 브랜치를 바꿀 수 있습니다. $ git pull origin master# stash 명령어로 스택에 넣어둔 변경 사항을 적용하고, 스택에서 제거하여줍니다.$ git stash pop 간단하게 한줄로 표현하면 git stash &amp;&amp; git pull origin master &amp;&amp; git stash pop 와 같이 사용할 수 있습니다. 참고자료git stash에 대한 자세한 사용법은 해당 링크에서 확인할 수 있습니다.","link":"/2020/02/18/error-Your-local-changes-would-be-overwritten-by-merge/"},{"title":"［JS］ ES5와 ES6 뭐가 다를까?","text":"ES5와 ES6를 비교 할겸ES6를 사용할때 자주 쓰이는 부분만 정리해보았습니다. Const Variables let Variables Block-Scoped Function Arrow Function Default Parameter Rest Parameter Spread Operator Template Literals Ehhanced Object Properties Property Shorthand Computed Property Names Method Properties Export / Import Class Definition Promise Promise all Const 변수Immutable varibale인 Const 변수(상수 변수)를 지원합니다.(블록-스코프 변수) 12const PI = 3.141592console.log(PI) // 3.141592 let 변수기존의 함수-스코프였던 변수와 다르게 Hoisting 없는 블록-스코프 변수를 지원합니다. 1234567891011121314151617181920212223242526272829// ES5console.log('for loop start')for(var i=0; i&lt;10; i++) { console.log('i : ' + i)}console.log('for loop end i : ' + i) // for loop end i : 10function counter() { for(var j=0; j&lt;10; j++) { console.log('j : ', j) }}counter()console.log('j : ', j) // j is not defined// ES6console.log('for loop start')for(let i=0; i&lt;10; i++) { console.log('i : ' + i)}console.log('for loop end i : ' + i) // j is not definedfunction counter() { for(let j=0; j&lt;10; j++) { console.log('j : ', j) }}counter()console.log('j : ',j) // j is not defined 또한 var 변수는 재선언,재할당이 가능하지만 let 변수는 재선언이 불가능합니다 (const 변수는 immutable variable이므로 재할당도 불가능) 1234567891011121314var a = 'foo'var a = 'bar'// hoisting으로 ReferenceError가 나지않는다.b = 'foo'var blet c = 'foo'let c = 'bar' // Uncaught SyntaxError: Identifier 'c' has already been declaredc = 'bar' // &quot;bar&quot;const d = 'foo'const d = 'bar' // Uncaught SyntaxError: Identifier 'd' has already been declaredd = 'bar' // Uncaught TypeError: Assignment to constant variable. Block-Scoped 함수블록-스코프 함수 정의 방식 개선 1234567891011121314151617181920// ES6{ function foo () { return 1 } console.log(foo()) // 1 { function foo() { return 2 } console.log(foo()) // 2 } console.log(foo()) // 1}// ES5(function () { var foo = function () { return 1;} foo() === 1; (function () { var foo = function () { return 2; } foo() === 2; })(); foo() === 1;})(); Arrow Functionfunction과 return을 묶어 화살표 함수로 변형 가능합니다 12345678910111213// ES6nums = evens.map((v,i) =&gt; v+i)this.nums.forEach((v) =&gt; { if(v % 2 === 0) this.evens.push(v)})// ES5nums = evens.map(function (v, i) { return v+i; });var self = this;this.nums.forEach(function (v) { if(v % 2 === 0) self.evens.push(v);}); 디폴트 파라미터타 언어에서 사용 할 수 있었던 디폴트 파라미터가 지원됩니다. 123456789101112131415// ES6function foo (x, y=2, z=3) { return x + y + z}foo(1) // 6// ES5function foo (x, y, z) { if(y === undefined) y = 2; if(z === undefined) z = 3; return x + y + z;};foo(1); // 6 Rest Parameter지정되지 않은 매개변수 집합을 하나의 변수에 담을 수 있습니다. 123456789101112// ES6function foo (x, y, ...a) { return (x * y) + a.length}foo(1, 2, &quot;baz&quot;, true , 3, [2]) // 6// ES5function foo (x,y) { var a = Array.prototype.slice.call(arguments, 2); return (x * y) + a.length;};foo(1, 2, &quot;baz&quot;, true , 3, [2]); // 6 Spread Operator (전개연산자)2개 이상의 인수나 2개이상의 요소 또는 2개이상의 변수가 해당되는 곳에 확장 될 수 있도록 합니다. 12345678910111213function myFunc(x, y, z){}// ES6let params = [ &quot;Foo&quot;, true, 2 ]let others = [ 1, 2, ...params ] // [ 1, 2, &quot;Foo&quot; ,true, 2 ]let str = &quot;Bar&quot;let chars = [ ...str ] // [ &quot;B&quot;, &quot;a&quot;, &quot;r&quot;]myFunc(1, 2, ...params);// ES5var params = [ &quot;Foo&quot;, true, 2 ];var others = [ 1, 2 ].concat(params); // [ 1, 2, &quot;Foo&quot; ,true, 2 ]var str = &quot;Bar&quot;;var chars = str.split(&quot;&quot;); // [ &quot;B&quot;, &quot;a&quot;, &quot;r&quot;]myFunc.apply(null, [1, 2].concat(params)); Template Literals문자열 다중 행 처리와 보간문자 처리를 할 수 있습니다. 12345678910111213141516// ES6let user = { name : &quot;Foo&quot; }let info = { id: &quot;bar&quot;, email: &quot;Foo@example.com&quot;}let userInfo = `Hello ${user.name}.Your ID is ${info.id} and email is ${info.email}.`// Hello Foo.// Your ID is bar// and email is Foo@example.com// ES5var user = { name : &quot;Foo&quot; }var info = { id: &quot;bar&quot;, email: &quot;Foo@example.com&quot;}var userInfo = &quot;Hello &quot; + user.name + &quot;.\\n&quot;+&quot;Your ID is &quot; + info.id + &quot;\\n&quot;&quot;and email is &quot;+info.email+&quot;.&quot;; Enhanced Object PropertiesProperty Shorthand공통 객체 속성 정의를 간결하게 할 수 있습니다. 1234567// ES6let x = 0, y = 0obj = {x, y}// ES5var x = 0, y = 0;obj = {x: x , y: y}; Computed Property NamesObject 프로퍼티 정의에 계산된 이름을 지원합니다 1234567891011// ES6let obj = { foo: &quot;Bar&quot;, [&quot;Baz&quot; + myFunc() ]: 42}// ES5var obj = { foo: &quot;Bar&quot;};obj[&quot;Baz&quot; + myFunc() ] = 42; Method Properties일반적인 함수와 제너레이터 함수의 Object 프로퍼티 정의에 메소드를 표기할 수 있도록 지원합니다. 12345678910111213// ES6obj = { foo (a, b) {}, bar (x ,y) {}, *baz (x, y) {}}// ES5obj = { foo: function (a, b) {}, bar : function (x, y) {}, // baz : es5에서는 대체할 것이 없습니다.} Export / Import값을 export/import로 모듈에 가져오거나 모듈로 내보낼 수 있습니다. 123456789101112131415161718192021222324// ES6// lib/math.jsexport function sum (x ,y) { return x + y }export var pi = 3.141592// Foo.jsimport * as math from &quot;lib/math&quot;console.log(&quot;2pi = &quot; + math.sum(math.pi, math.pi))// Bar.jsimport { sum, pi } from &quot;lib/math&quot;console.log(&quot;2pi = &quot; + sum(pi,pi))//ES5// lib/math.jsLibMath = {};LibMath.sum = function (x ,y) { return x + y };LibMath.pi = 3.141592;// Foo.jsvar math = LibMath;console.log(&quot;2pi = &quot; + math.sum(math.pi, math.pi));// Bar.jsvar sum = LibMath.sum, pi = LibMath.pi;console.log(&quot;2pi = &quot; + sum(pi,pi)); Class Definition클래스를 지원합니다 (이외에도 상속, 오버로딩, 정적 클래스멤버, Getter/Setter를 지원합니다.) 123456789101112131415161718192021// ES6class Car { constuctor (id, x ,y) { this.id = id this.move(x,y) } move (x, y) { this.x = x this.y = y }}// ES5var Car = function (id, x ,y) { this.id = id; this.move(x, y);};Car.prototype.move = function (x, y) { this.x = x; this.y = y;} Promise비동기 처리 이후 동작을 순차적,또는 병렬로 진행하기 위해 사용하는 클래스. 기존 Callback Hell에서 벗어날 수 있도록 도와줍니다(잘 구현 했을 경우….) 1234567891011121314151617181920212223242526// ES6let _promise = () =&gt; { return new Promise((resolve,reject) =&gt; { if(success){ resolve(value) // success } else { reject(reason) // fail } })}_promise() .then( (res) =&gt; { //success일때 처리 console.log(res) }, (err) =&gt; { //reject 일때 처리 console.error(err) } )_promise() .then(...) .catch((err) =&gt; { console.error(err) }) 여러개의 프로미스가 모두 완료 될때 실행하려면요? Promise-all 을 이용합니다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657let _promise1 = new Promise((resolve,reject) =&gt; { if(success){ resolve(value) // success } else { reject(reason) // fail } })let _promise2 = new Promise((resolve,reject) =&gt; { if(success){ resolve(value) // success } else { reject(reason) // fail } })Promise.all([_promise1, _promise2]).then( (res) =&gt; { // resolve 된 결과 처리 console.log(res) }, (err) =&gt; { // reject 된 결과 처리 console.log(err) })// ORlet _promise1 = () =&gt; { return new Promise((resolve,reject) =&gt; { if(success){ resolve(value) // success } else { reject(reason) // fail } })}let _promise2 = () =&gt; { return new Promise((resolve,reject) =&gt; { if(success){ resolve(value) // success } else { reject(reason) // fail } })}Promise.all([_promise1(), _promise2()]).then( (res) =&gt; { // resolve 된 결과 처리 console.log(res) }, (err) =&gt; { // reject 된 결과 처리 console.log(err) }) 참고자료 MDN ES-6 기능 소개 Promise ES6 Promises(1) - the API 도대체 Promise는 어떻게 쓰는거야?","link":"/2018/04/16/es5-vs-es6/"},{"title":"[Git] 원격 브랜치명으로 새로운 브랜치 생성하기","text":"주로 PHPStorm 같은 IDE 나 VSCode 같은 Extension이 잘 되어 있는 에디터를 사용하고,그 이전에는 Source Tree / Git Kraken / Fork 등 Git Client 를 사용하여 Git을 사용하기 때문에,아직 CLI로 Git을 유연하게 다루지 못해 git-scm 문서의 내용을 정리 합니다. 명령어 정리원격 브랜치명과 같은 이름으로 생성할 때1$ git checkout --track origin/master 해당 브랜치명이 리모트에만 있고, 로컬에는 없을 때 이를 축약하여 아래와 같이 실행할 수 있다. 1$ git checkout master 원격 브랜치명과 다른 이름으로 생성할 때가장 많이 쓰이는 경우인데, 원격 Git 서버의 master 브랜치를 기준으로 새로운 브랜치를 만들고, 체크아웃 할 때 사용합니다. 1$ git checkout -b my-new-branch-name origin/master 위와 같이 실행하면 origin/master를 트래킹 하게 되는데,다른 브랜치를 추적하기 위해 아래와 같이 실행할 수 있습니다. 1$ git branch -u origin/feature-test 참고자료Git 브랜치 - 리모트 브랜치","link":"/2020/03/09/git-new-branch-from-remote-branch/"},{"title":"［Hexo］블로그 주소를 바꾸었어요!","text":"이번에도 Gracefullight님의 제안으로, dev 도메인을 구매하기로 하였습니다. 기존의 아이디를 사용하여 khzero.dev를 쓸까 하다가, 이왕 구매하는거 깃허브 아이디도 바꾸고, 도메인도 맞춰서 사자! 라고 생각을 했었습니다…그때 멈췄어야 했는데요… 해당 포스팅을 참조하여 작업을 진행하기 시작했습니다. 1. 도메인 구매 및 연결닉네임을 찾다가 Hodory로 변경하고, hodory.dev 도메인을 구매했습니다. Github Pages로 관리되던 khzero.github.io Repository 이름을 hodory.github.io로 변경하였죠 지난번 TravisCI로 블로그 자동 배포시 겪은 문제에서 TravisCI로 배포 환경을 구축 했기 때문에, 위의 이미지와 같이 깃허브에서 TravisCI 서비스연결도 다시하고, Hexo config.yml도 모두 수정하였습니다. 기존의 도메인 URL도 모두 변경하여 블로그를 배포했습니다. 2. 기존 블로그는 어떻게 해요???생각하여보니 현재 어썸데브블로그에 khzero.github.io 주소의 포스팅들이 공개 되어 있는데, 깃허브 아이디를 변경하면서 도메인 연결이 끊겨, 404 페이지를 노출하고 있었습니다. 급하게 khzero로 계정을 새로 만든 후, khzero.github.io Repository를 생성하고 기존 포스트를 배포하여 404로 노출되는것은 막았습니다. 3. 서브도메인으로 바꿀래요!원래는 도메인을 hodory.dev로 쓰려 했지만, 서브 도메인으로 블로그임을 명시하고 싶어,다시 hodory 계정의 hodory.github.io Rpository를 blog.hodory.dev로 CNAME을 설정하고 아래와 같이 설정하였습니다.(※주의 : CNAME을 배포하면 아래의 설정이 초기화 되니 주의하시기 바랍니다.※) 배포를 하였더니 깃허브로부터 아래와 같은 메일이 왔었습니다. A 레코드에 blog.hodory.dev가 설정되어 있어서인데,CNAME으로 변경하기위해 구글 도메인 DNS 설정에서 아래와 같이 변경했습니다. 설정을 모두 마친 뒤, 지인들에게 자랑을 했는데 블로그가 아래와 같은 오류로 나오지 않는다했습니다. 웹사이트에서 HSTS를 사용하므로 지금은 blog.hodory.dev에 방문할 수 없습니다. 네트워크 오류와 공격은 대체로 일시적인 문제이기 때문에 나중에 이 페이지가 정상적으로 작동할 수 있습니다. TTL 문제일 수 있어 최대 1H까지 리졸브가 안될 수 있어요 라는 설명을 듣고 TTL을 1m 으로변경하였습니다 1분정도 지난 후 확인해보니 정상적으로 동작했습니다! 또 중간에 배포를 하다가 이와 같이 되는 노출되는 경우가 있었는데 위에 기재하였던 CNAME이 수정되면서, Enforce HTTPS 가 체크 해제되어 있었습니다.이 부분을 수정하니 정상적으로 노출이 되었습니다. 4. 기존 블로그를 연결하자!블로그 주소가 변경되면서 해야할 것은 oneSignal의 URL 변경 Analytics 수정 구글 애드센스 확인 Search Console 연결 페이스북 픽셀 주소변경 네이버 웹마스터도구 사이트 추가 6가지였습니다. 대부분 URL 변경만 한다거나, 추가하는 방식으로 간단하게 수정 되었으나, 4번에서 문제가 생겼습니다. 현재 Search Console의 구버전에서만 가능한 주소 변경 툴인데, 아래 이미지에 표시된 2번의 301 리디렉션 정상동작 여부에서 막혔습니ㅏㄷ. Github Pages 는 정적페이지이다보니 301로 리디렉션이 불가능합니다. 혹시나 하는 마음에 jekyll-redirect-from 패키지도 확인 해보았으나, meta 태그와 script를 이용해 페이지를 이동시키는데, 구글봇이 해당 페이지를 읽을때 HTTP 코드가 200으로 나와서 301 리디렉션이 되지 않았습니다. 어쩔 수 없이 hexo-theme-redirect 테마를 이용하여, meta 리디렉션만 설정하고 Search Console은 커뮤니티에 문의를 남기고 우선 재생성하기로 하여 모든 마이그레이션을 마무리지었습니다. 혹시나 Search Console 주소변경에 대한 다른 방법을 알고 계시다면 공유 부탁 드리겠습니다.","link":"/2019/06/09/github-pages-blog-migration/"},{"title":"Hexo Netlify CMS 연결하기","text":"Netlify CMS 블로그 플랫폼에 의존적이지 않고, 개발자st 블로그를 운영하고자 2017년부터 hexo를 이용해 블로그를 운영하고 있습니다. 마크 다운과 파일시스템을 이용하여 블로그 포스트를 작성하고, git을 이용하여 버전 관리를 하는것은 개발자로서 꽤나 매력적이었습니다. 하지만 랩탑을 항상 소지하고 있지 않다면,다양한 환경에서 블로그를 작성하기 위해 nodejs를 설치하고, hexo-cli 를 설치하는것은 언제나 부담스러운 일입니다. 제 블로그는 Github Actions 를 이용하여 포스팅만 작성하면 자동으로 빌드하여 배포가 되지만,또 다른 문제점은 포스팅에 이미지가 들어가게 될 경우 작업의 복잡도가 올라가게 됩니다. 위와 같은 이유로 hexo를 온라인에서도 작성할 방법을 고민하고 검색하였고, netlify-cms 라는 서비스를 알게 되어 적용하고자 했습니다. 사실과 오해 작년에 해당 서비스를 처음 접하였을때는 gatsby 블로그를 알아보다가 알게 된 것이라 두가지 오해가 있었습니다. graphQL으로 포스트를 관리한다. netlify로 블로그를 호스팅 할때만 사용이 가능하다. 이번에 작업을 진행하면서 알게된 내용은 틀린 부분들이 있었습니다. graphQL으로 포스트를 관리한다. git-gateway라는 자체적인 방식을 이용하여 git repository를 저장소로 사용합니다. netlify로 블로그를 호스팅 할때만 사용이 가능하다. admin에 접근하기 위해서는 netlify를 이용해 호스팅을 해야하는것은 맞지만, 기존에 github pages로 제공하던 블로그와 별개로 다른 환경에 별도의 배포본을 이용하여 사용할 수 있다. 위와 같은 이유로 저는 기존의 깃허브 블로그(https://blog.hodory.dev)[https://blog.hodory.dev] 와netlify-cms를 이용하기 위한 https://hodory-blog.netlify.app/ 를 따로 사용하고 있습니다. 설정방법 Netlify-CMS 공식 문서 참조하여 직접 설정하는것도 똑같이 따라만 하면 동작합니다. 하지만 변경사항이 생긴다면 블로그를 작성하기 위해 쓰는것인데 오히려 버전 대응에서도 리소스가 들 것이고,깔끔한 구조를 만들진 못할것 같아서 hexo-netlify-cms 해당 패키지를 사용하게 되었습니다. 위와 같이 git gateway를 설정하여 줍니다.이것만 하면 netlify app의 URL에서 어드민 로그인이 가능합니다. 임시 저장 기능 활용하기 netlify-cms가 자체적인 db를 가지고 사용할 것이라 오해했던 부분이 이 부분때문이였습니다. 해당 링크를 확인해보면 기본적으로 netlify cms는 메인 git repo에 직접 커밋을 하는 방식으로 동작합니다. 하지만 publish_mode를 editorial_workflow로 변경하여주면 draft 저장 / draft 수정 / draft publish 와 같은 단계로 나누어 처리할 수 있습니다. 설정 방법hexo 디렉토리 root의 _config.yml 파일에 아래와 같이 추가합니다. 12netlify_cms: config_file: netlify-cms.yml 같은 경로에 netlify-cms.yml 파일을 생성하고 기본값을 복사하여 넣어주고, 해당 값을 넣어주면 netlify-cms.yml 파일의 값으로 설정되게 됩니다. 1publish_mode: editorial_workflow 기존화면 상단의 Publish 버튼 클릭시 바로 발행과 이후 동작을 선택할 수 있습니다. editorial_workflow 설정 후 Save 버튼만 노출이 되는데, 설정이 잘못 된 것인줄 알았으나, Save 버튼을 누르면 아래와 같이 Draft 상태 노출과 함께 변경됩니다. Draft 상태는 repository에 `cms/all_posts/` 과 같은 브랜치가 생기며, Pull Request가 발행됩니다. Publish 버튼의 동작은 동일하지만 Status가 READY 상태일때만 버튼이 동작합니다. 주의사항(필수) 접근 권한 설정Netlify site 설정에서 Identity &gt; Registration 설정을 Invite Only 로 변경하지 않으면, 모든 사용자가 각자의 메일 인증만 하면 자신의 블로그에 글을 쓸 수 있게 됩니다. 자신의 블로그에 아무나 글을 쓰길 원하는 사람은 없기 때문에 필수로 설정하는것을 추천드립니다.","link":"/2021/12/30/hexo-netlify-cms-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0/"},{"title":"［Hexo］TravisCI로 블로그 자동 배포시 겪은 문제","text":"WARN No layout 자동 배포를 했더니 빈 파일들만 올라가요!! 한줄 요약 : theme 폴더를 레포지토리에 추가하시면됩니다. 아래의 내용은 해당 원인을 찾아가던 본인의 경험담입니다… 블로그를 직접 만드는데, 시간을 투자하는것 보다 포스팅을 하는게 더 가치 있겠다 싶어현재 블로그를 Hexo + Github Page를 이용하여 운영하고 있습니다 기존에는 배포를 Hexo-cli를 이용하여 아래와 같은 명령어를 사용하여 배포 했습니다. 123$ hexo clean$ hexo generate$ hexo deploy 쉘에서 해당 명령어를 작성하는것 또한 귀찮아져서 package.json 파일을 이용하여, 12345678/* * package.json */{ &quot;scripts&quot;: { &quot;deploy&quot;: &quot;hexo clean &amp;&amp; hexo d -g&quot; }} 해당 스크립트를 작성해서 npm deploy명령어로 배포를 하고, 소스는 별도의 레포지토리에 관리하고 있었습니다. 팀원에게는 자동 배포를 추천하였으나(https://jheloper.github.io/2019/04/hexo-ci-cd-with-codeship/),저는 설정하지 않고 있었죠… 그러던 중 Gracefullight님의 추천을 받아,이전에 보았던 ChangJoo Park님의 포스팅인 Travis CI를 이용한 Github Pages + Hexo 블로그 자동 배포하기를 참고하여작업하기로 결심했습니다. Github Access Token 발급 받기 _config.yml 파일에 deploy.repo 수정하기 배포 스크립트인 .travis.yml 작성하기 깃허브 플러그인을 이용하여 레포지토리와 연결하기 Travis CI 서비스에서 해당 프로젝트에 Environment Variables에 __GITHUB_TOKEN__ 이름의 환경변수에 액세스 토큰 추가하기 위의 다섯가지를 모두 마친 뒤,드디어 소스코드를 관리하는 Github Repository에 푸시를 하였습니다! 빌드도 성공했고, 푸시도 성공적이였습니다.확인하고자 블로그에 접속을 하였는데, 빈화면이 노출되고 있었습니다. 정적페이지이니까 우선적으로 Github Page Repo의 파일들을 확인했는데,모든 경로의 index.html 파일들이 0바이트로 변경되어 있었습니다. .gitignore 때문에 컨텐츠가 만들어지지 않는 것인가? 먼저 의심을 했고 hexo-generator가 만들어주는 db.json도 git으로 버전관리대상에 추가 후 다시 푸시하였습니다.예상대로 hexo generate 스크립트를 실행할때 생성 되기 때문에, 동일한 현상이 재현 되었습니다. 스크립트 실행시 무슨 문제가 있었다면 빌드가 중지 되었을텐데, Job log를 보았을때는 그런 문제가 없었습니다. 그리하여 기존 방식대로 우선 배포를 해둔 후, Job Log를 하나씩 자세히 들여다 보았는데 1234WARN No layout: 2019/06/05/where-is-constructor-inject/index.htmlWARN No layout: 2019/06/04/json-property-not-working/index.htmlWARN No layout: 2019/05/28/required-a-bean-of-type-that-could-not-be-found/index.html... 위와 같이 No layout 이라는 경고 메세지가 있었습니다.혹시나 하여 새로운 폴더에서 소스코드를 풀 받아 보았더니,themes 폴더에 사용중이던 테마가 빈 폴더였습니다. 항상 로컬에서만 푸시 하였기 때문에, 그걸 모르고 있었죠… 깃허브 레포지토리에는 이와같이 표시되고 클릭 불가능한 상태였습니다. 원인을 찾아본 결과, 해당 theme 마다 .git 디렉토리가 존재하고,개별적으로 버전관리가 되고 있기 때문에 저의 레포지토리를 pull을 받아도 사용할 수 없었습니다. 해당 포스팅을 보고,서브모듈을 사용해야겠다 생각했습니다. 하지만 템플릿쪽이다보니 개별적인 수정사항들도 생길 수 있기 때문에 직접 관리하는게 좋겠다 싶어서,아예 .git 폴더를 지우고, 제 레포지토리에서 버전관리 할 수 있게 하는 쪽으로 마음을 바꾸었습니다. 그런데 themes/icarus/.git 폴더를 삭제하고, git status 명령을 쳤을때,themes/icarus 디렉토리 하위 파일들이 Untracked files에 없었습니다.혹시나해서 폴더명을 바꾸니까 노출이 되었고요.. git에 캐시가 남아 있나? 싶어 git rm --cached themes/icarus 명령어를 사용하였더니정상적으로 Untracked files에 노출이 되어 버전관리에 추가한 후, 푸시를 했습니다. 그 후, 현재와 같이 정상적으로 동작하고 있습니다!! 정말 중요한 핵심은 theme 폴더를 레포지토리에 추가하시면됩니다. 였기 때문에한줄 요약으로 맨 위에 기재해두었습니다.","link":"/2019/06/06/hexo-travis-ci-with-no-contents/"},{"title":"［JS］jQuery 없이 Selectbox에서 여러개 선택된 option의 값 추출하기","text":"DOM을 다룰때 jQuery를 사용하면 매우 편리합니다. 물론 크로스 브라우저 이슈로도 제이쿼리를 많이 사용합니다. 하지만 DOM을 핸들링하기 위해서만 jQuery를 쓴다면, 편리함은 챙기겠지만 낭비 아닐까싶습니다. 저는 위와 같은 생각으로,주로 DOM 핸들링에는 jQuery 의존성을 줄이고자 순수 자바스크립트를 사용하려 노력하고 있습니다. 또한, document.querySelector와 document.querySelectorAll 를 이용한다면,jQuery에서 사용하던 복잡한 DOM Selector도 쉽게 사용할 수 있습니다. 123456&lt;select id=&quot;user&quot; name=&quot;user[]&quot; multiple=&quot;multiple&quot;&gt; &lt;option&gt;선택&lt;/option&gt; &lt;option value=&quot;foo&quot;&gt;Foo&lt;/option&gt; &lt;option value=&quot;bar&quot;&gt;Bar&lt;/option&gt; &lt;option value=&quot;baz&quot;&gt;Baz&lt;/option&gt;&lt;/select&gt; 위와 같은 Multiple SelectBox에서 여러개가 선택되었을 경우 값을 어떻게 가져올까요? jQuery를 사용하면 $(&quot;#user&quot;).val()으로 짧고 간결하게 가져올 수 있습니다. 선택된 값이 없을 경우 null이 리턴되고, 선택된 값이 있으면 배열 안에 value 값이 담깁니다. 그렇다면 순수 자바스크립트로는 어떻게 표현할까요? 123Array.from(document.querySelector(&quot;#user&quot;).selectedOptions, (item)=&gt; { return item.value;}); document.querySelector(&quot;#user&quot;).selectedOptions를 사용하면 ID 값이 user인 DOM을 찾아 selected 된 옵션을 리턴하여줍니다.해당 값에서 value 값만 뽑고싶다면 위와 같이 처리할 수 있습니다. 위와 같이 처리하면 jQuery를 사용할때와 다른점은 선택된 옵션이 없을 경우에는 []를 리턴하여 줍니다.","link":"/2019/05/12/how-to-get-multiple-selected-options-with-vanillajs/"},{"title":"［Hexo］ 명령어 정리","text":"Hexo 명령어 정리 # 초안 생성명령어 1$ hexo new draft [파일명] 예제 1$ hexo new draft hello-world # 초안을 포스트로 옮기기(Draft to Post)명령어 1$ hexo publish [파일명] 예제 1$ hexo publish hello-world # 포스트 생성명령어 1$ hexo new [파일명] 예제 1$ hexo new hello-world # 배포하기12$ hexo clean // clean을 하지 않으면 deploy를 해도 페이지가 업데이트 되지 않는 경우가 발생한다$ hexo deploy --generate # 기타사항 카테고리와 태그와 같은 설정은 어떻게 설정하나요 ? 포스트파일의 Front-matter에 아래와 같이 작성하시면 됩니다. 123456789---title: PHP 0001과 같이 번호 지정 하기tags: - Hexo - HelloWorldcategories: - Hexodate: 2017-08-31 12:00:00--- 썸네일을 등록하고 싶어요 위의 포스트 Front-matter에 아래 사항을 추가하시면됩니다 아래에서 지정한 images 폴더의 위치는 source 폴더의 하위경로 입니다. 1thumbnail: /images/logo.jpg","link":"/2017/08/31/how-to-use-hexo/"},{"title":"［JS］Object literal 보다 JSON.parse()가 더 빠르다","text":"서론 웹에서 몇 kb 크기의 객체를 초기에 렌더링 하는것은 생각보다 많습니다. 이 javascript 객체가 로드될때까지 클라이언트는 빈 화면을 보게 될 수 있습니다. 이러한 문제를 해결하기 위해, 서버사이드 렌더링을 활용 하는 방법도 있겠지만다른 방법은 없을까요? Chrome Dev Summit에서는 객체를 JSON으로 직렬화 하고, 문자열 리터럴로 변환해 Javscript 객체에 전달하는 것이 성능 향상에 도움이 된다고 이야기합니다. 무슨 소리일까? 아래의 두 코드는 동일한 객체를 생성하지만,Javascript 엔진의 경우, JSON 예제를 스캔하고, 파싱만 하기 때문에 빠르다고합니다. Javascript 파서에게 해당 코드는 여러개의 객체 리터럴을 받는 코드이냐, 많은 양의 데이터가 담긴 문자열 단일 리터럴이냐로 구분됩니다. 해당 예제에서의 객체의 값은 숫자이지만, 자기 자신의 속성과 값을 가진 Object 또는 배열이거나, 더 많은 값을 가진 무엇이든 될 수 있기 때문입니다. 이렇기 때문에 자바스크립트 파서는 단지 올바르게 토큰화 하기위해 JSON.parse에 비해 더 많이 동작 해야 합니다. 또 다른 이유로는 자바스크립트 객체 리터럴은 그 값이 객체문자열이라는것을 미리 알지 못하기때문입니다. JSON.parse로 파싱할때에는 간단하게 중괄호 이후에 Object로 시작할지, 아니면 잘못된 JSON 형식인지라는 두가지 옵션에만 중점을 둡니다. 반면 객체 리터럴은 위의 이미지와 같이 Javscript Object는 중괄호 뒤의 값이 무엇인지를 아직까지는 알 수 없고 이렇게 되었을때는 첫번째 라인에 선언된 x의 값을 바인딩 한 객체 리터럴을 생성하는것을 알 수 있다. 하지만 이와 같이 선언 되었을 경우 두번째 라인의 코드에서 첫번째 라인의 x는 전혀 참조되지않습니다. 이와 같이, 이러한 문맥 의존 문법으로 인해, Javascript 엔진에서의 파싱이 까다롭습니다. 문자열을 JSON 파싱하는것은 이러한 문제가 없어, 구문 분석이 훨씬 간단해져서 빠를 수 있는것 입니다. 실제로 얼마나 빠른건데? 캐시가 없는 콜드로드 상태에서 8MB에 가까운 페이로드를 기준으로 파싱하였을때,v8과 크롬에서 JSON.parse()가 1.7배정도 빠르다고 한다. 이는 다른 자바스크립트 엔진이나 브라우저에서도 적용된다고한다. 리덕스앱에 이와 같은 적용을 한 사례에서는 Time To Interactive(TTI)가 18% 개선되었고, Lighthouse 성능 점수가 8포인트 증가하였습니다. 이러한 작업을 직접 수동으로 하는것 대신 툴을 이용하는것을 추천합니다.코드 베이스에 JSON 모듈을 사용할 경우, webpack에서는 JSON.parse()기능을 이미 적용 시켰습니다. 다른 코드들은 babel 플러그인를 이용해 변환 할 수 있습니다. 맺음말 페이스북 페이지에서 Faster apps with JSON.parse 해당 문구를 보자마자 “엥?? JSON.parse()는 느리지 않나??” 라는 생각만을 가지고 관심을 가지며 영상을 보면서 정리한 내용이라 제가 잘못 이해한 부분이 있을 수 있습니다. 잘못된 부분이 있으면 코멘트 부탁 드리겠습니다. 출처 Faster apps with JSON.parse (Chrome Dev Summit 2019)","link":"/2019/11/26/json-parse-is-faster-than-object-literal/"},{"title":"［Java］@JsonProperty이 왜 동작을 안하지?","text":"123class anonymousDTO { String whatYouWant;} 대부분 자바의 변수를 생성할때 위와 같이 CamelCase를 많이 쓰는것으로 알고있습니다…..(본인이 잘못 생각하는것일 수 있습니다.) 필자 또한 위와 같이 camelCase를 사용하였으나 API 통신 및 응답을 리턴할때에는hyphen uppercase가 필요했습니다. 위의 조건을 충족하기 위해 적절한 어노테이션을 찾았는데,@JsonProperty(&quot;{WHAT_YOU_WANT}&quot;)였습니다. json으로 매핑할때 WHAT_YOU_WANT에 들어갈 값으로 해당 프로퍼티를 매핑하는것이였습니다. 테스트 코드를 작성하여 확인해보았지만 정상 동작하지 않아, 주위의 도움을 받았는데,getter메소드에 해당 어노테이션을 작성해야한다는 조언도 있었으며,compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind'해당 라이브러리를 gradle에 추가하여 jackson 라이브러리를 최신화 할 필요가 있다는 조언을 받았습니다. 123456@Getter@Setterclass anonymousDTO { @JsonProperty(&quot;WHAT-YOU-WANT&quot;) String whatYouWant;} 12345678class anonymousDTO { String whatYouWant; @JsonProperty(&quot;WHAT-YOU-WANT&quot;) public String getWhatYouWant() { return this.whatYouWant; }} 많은 주위의 도움을 받아 위와 같이 두가지 방법을적용해 보았으나, 기대하는 결과를 얻을 수 없었습니다.(에러나 Exception은 발생하지 않았으나, 요청에 대한 응답을 모델에 매핑하였으나, Null 값이 해당 프로퍼티에 매핑되었습니다.) 오랜 삽질 끝에 얻은 결과는제가 요청에 대한 json Object 응답을 Gson을 이용하여 해당타입으로 받았는데,jackson의 json object로 매핑하였고, jackson의 어노테이션인 @JsonProperty가 기대와 다르게 동작하여,검색하였는데 @SerializedName 어노테이션으로 해결할 수 있다는 StackOverFlow에서의 답변이였습니다. 그리하여 해당 코드를 이와같이 변경하였습니다. 123456@Getter@Setterclass anonymousDTO { @SerializedName(&quot;WHAT-YOU-WANT&quot;) String whatYouWant;} Gson을 이용할 때에는 @SerializedName을 사용해야하고 jackson을 사용할때에는 @JsonProperty를 사용해야 한다는데레거시 PHP와 JS를 좋아하는 저로써는 똑같은 json object 이고, 사실상 JsonObject라는 타입인데,Gson의 json 이냐 jackson의 json이냐에 따라 다른 어노테이션을 써야한다는게 이해하기 어려웠습니다. 지난번, 어노테이션을 사용할때에도 해당 어노테이션이 어떻게 동작하는지 유의를 하며 써야겠다고 다짐했으나,결국 빠른 결과물과 편리함을 추구하다보니, 많이 사용하는 어노테이션을 그저 가져다 쓰는데에만 중점을 두었습니다. 제가 여태까지 사용해온 레거시 php 나 js는 이와 같은 강타입 언어가 아니다보니, 해당 어노테이션도 없을 뿐만 아니라,그저 모델 클래스를 만들 필요없이 변수에 담을 수 있었는데,이러한 부분이 어렵기도 하고, 긍정적인 시각으로 바라보았을때는 어느정도 타입체킹이 되고, 개발자 입장에선 복잡도는 증가하지만,조금 더 안정적이지 않을까 싶기도 합니다. 물론 제가 다른 대안으로 생각하는 TypeScript와 PHP v7.x도 있지만요…","link":"/2019/06/04/json-property-not-working/"},{"title":"［JS］Knex와 Webpack을 같이 쓰면서 발생한 오류 처리","text":"12ERROR in './node_modules/knex/lib/dialects/mssql/index.js'Module not found: Error : Can't resolve 'mssql/lib/base' 프로젝트에 웹팩을 도입하여 사용중, knex 라이브러리를 넣고 나서웹팩으로 빌드시 해당 에러가 나와서 빌드에 실패 했습니다. 해당 오류를 검색 하였는데,역시나 깃허브 이슈가 있었고(감사합니다),webpack의 config에 아래의 내용을 추가 하였습니다. 123externals: { knex: 'commonjs knex'} 해당 작업 후 빌드는 성공했지만,노드 서버에서 실행시 knex 모듈을 찾을 수 없다는 오류가 나왔습니다. 123456789101112131415{ &quot;errorMessage&quot;: &quot;Cannot find module 'knex'&quot;, &quot;errorType&quot;: &quot;Error&quot;, &quot;stackTrace&quot;: [ &quot;Function.Module._load (module.js:474:25)&quot;, &quot;Module.require (module.js:596:17)&quot;, &quot;require (internal/module.js:11:18)&quot;, &quot;Object.defineProperty.value (/var/task/main.js:1604:18)&quot;, &quot;__webpack_require__ (/var/task/main.js:20:30)&quot;, &quot;Object.&lt;anonymous&gt; (/var/task/main.js:1564:14)&quot;, &quot;__webpack_require__ (/var/task/main.js:20:30)&quot;, &quot;Object.defineProperty.value (/var/task/main.js:1442:20)&quot;, &quot;__webpack_require__ (/var/task/main.js:20:30)&quot; ]} 계속해서 구글링하던중, 다른분의 도움으로 해당 이슈 코멘트를 찾았습니다.해당 코드를 참고하여 mysql2 라이브러리를 사용했기때문에 아래와 같은 코드를 추가 하였습니다. 1234567891011121314151617{ plugins: [ new webpack.NormalModuleReplacementPlugin(/\\.\\.migrate/, '../util/noop.js'), new webpack.NormalModuleReplacementPlugin(/\\.\\.seed/, '../util/noop.js'), new webpack.IgnorePlugin(/mariasql/, /knex/), new webpack.IgnorePlugin(/mysql/, /knex/), new webpack.IgnorePlugin(/mssql/, /knex/), new webpack.IgnorePlugin(/oracle/, /knex/), new webpack.IgnorePlugin(/oracledb/, /knex/), new webpack.IgnorePlugin(/postgres/, /knex/), new webpack.IgnorePlugin(/redshift/, /knex/), new webpack.IgnorePlugin(/pg-query-stream/, /knex/), new webpack.IgnorePlugin(/sqlite3/, /knex/), new webpack.IgnorePlugin(/strong-oracle/, /knex/), new webpack.IgnorePlugin(/pg-native/, /pg/) ]} 빌드는 성공 했으나 정상 동작하지 않아 확인 해보니 /node_modules/knex/lib/mysql2/index.js 해당 파일에 이러한 코드가 있어서 결국 mysql2를 쓰더라도 mysql 라이브러리가 필요하였습니다. 굳이 mysql2 모듈을 고집 할 필요가 없을것 같아, mysql 모듈로 변경하고,new webpack.IgnorePlugin(/mysql/, /knex/) 를 new webpack.IgnorePlugin(/mysql2/, /knex/), 로 변경하니빌드도 성공하였으며, 정상 동작 하였습니다. 더 좋은 방법이 있을거 같은데 아쉽게도 제가 찾은 방법은 이것 밖에 없었습니다.좋은 해결 방안 있으면 댓글로 공유 부탁 드리겠습니다.","link":"/2019/04/18/knex-with-webpack/"},{"title":"［Database］ postgresql와 mysql 뭐가 다를까?","text":"PostgreSQL 과 MySQL의 차이점 PostgreSQL은 기본적으로 트랜잭션을 지원합니다(MySQL의 경우 테이블이 InnoDB 타입일 경우에만 지원합니다.) Databse의 하위개념으로 Schema가 있습니다.(MySQL의 Database의 개념은 PostgreSQL의 스키마와 개념이 비슷합니다.) 스키마를 별도로 지정하지 않을 경우, public이라는 스키마를 기본적으로 사용합니다. 데이터베이스가 다르면 물리적으로 분리되어있다는것을 의미합니다. 서로 다른 Schema간에는 JOIN이 가능합니다. 구조 참고자료 postgreSQL 구조 이미지 - 구루비 postgreSQL 소개","link":"/2018/04/23/pgsql-vs-mysql/"},{"title":"［PHP］배열 key의 min 또는 max 구하기","text":"PHP로 개발을 하다보면, 연관 배열을 많이 쓰게되는데요 아래와 같은 배열에서 cnt의 max값과 min값을 구하려면 어떻게 해야할까요? 또는 이러한 배열에서 특정 키값의 값만 뽑아 배열로 만들고싶다면 어떻게 해야할까요? 12345678910111213141516171819array(3) { [0]=&gt; array(3) { [&quot;title&quot;]=&gt; string(5) &quot;apple&quot; [&quot;cnt&quot;]=&gt; int(1) &quot;5&quot; [&quot;color&quot;]=&gt; string(5) &quot;green&quot; } [1]=&gt; array(3) { [&quot;name&quot;]=&gt; string(4) &quot;pear&quot; [&quot;cnt&quot;]=&gt; int(1) &quot;8&quot; [&quot;color&quot;]=&gt; string(6) &quot;yellow&quot; } 배열을 순회하여 해당 키의 값을 뽑아 배열을 만들고, 최소 또는 최대값이 필요하면 min 또는 max 함수를 적용해야 한다 생각했습니다. 그런 코드는 만들고 싶지 않아 검색을 하다보니 PHP 5.5버전부터는 array_column을 사용하면 쉽게 처리할 수 있었습니다. array array_column ( array $input , mixed $column_key [, mixed $index_key = NULL ] ) 와 같은 구조로 첫번째 파라미터에 해당 배열을 넣고, 두번째 파라미터에 뽑아낼 key를 넣으면 됩니다. 예를들어 아래와 같은 연관 배열에서 cnt로만 배열을 만들려면 이와 같이 할 수 있습니다. 123456789101112131415161718192021222324&lt;?php$arr = [ [ 'title'=&gt;'title1', 'cnt'=&gt;2, 'color'=&gt;'blue', ], [ 'title'=&gt;'title2', 'cnt'=&gt;3, 'color'=&gt;'blue', ],];$cntArr = array_column($arr, 'cnt');var_dump($cntArr);### Result array(2) { [0]=&gt; int(2) [1]=&gt; int(3)} 또한 세번째 파라미터로는 index_key를 넣을 수 있는데요 return 할 배열의 키로 사용할 값을 넣으면 됩니다 예를들어 이렇게 쓸 수 있을것 같았습니다. 12345678910111213141516171819202122232425262728&lt;?php// example code$arr = [ [ 'idx' =&gt; 2555, 'title'=&gt;'title1', 'cnt'=&gt;2, 'color'=&gt;'blue', ], [ 'idx' =&gt; 2982, 'title'=&gt;'title2', 'cnt'=&gt;3, 'color'=&gt;'blue', ],];$cntArr = array_column($arr, 'cnt', 'idx');var_dump($cntArr);### Resultarray(2) { [2555]=&gt; int(2) [2982]=&gt; int(3)} 이와같이 사용하면 해당 idx의 cnt를 뽑을 수 있어 더 효율적으로 사용할 수 있을거 같습니다. 더 좋은 사용 방안 있으시면 댓글로 부탁드리겠습니다. 참고자료 StackOverFlow - Find highest value in multidimensional array PHP 공식문서 - array_column()","link":"/2018/10/27/php-array-column/"},{"title":"［PHP］Monolog와 함께 로그를 시작하자 - 1","text":"PHP에서 로그 남기기PHP에서는 주로 JS에서 console.log | console.debug 와 유사하게 var_dump | print_r | echo | sys_log | error_log 등 다양한 방식으로 로그를 남기고 있습니다. Monolog란?PSR-3을 준수하고 있는 로깅 프레임워크로,거의 대부분의 로깅 플랫폼과 연결할 수 있는 핸들러(Slack, ElasticSearch, Mail, NewRelic 등)를 제공하고 있습니다. RFC 5424(Syslog Protocol이라고 하는데 더 공부해봐야할 것 같습니다.)에 정의된 로그 레벨을 모두 지원하고 있습니다. DEBUG(100) INFO(200) NOTICE(250) WARNING(300) ERROR(400) CRITICAL(500) ALERT(550) EMERGENCY(600) 코어 컨셉간단하게 Logger Instance에 Record를 추가하면,해당 인스턴스에 추가 해두었던 핸들러에 이벤트를 전파하는 것으로 보입니다.(한개의 로그를 여러곳에 저장할 수 있는 이점을 가지고 있습니다.) 설치 방법PHP Composer로 관리할 수 있는 라이브러리이므로 Composer를 이용하여 설치합니다. 1composer require monolog/monolog 사용방법우선적으로 use를 사용하여 사용할 Namespace를 추가합니다. 1234&lt;?phpuse Monolog\\Logger;use Monolog\\Handler\\StreamHandler;use Monolog\\Handler\\FirePHPHandler; Logging Channel의 이름을 설정하여 객체를 생성합니다. 12// Create the logger$logger = new Logger('Application'); 로그를 전파할 핸들러를 추가합니다. php:stderr 또는 원격이나 로컬 파일 기타에 사용할 Stream Handler를 설정합니다. Slack Webhook Url으로 보내기 위해 Slack WebHook Handler를 설정합니다. 123// Now add some handlers$logger-&gt;pushHandler(new StreamHandler(__DIR__ . '/app.log', Logger::DEBUG));$logger-&gt;pushHandler(new SlackWebhookHandler({{WEBHOOK_URL}}, {{CHANNEL}}, {{USERNAME}}, false, null, false, false, Logger::INFO)); 아래와 같은 함수를 호출하여 로그를 쌓을 수 있습니다. 1234567// You can now use your logger$logger-&gt;info('Welcome To Monolog');/********* * app.log *********/// [2019-05-10 17:03:10] Application.INFO: Welcome To Monolog [] [] Legacy한 프로젝트에서는 주로 컨테이너 객체라는 개념이 없는 경우가 많은데,프로젝트 내부에서도 글로벌 변수에 담아서 Logger 객체를 사용해야하나 고민하였습니다.문서를 확인하다보니 이를 위한 Monolog\\Registry라는 유틸 클래스가 있었고,이와 같이 사용할 수 있습니다. 1234567891011121314151617181920212223242526272829303132/**************** * bootstrap.php ****************/ &lt;?phpuse Monolog\\Handler\\StreamHandler;use Monolog\\Logger;use Monolog\\Registry;$logger = new Logger('Application');$logger-&gt;pushHandler(new StreamHandler(__DIR__ . '/app.log', Logger::DEBUG));Registry::addLogger($logger,'ApplicationLog');/**************** * foo.php ****************/&lt;?phpuse Monolog\\Registry;require_once __DIR__ . &quot;/bootstrap.php&quot;;function logInfo($message) { $logger = Registry::getInstance('ApplicationLog'); $logger-&gt;info($message);}logInfo('I am Global Logging');/********* * app.log *********/// [2019-05-10 17:03:10] Application.INFO: I am Global Logging [] [] 이와 같이 bootstrap.php 파일에서 Register에 등록한 Logger 객체는global 변수를 사용하지 않아도 클래스 / 함수 상관 없이 어디에서든지 사용 가능해집니다. 더 좋은 활용 방법이 있으시다면 공유 부탁드리겠습니다. 자세한 사항은 Monolog-Usage에서 확인 하실 수 있습니다.","link":"/2019/05/09/php-logging-with-monolog-1/"},{"title":"［PHP］ 0001과 같이 번호 지정 하기","text":"PHP에서 0001과 같이 번호 지정하기1234&lt;?php$count = 1;$count = str_pad($count,4,'0',STR_PAD_LEFT); //0001?&gt; 01이나 001 같이 사용할 때는 두번째 파라미터 값에 2(01) 또는 3(001)을 사용하면 된다.","link":"/2017/08/31/php-str-pad/"},{"title":"［PHP］ 에러 보여주기","text":"배포 서버에서는 권장하지 않는 설정입니다.테스트 서버에서 에러 메세지를 확인하고 싶을때해당 php 파일의 최상위나 공통파일의 최상위에 이 소스코드를 넣어주시면 됩니다.1234&lt;?php error_reporting(E_ALL); //모든 PHP 에러를 리포팅함 ini_set(&quot;display_errors&quot;, 1); //php.ini 파일의 'display_errors'를 활성화 시킴?&gt;","link":"/2017/11/17/php-view-error/"},{"title":"［PHP］ PHP4.x 버전과 PHP 5.x 버전 비교(Comparison between PHP4 and PHP5)","text":"PHP5에서 무엇이 바뀌었을까? 젠드엔진2가 내장되었습니다. PHP GCI 버전이 php.exe 에서 php-cgi.exe 로 변경되었습니다. PHP CLI 버전이 cli/php.exe 에서 주 디렉토리로 변경되었습니다. PHP CLI 버전은 php.ini 지시어 설정과 상관없이 항상 전역 $argv(Array of arguments passed to script) 와 $argc(The number of arguments passed to script) 변수를 가지며, register_argc_argv(argv와 argc 변수를 선언할지 여부 설정)를 off로 설정해도 영향을 미치지 않습니다. ISAPI 모듈들의 이름이 php4xxx에서 php5xxx로 바뀌었습니다. 프로퍼티가 없는 객체를 “빈” 것으로 판단하지 않습니다. 인터페이스 등을 사용할 경우, 사용 전 선언해야합니다. 포함한 파일에 함수정의가 있을경우, 그 파일이 두번 포함 되었을 때,PHP5에서는 치명적인 오류가 발생합니다. include_once를 사용하길 권장합니다. 키워드 예외처리(try()-catch()-finally()[v5.5~]) 네임스페이스[v5.3~] 인터페이스(interface,implements) 추상클래스(abstract) 접근제어자(private,protected,public) instanceof : 객체의 클래스 확인 clone : 객체 복제 컴파일 상수 __NAMESPACE__ [v5.3~] __DIR__ [v5.3~] DataBase MySQL 클라이언트 라이브러리를 포함하지 않습니다. MySQL 4.1 이상에서 동작하는 MySQLi가 추가되었습니다. SQLite 확장 모듈이 포함됩니다. 새로운 함수가 추가되었습니다.(New Functions) 배열 (9개) array_combine() : 하나의 배열은 키로, 하나의 배열은 값으로 가지는 배열 생성 합니다. array_walk_recursive() : 배열의 모든 원소에 사용자 함수를 적용합니다. 이 외의 7개 함수 iconv (7개) iconv_strlen() : 문자열의 문자 수를 반환 합니다. iconv_strpos() : haystack에서 needle이 처음으로 나타나는 위치를 찾습니다. iconv_strrpos() : haystack에서 needle이 마지막으로 나타나는 위치를 찾습니다. iconv_substr() : 문자열의 일부를 잘라냅니다. 이 외의 3개 함수 스트림 (8개) stream_copy_to_stream() : 한 스트림의 데이터를 다른 스트림으로 복제합니다. stream_get_line() : 스트림 자원에서 주어진 구분자로 나타나는 열을 얻습니다. 이 외의 6개 함수 날짜와 시간 관련 (4개) idate() : 지역 날짜/시간을 정수로 바꿉니다. date_sunset() : 주어진 날짜와 위치의 일몰 시간을 반환합니다. date_sunrise() : 주어진 날짜와 위치의 일출 시간을 반환합니다. time_nanosleep() : 초와 나노초의 수만큼 지연합니다. 문자열 (3개) str_split() : 문자열을 배열로 변환합니다. strbrk() : 문자열에서 문자 세트에 있는 문자를 검색합니다.(대소문자 구분하여 세트중 한글자라도 먼저 나오는것을 찾습니다.) substr_compare() : 두 문자열을 offset부터 length까지(대소문자 구분없이:옵션) 바이너리로 안전하게 비교합니다. 인터베이스 (19개) 기타 (30개) file_put_contents() : 문자열을 파일로 씁니다. get_headers() : HTTP 요청의 응답으로 서버가 보낸 모든 헤더를 가져옵니다. http_build_query() : 배열을 이용하여 URL-encode한 쿼리 문자열을 생성합니다. scandir() : 지정한 경로 안에 파일과 디렉토리 목록을 배열로 반환합니다. 이 외의 27개 함수 자세한 내용은 해당링크에서 확인 하실 수 있습니다. 새로운 지시어 (php.ini 지시어) mail.force_extra_parameter register_long_arrays session.hash_function : 해시 함수 선택(MD5 or SHA-1) session.hash_bits_per_character zend.ze1_compatibility_mode : 젠드엔진1 (PHP 4)호환모드 활성화 기타 자세한 사항은 해당링크에서 확인 하실 수 있습니다. 참고자료 PHP 공식문서 - PHP4에서 PHP 5.0.x로 이행","link":"/2018/04/19/php4-vs-php5/"},{"title":"PHPUnit Annotation 정리","text":"서론 PHP Unit을 사용하면서도 잘 모르는 어노테이션을 PHPUnit v8.4 기준(2019-11-19 최신버전)으로 정리하였습니다. @author테스트를 작성자별 그룹화 필터링 할 때 @group 어노테이션의 별칭으로, 테스트를 작성자별로 그룹화하여 필터링 하는데 사용할 수 있습니다. @after각 테스트가 끝난 뒤 실행 하려 할 때 각 테스트 메소드들이 실행 된 후, 특정 메소드를 실행하고자 할때 사용할 수 있습니다. 각 테스트가 끝난 뒤 트랜잭션 커밋or롤백을 한다거나, 생성된 파일을 삭제하는 등의 처리를 하는데 사용하면 좋을 것 같습니다. 예제 코드 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace Tests;use PHPUnit\\Framework\\TestCase;class MyTest extends TestCase{ /** * @after */ public function afterDo() { echo &quot;After Method Called&quot; . PHP_EOL; } public function test1() { echo &quot;test1 Method Called&quot; . PHP_EOL; self::assertTrue(true); } public function test2() { echo &quot;test2 Method Called&quot; . PHP_EOL; self::assertTrue(true); }}// 출력 결과test1 Method CalledAfter Method Calledtest2 Method CalledAfter Method Called @afterClass모든 테스트가 끝난 후 실행 하려 할 때 모든 테스트가 끝난 후, 공유된 자원들을 정리하기 위해 호출할 정적 메소드를 지정 할 수 있습니다. 해당 부분에서 테스트 실행시 만든 DB 커넥션을 회수하거나, 전체 트랜잭션을 처리 하거나, 소켓을 닫는 등의 처리를 할 수 있을것 같습니다. 예제 코드 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Tests;use PHPUnit\\Framework\\TestCase;class MyTest extends TestCase{ /** * @afterClass */ public static function afterClassDo() { echo &quot;After Class Method Called&quot; . PHP_EOL; } public function test1() { echo &quot;test1 Method Called&quot; . PHP_EOL; self::assertTrue(true); } public function test2() { echo &quot;test2 Method Called&quot; . PHP_EOL; self::assertTrue(true); }}// 출력 결과test1 Method Calledtest2 Method CalledAfter Class Method Called @backupGlobals글로벌 변수를 유지하고 싶다면 모든 글로벌 변수를 각 테스트 전에 백업하고, 각 테스트 이후 해당 백업을 복원시킵니다. 메소드 레벨에서 재정의가 가능합니다. 해당 설명만으로는 이해가 잘 되지 않아서 직접 예제 코드를 만들어 보았습니다.클래스 스코프 밖에 정의된 글로벌 변수인 $className을 @backupGlobals 어노테이션이 enabled 되어 있는 테스트 코드에서는 실행이전 값을 백업하여두고 테스트가 끝나면 복원이 되어,두번째 테스트코드에서도 “MyTest”라는 값을 가지고 있게됩니다. 예제 코드 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Tests;use PHPUnit\\Framework\\TestCase;$className = &quot;MyTest&quot;;/** * @backupGlobals enabled */class MyTest extends TestCase{ public function test_글로벌변수를_백업하고_변경() { global $className; $this-&gt;assertEquals($className, &quot;MyTest&quot;); $className = &quot;Foo&quot;; } /** * @backupGlobals disabled */ public function test_글로벌변수를_백업하지_않고_변경() { global $className; $this-&gt;assertEquals($className, &quot;MyTest&quot;); $className = &quot;Bar&quot;; } public function test_글로벌변수를_백업되어있는지_체크() { global $className; $this-&gt;assertEquals($className, &quot;Bar&quot;); }} @backupStaticAttributes정적 속성을 사용하려 할 때 선언된 클래스들 안의 모든 정적 속성을 각 테스트 전에 백업하고, 각 테스트 후에 해당 백업을 복원 시킵니다. 클래스 레벨에도 선언 가능하며, 각 테스트 메소드에서 추가 제어 가능합니다. 예제 코드 **아래 코드는 정상 동작 안 합니다.** 12345678910111213141516171819202122&lt;?phpuse PHPUnit\\Framework\\TestCase; /** * @backupStaticAttributes enabled */class MyTest extends TestCase{ public function test_정적속성을_사용하는_테스트() { // ... } /** * @backupStaticAttributes disabled */ public function test_정적속성을_사용하지_않는_테스트() { // ... }} @before각 테스트 실행전에 실행 하려 할 때 각 테스트 메소드가 호출되기 전에 실행할 메소드를 지정할 수 있습니다. 아래와 같이 beforeMethod는 각 메소드 호출전에 실행되지만,users 배열의 값이 증가되지는 않습니다. 예제 코드 123456789101112131415161718192021222324252627282930313233343536&lt;?phpuse PHPUnit\\Framework\\TestCase;class MyTest extends TestCase{ protected $users = []; /** * @before */ public function beforeMethod() { echo &quot;Before Method Called&quot; . PHP_EOL; $this-&gt;users[] = [ 'name' =&gt; '홍길동' ]; } public function test1() { echo &quot;test1 Method Called&quot; . PHP_EOL; self::assertCount(1, $this-&gt;users); } public function test2() { echo &quot;test2 Method Called&quot; . PHP_EOL; self::assertCount(1, $this-&gt;users); }}// 출력 결과Before Method Calledtest1 Method CalledBefore Method Calledtest2 Method Called @beforeClass테스트 실행전 공유 속성을 만들 때 해당 클래스에서 테스트가 실행되기전 공유 하기 위한 정보를 설정하기 위해 호출 할 static 메소드에 지정하여 사용할 수 있습니다. 예제 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpuse PHPUnit\\Framework\\TestCase;class MyTest extends TestCase{ protected $users = []; /** * @beforeClass */ public static function beforeClass() { echo &quot;Before Class Called&quot; . PHP_EOL; } /** * @before */ public function beforeMethod() { echo &quot;Before Method Called&quot; . PHP_EOL; $this-&gt;users[] = [ 'name' =&gt; '홍길동' ]; } public function test1() { echo &quot;test1 Method Called&quot; . PHP_EOL; self::assertCount(1, $this-&gt;users); } public function test2() { echo &quot;test2 Method Called&quot; . PHP_EOL; self::assertCount(1, $this-&gt;users); }}// 출력 결과Before Class CalledBefore Method Calledtest1 Method CalledBefore Method Calledtest2 Method Called @codeCoverageIgnore* 코드 커버리지 분석시 제외할 라인에 사용할 수 있습니다. 예제 코드 123456789101112131415161718192021222324252627282930&lt;?phpuse PHPUnit\\Framework\\TestCase;/** * @codeCoverageIgnore */class Foo{ public function bar() { }}class Bar{ /** * @codeCoverageIgnore */ public function foo() { }}if (false) { // @codeCoverageIgnoreStart print '*'; // @codeCoverageIgnoreEnd}exit; // @codeCoverageIgnore @covers테스트 영역을 명시하려 할 때 어떤 영역을 테스트 하고자 하는지 명시하고자 할 때 사용합니다. 이와 같이 명시 하면 IDE(PHPStorm)에서 연결되어 있어 ctrl+shift+T 를 이용해 테스트로 바로 이동이 가능해지고, usage로 찾을 수 있어 메소드명 수정시 같이 반영됩니다. 예제 코드 1234567/** * @covers \\App\\Services\\Member::getMember */public function test_회원정보에_나이_정보가_있는지_체크(){ $this-&gt;assertArrayHasKey('age', $this-&gt;member-&gt;getMember(1));} @coversDefaultClass너무 긴 네임스페이스와 클래스명을 반복해서 쓰고 싶지 않을 때 기본 네임스페이스나 클래스명을 명시하는데 사용할 수 있어, @covers 어노테이션에 긴 네임스페이스나, 클래스명을 반복해서 사용할 필요가 없어집니다. 해당 어노테이션에는 정규화 된 클래스명을 사용해야하기때문에,모호하지 않도록 클래스명 맨 앞에 \\ 로 시작하는것을 추천합니다. 아래 예제 코드와 같이 @covers \\Foo\\CoveredClass::publicMethod 를 @covers ::publicMethod로 줄여 쓸 수 있는 이점을 얻게 됩니다. 예제 코드 1234567891011121314151617&lt;?phpuse PHPUnit\\Framework\\TestCase;/** * @coversDefaultClass \\Foo\\CoveredClass */class CoversDefaultClassTest extends TestCase{ /** * @covers ::publicMethod */ public function testSomething() { $o = new Foo\\CoveredClass; $o-&gt;publicMethod(); }} @coversNothing작성예정 클래스나 메소드레벨에서 사용할 수 있고 @covers 어노테이션을 덮어 씁니다. @DataProvider메소드를 이용해 파라미터를 주입하고 싶을때 @dataProvider 를 사용하면 메소드의 파라미터로 전달할 수 있습니다.Java Junit 패키지에서 JunitParams를 이용하여 @Parameters 어노테이션을 사용하는것과 동일한 효과를 얻을 수 있습니다. 예제 코드 아래 예제 코드와 같은 테스트는 배열의 각 값 들이 $a, $b, $expected 로 바인딩 되며, 총 4개의 배열이 자동 주입되어 테스트가 4회 수행됩니다. ```php assertSame($expected, $a + $b); } public function additionProvider() { return [ [0, 0, 0], [0, 1, 1], [1, 0, 1], [1, 1, 3] ]; } } 1234567891011121314151617181920212223242526- 아래와 같이 이름이 정의된 dataset을 사용할 수도 있습니다. - ```php &lt;?php use PHPUnit\\Framework\\TestCase; class DataTest extends TestCase { /** * @dataProvider additionProvider */ public function testAdd($a, $b, $expected) { $this-&gt;assertSame($expected, $a + $b); } public function additionProvider() { return [ 'adding zeros' =&gt; [0, 0, 0], 'zero plus one' =&gt; [0, 1, 1], 'one plus zero' =&gt; [1, 0, 1], 'one plus one' =&gt; [1, 1, 3] ]; } } @depends테스트 코드간의 종속성 정의 @depends 어노테이션 사용시 테스트 코드간의 종속성을 선언 할 수 있습니다. 실행순서를 정의하는것은 아니지만, @depends에 정의된 테스트의 리턴값의 레퍼런스를 전달합니다. 레퍼런스 전달이 아닌 값의 깊은 복사를 원할 경우 @depends clone 를 이용하고,PHP에서 clone으로 불리는 얕은 복사를 원할 경우 @depends shallowClone 를 이용하면 됩니다. @doesNotPerformAssertions값에 대한 assertion 없이 테스트 코드를 실행만 하고자 할때 아래와 같이 테스트를 수행하지 않을 경우 This test did not perform any assertions와 같은 Warning이 발생됩니다. 해당 어노테이션을 사용하면 Risky 없이 OK (1 test, 0 assertions)로 성공 처리됩니다. 예제 코드 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Tests;use PHPUnit\\Framework\\TestCase;class MyTest extends TestCase{ public function testAddSlashes() { echo addslashes(&quot;name='1'&quot;); }}// 출력 결과This test did not perform any assertions/opt/project/tests/MyTest.php:9name=\\'1\\'OK, but incomplete, skipped, or risky tests!Tests: 1, Assertions: 0, Risky: 1.&lt;?phpnamespace Tests;use PHPUnit\\Framework\\TestCase;class MyTest extends TestCase{ /** * @doesNotPerformAssertions */ public function testAddSlashes() { echo addslashes(&quot;name='1'&quot;); }} @group테스트 코드에 태그를 달고 싶을때 @group어노테이션을 이용하여, 테스트 코드에 1개 이상의 태그와 같이 묶음 필터를 추가할 수 있습니다. XML 설정 파일 주입을 이용 하거나 CLI에서 실행시 --group 과 --exclude-group 를 이용해서 테스트 실행 대상 또는 제외그룹을 설정할 수 있습니다. @large60초 이상 실행 되면 실패 처리 하고자 할 때 @group large의 별칭으로,PHP_Invoker 패키지가 설치되어 있고, strict mode가 실행되어 있으면 60초 이상 실행 될 경우 실패 처리됩니다.해당 타임아웃에 관한 정보는 설정 정보 XML의 timeoutForLargeTests속성을 통해 설정 할 수 있습니다. @medium10초 이상 실행 되면 실패 처리 하고자 할 때 @group medium의 별칭으로, PHP_Invoker 패키지가 설치되어 있고, strict mode가 실행되어 있으면 10초 이상 실행 될 경우 실패 처리됩니다.해당 타임아웃에 관한 정보는 설정 정보 XML의 timeoutForMediumTests속성을 통해 설정 할 수 있습니다. Medium 테스트는 @large 테스트에 의존적이여서는 안됩니다. @preserveGlobalState테스트가 별도의 프로세스에서 실행될때 직렬화 오류 방지 테스트가 별도의 프로세스에서 실행될 때, PHPUnit은부모 프로세스에서 글로벌 state를 직렬화 한 값을 자식 프로세스에서 역직렬화하여 상태를 보존합니다. 부모 프로세스에서 직렬화 할 수 없는 글로벌 state가 있는 경우, 해당 옵션을 disable 처리하여 방지할 수 있습니다. @requires특정 조건일때만 테스트를 수행하고자 할 때 PHP의 버전이나 extensions 설치여부 등 전제 조건을 체크하여 테스트를 건너뛸 수 있습니다. &lt;, &lt;=, &gt;, &gt;=, =, ==, !=, &lt;&gt; 등의 비교 연산자를 사용하여 버전을 비교할 수 있습니다. 해당 어노테이션을 이용해 체크 가능한 항목은 아래와 같습니다. 체크 가능한 조건 PHP PHP 버전 PHPUnit PHP Unit 버전 OS PHP_OS 상수와 정규식으로 매칭되는 값입니다. ex) WIN32|WINNT OSFAMILY PHP_OS_FAMILY 상수와 매칭되는 값으로 PHP 7.2.0부터 사용가능합니다. ex) Windows function 함수 존재 여부 → function_exists() extension extension 설치 여부 및 버전 체크 예제 코드 123456789101112131415161718&lt;?phpuse PHPUnit\\Framework\\TestCase;/** * @requires extension mysqli */class DatabaseTest extends TestCase{ /** * @requires PHP &gt;= 5.3 */ public function testConnection() { // 해당 테스트는 mysqli 확장프로그램이 설치되어 있고, PHP 버전이 5.3 이상일때 실행됩니다. } // 추가적인 테스트를 작성하였을때에도 mysqli 확장프로그램이 필요합니다.} @runTestsInSeparateProcesses테스트 클래스 내의 모든 테스트 메소드가 별도 PHP프로세스에서 테스트코드를 실행 하는것을 명시할 때 해당 테스트 클래스 내의 모든 테스트 메소드들이 별도의 PHP 프로세스에서 실행되어야 함을 표시 할 때 사용합니다. PHPUnit은 직렬화를 통해 Global state를 유지하려 하기 때문에, 직렬화가 불가능한 부분은 @preserveGlobalState를 참조하세요. @runInSeparateProcess 해당 테스트 메소드가 별도의 PHP 프로세스에서 실행되어야 함을 표시 할 때 사용합니다. PHPUnit은 직렬화를 통해 Global state를 유지하려 하기 때문에, 직렬화가 불가능한 부분은 @preserveGlobalState를 참조하세요. @small @group small의 별칭으로, PHP_Invoker 패키지가 설치되어 있고, strict mode가 실행되어 있으면 1초 이상 실행 될 경우 실패 처리됩니다.해당 타임아웃에 관한 정보는 설정 정보 XML의 timeoutForSmallTests속성을 통해 설정 할 수 있습니다. Medium 테스트는 @large 와 @medium로 마킹된 테스트에 의존적이여서는 안됩니다. ※ 테스트의 실행 시간 제어를 하고자 할 때, @small, @medium, @large 와 같은 어노테이션을 명시적으로 사용해야합니다. @test테스트 메소드명을 test로 시작하고싶지 않을 때 테스트 메소드는 메소드명의 prefix로 test를 사용합니다. 테스트 메소드명의 prefix로 test를 사용하지 않는 대안으로, 주석에 @test 어노테이션을 사용하면 테스트 메소드라고 인식됩니다. @testdoxtestdox 옵션으로 생성되는 문서의 설명을 대체하려 할 때 --testdox를 옵션으로 주었을때, 메소드의 이름으로부터 만들어진 설명을 오버라이딩 할 수 있습니다. 클래스 또는 메소드의 설명을 더 명확히 만들어 agile document를 만들 수 있습니다. 주의할 점으로는 PHPUnit v7.0까지는 어노테이션 파싱 오류로, @test로 인식되어 동작합니다. @testWith주석을 이용해 파라미터를 주입하고 싶을때 @dataProvider는 호출될 메소드를 필요로 하지만, 주석만을 이용해 테스트하고자 할 때에는@testWith를 사용할 수 있습니다. JSON 포맷은 연관배열로 주입됩니다. 주의 할 점은 여러개의 dataset을 정의할 때에는 라인당 하나씩 지정해야합니다. 아래의 두개의 코드는 동일하게 동작합니다. 예제 코드 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php/** * @param string $input * @param int $expectedLength * * @testWith [&quot;test&quot;, 4] * [&quot;longer-string&quot;, 13] */public function testStringLength(string $input, int $expectedLength){ $this-&gt;assertSame($expectedLength, strlen($input));}/** * @param string $input * @param int $expectedLength * * @dataProvider additionProvider */public function testStringLengthWithDataProvider(string $input, int $expectedLength){ $this-&gt;assertSame($expectedLength, strlen($input));}public function additionProvider(){ return [ [&quot;test&quot;, 4], [&quot;longer-string&quot;, 13] ];}/** * @param array $array * @param array $keys * * @testWith [{&quot;day&quot;: &quot;monday&quot;, &quot;conditions&quot;: &quot;sunny&quot;}, [&quot;day&quot;, &quot;conditions&quot;]] */public function testArrayKeys($array, $keys){ $this-&gt;assertSame($keys, array_keys($array));}/** * @param array $array * @param array $keys * * @dataProvider additionProvider */public function testArrayKeysWithDataProvider($array, $keys){ $this-&gt;assertSame($keys, array_keys($array));}public function additionProvider(){ return [ [[&quot;day&quot; =&gt; &quot;monday&quot;, &quot;conditions&quot; =&gt; &quot;sunny&quot;], [&quot;day&quot;, &quot;conditions&quot;]] ];} @ticketTicket ID(JIRA 이슈 코드와 같은)로 테스트를 필터링 할 때 @group 어노테이션의 별칭. ticket ID를 이용하여 테스트를 필터링 할 수 있도록 하여줍니다. @uses 테스트에 의해 실행될 코드를 지정합니다. 좋은 예제는 아래와 같이 유닛 테스트 코드에 필요한 Object 값 입니다. 예제 코드 12345678/** * @covers \\BankAccount * @uses \\Money */public function testMoneyCanBeDepositedInAccount(){ // ...} 해당 어노테이션에는 정규화 된 클래스명을 사용해야하기때문에,모호하지 않도록 클래스명 맨 앞에 \\ 로 시작하는것을 추천합니다.","link":"/2019/11/24/phpunit-annotations/"},{"title":"［Java］@AllArgsConstructor의 잘못된 사용","text":"Consider defining a bean of type java.lang.String in your configuration.스프링부트로 서비스를 개발중에 @Value 어노테이션을 이용하여 application.yml 파일에 저장해둔 환경변수에 접근하고 싶었는데,아래와 같은 오류가 발생하였습니다. 123Parameter 2 of constructor in com.hodory.v1.service.MyService required a bean of type 'java.lang.String' that could not be found.Consider defining a bean of type 'java.lang.String' in your configuration. Retrofit을 사용하기위해 apiBaseUrl을 가져오려 작성한 코드는 아래와 같습니다. 123456789101112@Slf4j@Service@AllArgsConstructorpublic class MyService { private final MyRepository myRepository; private final ModelMapper modelMapper; @Value(&quot;${config.endpoint.url}&quot;) private String serviceUrl; ...} 필드에 @Autowired를 사용하는것은 권장하지 않는다는 IDE에서 나오는 메세지때문에 이 방식은 사용하지 않았습니다. 생성자를 이용한 주입이 아닌 @AllArgsConstructor 어노테이션을 사용한 이유는이전에 사용하였을때, 생성자를 이용해 직접 주입하는 방식보다, 의존성 주입 할 대상이 많아졌을때 훨씬 더 깔끔하였던 경험이 있어,해당 어노테이션을 사용하였습니다. private String serviceUrl 을 추가하고나서부터 해당 오류가 나타났습니다. 한참을 고민하다가 팀원들의 도움을 받아 원인을 알게 되었는데, serviceUrl이라는 값은 String 타입의 변수일 뿐, 스프링에서 관리하는 Bean이 아니기 때문에 의존성 자동 주입이 될 수 없다는것이였습니다. @Value를 사용하면 자동 주입이 되는줄 알았는데, 제가 생각했던것과 달랐습니다. 아래와 같이 스프링 애플리케이션에 의해 자동 주입 가능한 필드들을 파라미터로 가진 생성자를 만들어 필드에 매핑하도록 수정 하였더니,오류 없이 serviceUrl에 application.yml파일에 있던 url도 설정 되어 있었습니다. 1234567891011121314151617@Slf4j@Servicepublic class MyService { private final MyRepository myRepository; private final ModelMapper modelMapper; @Value(&quot;${config.endpoint.url}&quot;) private String serviceUrl; @Autowired public MyService(MyRepository repository, ModelMapper modelMapper) { this.myRepository = repository; this.modelMapper = modelMapper; } ...} 위와 같이 생성자에 직접 필요한 Bean들을 명시하여 주입 하는 방식 말고도기존 코드에서 @AllArgsConstructor 대신 @RequiredArgsConstructor 어노테이션을 사용하기만 하면,final로 선언된 필드나 @NonNull 어노테이션을 사용한 필드만을 필요로 하는 생성자를 만들어주기 때문에,이 경우에는 원하는 결과를 얻을 수 있었습니다. 자바에도 익숙 하지 않고, 의존성 주입이라는 개념에 대해 익숙하지 않은데,원리를 파악하지 않고, 남들을 따라하는 기존의 자세에 반성하는 계기가 되었으며, 어노테이션을 사용 할 때 해당 어노테이션이 해주는 기능만 파악 하는 것 만큼어떻게 동작하는지(예를 들어 lombok의 경우 어떤 코드를 생성 해주는지)등을 유의하며 사용해야겠다고 느꼈습니다.","link":"/2019/05/28/required-a-bean-of-type-that-could-not-be-found/"},{"title":"[AWS] S3 호스팅에 도메인 연결하기","text":"S3에서 정적 웹호스팅을 할 수 있다는 이야기는 들어 보았지만, 아직까지 해 볼 경험이 없었는데지인 덕분에 간만에 재밌는걸 해봐서 잊지 않으려고 기록합니다. 이미 많은 포스팅들도 있고, 공식 가이드 문서도 충분히 잘 정리 되어 있으니 참고 하시기 바랍니다. 도메인은 이미 구매하였다는 가정하에 진행합니다.이 포스팅에서 사용할 도메인은 [travelerapp.kr](http://travelerapp.kr) 입니다.(곧 만료 예정) S3 설정하기 우선 별 다른 설정없이 s3 버킷을 생성하여줍니다.이때 주의할점은 버킷명을 호스팅 하고자 하는 도메인과 일치시켜 주어야 합니다. 또한 권한 설정시 퍼블릭 액세스를 꼭 체크 해제 해주어야 합니다. 버킷이 생성되면 호스팅 하고자 하는 파일을 업로드하여줍니다.호스팅시 누구나 접근 가능하게 하기때문에 퍼블릭 액세스를 허용 해야합니다. 그 후 속성 → 정적 웹 사이트 호스팅 메뉴에 들어가서인덱스 문서(메인 페이지), 오류 문서(404 등 오류가 발생했을때 노출 할 페이지) 2가지를 설정하여줍니다. 저는 아래와 같이 main.html과 error.html으로 설정했습니다. 저장 후 빨간색 박스 안에 있는 엔드포인트에 본인이 설정한 페이지가 정상적으로 노출되는지 확인합니다. 또한 /detail.html 과 같이 존재하지 않는 페이지를 조회하였을때에 오류 문서로 설정한 페이지가 정상적으로 노출되는지도 확인합니다. 마지막으로 버킷의 정책을 설정하여 줍니다. 해당 리소스 하위 경로에 대한 조회 권한을 설정하는것으로, 아래의 빨간 박스 내용이 자신이 설정하려는 도메인과 동일해야합니다. 12345678910111213{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Id&quot;: &quot;Policy1579004958999&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;Stmt1579004957334&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: &quot;*&quot;, &quot;Action&quot;: &quot;s3:GetObject&quot;, &quot;Resource&quot;: &quot;arn:aws:s3:::static.travelerapp.kr/*&quot; } ]} 이것으로 S3에 대한 설정은 끝입니다. Route53 설정하기 Route53의 설정은 더욱 간단합니다. 이미 호스팅 영역을 등록 하였다면, 네임서버 설정은 아마존으로 자동 설정되어 있기 때문에 설정하려는 도메인으로 레코드 세트를 등록하여줍니다. 이때 ALIAS를 사용하는데 정상적으로 등록 하였다면 아래 이미지와 같이 s3에 대한 설정이 있습니다. 이와 같이 설정 후 저장을 하면 좌측 패널에 ALIAS로 설정된 도메인이 추가됩니다. 이제 다시 http://static.travelerapp.kr 로 접근하면 설정한 도메인에 S3에 올려둔 페이지가 정상적으로 노출됩니다. 또한 하위 디렉토리나 파일들도 접근이 가능합니다. 단점으로는 현재(2020-01-14 기준) http 프로토콜만 지원하기때문에 https를 지원하기 위해서는 CloudFront 서비스를 대안으로 사용해야 합니다. 참고자료 AWS S3 공식문서 - 사용자 지정 도메인으로 정적 웹 사이트 설정 Route 53과 S3로 정적 웹사이트 올리기","link":"/2020/01/14/setting-domain-for-s3-static-web-hosting/"},{"title":"［Java］스프링부트 회원 기존 비밀번호 체크하기","text":"회원 비밀번호 변경 로직을 작성중에 현재 비밀번호와 새 비밀번호를 입력받아,기존 비밀번호가 맞는지 체크하는 로직을 넣고 싶었습니다. 12345678910String currentPassword = new BCryptPasswordEncoder().encode(request.getCurrentPassword()); final User persistUser = userRepository.findUserByIdAndPassword(userId, currentPassword) .orElseThrow(() -&gt; new EntityNotFoundException(&quot;회원정보를 찾을 수 없습니다.&quot;)); if(!currentPassword.equals(persistUser.getPassword())) { logger.info(&quot;changePassword is Not Equal Current Password&quot;); return new ResponseEntity&lt;&gt;(UserRegisterResult.ERROR.getResponseBody(), HttpStatus.FORBIDDEN); } new BCryptPasswordEncoder().encode(password);로 암호화 한 패스워드를 저장했기 때문에,회원을 찾을때도 이렇게 하면 되겠다고 생각해서 위와 같은 코드를 작성하였는데,테스트중 계속하여 EntityNotFoundException이 발생하였습니다. 디버깅으로 체크하였더니 String currentPassword = new BCryptPasswordEncoder().encode(request.getCurrentPassword()); 부분에서 매번 다른 비밀번호가 currentPassword에 들어갔습니다. 왜 다른 값이 나오는지 알고 싶어 BCryptPasswordEncoder 클래스 파일을 열어보았는데, encode 부분에서 rawPassword 와 salt값을 생성하여 두개의 값으로 패스워드를 해싱하고 있었습니다. 해당 클래스 파일안에 matches(CharSequence rawPassword, String encodedPassword)라는 함수가 있었고, 클래스의 인터페이스를 확인하였더니, 1234567891011/** * Verify the encoded password obtained from storage matches the submitted raw * password after it too is encoded. Returns true if the passwords match, false if * they do not. The stored password itself is never decoded. * * @param rawPassword the raw password to encode and match * @param encodedPassword the encoded password from storage to compare with * @return true if the raw password, after encoding, matches the encoded password from * storage */boolean matches(CharSequence rawPassword, String encodedPassword); 라는 주석을 확인하였고, 구현체가 아닌 인터페이스를 사용하고자org.springframework.security.crypto.password.PasswordEncoder 를 의존성 주입하여, 12345678final User persistUser = userRepository.findById(userId) .orElseThrow(() -&gt; new EntityNotFoundException(&quot;회원정보를 찾을 수 없습니다.&quot;));if(!passwordEncoder .matches(request.getCurrentPassword(), persistUser.getPassword())) { logger.info(&quot;changePassword is Not Equal Current Password&quot;); return new ResponseEntity&lt;&gt;(UserRegisterResult.ERROR.getResponseBody(), HttpStatus.FORBIDDEN);} 이와 같이 수정하였고, 기대했던 결과대로 수행되었습니다. 아직 자바와 스프링이 많이 서툴러서 코드를 작성하는 시간보다 검색해보는 시간이 많아 더 어려운거 같습니다. 잘못된 부분이 있다면 코멘트 부탁드리겠습니다.","link":"/2019/05/14/spring-boot-validate-user-old-password/"},{"title":"［Java］Spring REST Docs HTML이 생성되지 않을때","text":"백기선님의 스프링부트 강좌를 수강하는중에 Spring REST Docs를 이용하여 HTML을 생성하려하는데,아무리 빌드를 해도 ascii\\html\\index.html이 생성되지 않았습니다. 1234567891011121314151617181920212223242526272829303132오후 11:58:18: Executing task 'build'...&gt; Task :compileJava&gt; Task :processResources&gt; Task :classes&gt; Task :compileTestJava&gt; Task :processTestResources NO-SOURCE&gt; Task :testClasses&gt; Task :test2019-12-02 23:58:35.629 INFO 24376 --- [ Thread-5] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService 'applicationTaskExecutor'2019-12-02 23:58:35.629 INFO 24376 --- [ Thread-7] o.s.s.concurrent.ThreadPoolTaskExecutor : Shutting down ExecutorService 'applicationTaskExecutor'2019-12-02 23:58:35.630 INFO 24376 --- [ Thread-7] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'2019-12-02 23:58:35.630 INFO 24376 --- [ Thread-5] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default'2019-12-02 23:58:35.630 INFO 24376 --- [ Thread-7] .SchemaDropperImpl$DelayedDropActionImpl : HHH000477: Starting delayed evictData of schema as part of SessionFactory shut-down'2019-12-02 23:58:35.630 INFO 24376 --- [ Thread-5] .SchemaDropperImpl$DelayedDropActionImpl : HHH000477: Starting delayed evictData of schema as part of SessionFactory shut-down'2019-12-02 23:58:35.637 INFO 24376 --- [ Thread-5] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated...2019-12-02 23:58:35.642 INFO 24376 --- [ Thread-5] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed.2019-12-02 23:58:35.733 ERROR 24376 --- [ Thread-7] .SchemaDropperImpl$DelayedDropActionImpl : HHH000478: Unsuccessful: drop table event if exists2019-12-02 23:58:35.734 INFO 24376 --- [ Thread-7] com.zaxxer.hikari.HikariDataSource : HikariPool-2 - Shutdown initiated...2019-12-02 23:58:35.739 INFO 24376 --- [ Thread-7] com.zaxxer.hikari.HikariDataSource : HikariPool-2 - Shutdown completed.&gt; Task :asciidoctor NO-SOURCE&gt; Task :bootJar&gt; Task :jar SKIPPED&gt; Task :assemble&gt; Task :check&gt; Task :buildBUILD SUCCESSFUL in 18s5 actionable tasks: 5 executed오후 11:58:36: Task execution finished 'build'. cli를 들여다보니, 위와 같이 노출이 되는데 자세히 들여다보면 &gt; Task :asciidoctor NO-SOURCE 가 있습니다. 의존성문제인줄알고 버전도 변경 하여 보고 build.gradle 파일의 코드가 잘못되었거나,버전이 올라가면서 변경점이 있는지 체크해보았으나 다른점이 없어 검색을 하였더니asciidoctor sourceDirectory가 Maven 플러그인에서는 src/main/asciidoc이지만, Gradle 플러그인은 sourceDirectory가 /src/docs/asciidoc 였습니다.또한 Spring-REST-Docs에 의해 생성되는 경로도 아래 이미지와 같이 달랐습니다 Maven을 사용해 본 적이 없어서 gradle과 플러그인도 동일할줄 알았는데,빌드 결과물도 다른 디렉토리에 생성되고 실행가능한 명령어들도 다른것을 알 수 있었습니다. 참고자료 Github - asciidoctor Maven Plugin Docs - asciidoctor Gradle Plugin Docs - Spring REST Docs#Generating Documentation Snippets","link":"/2019/12/04/spring-rest-docs-with-gradle-not-working-html5/"},{"title":"[Java] Spring AOP 에서 Custom Exception 사용하기","text":"Spring AOP에서 Custom Exception 사용하기Spring AOP는 CglibAopProxy 클래스를 이용하여 동작합니다. 아래 코드와 같이 super.process() 를 try-catch로 처리하고 있고, Runtime Exception은 exception 을 그대로 던질 수 있기 때문에 Custom Exception은 Exception 클래스가 아니라 RuntimeException을 상속받아서 사용해야 합니다 1234567891011121314151617181920212223242526@Override@Nullablepublic Object proceed() throws Throwable { try { return super.proceed(); } catch (RuntimeException ex) { throw ex; } catch (Exception ex) { if (ReflectionUtils.declaresException(getMethod(), ex.getClass()) || KotlinDetector.isKotlinType(getMethod().getDeclaringClass())) { // Propagate original exception if declared on the target method // (with callers expecting it). Always propagate it for Kotlin code // since checked exceptions do not have to be explicitly declared there. throw ex; } else { // Checked exception thrown in the interceptor but not declared on the // target method signature -&gt; apply an UndeclaredThrowableException, // aligned with standard JDK dynamic proxy behavior. throw new UndeclaredThrowableException(ex); } }}","link":"/2022/08/10/springboot-spring-aop-%EC%97%90%EC%84%9C-custom-exception-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"SSL Connection Error 발생","text":"12[root@aaaaa ~]# curl -XGET {{링크}}curl: (35) SSL connect error 원인 Curl 버전이 낮아서 발생하는 문제 해결방법 패키지를 업데이트 할 수 있을 때1$ yum update -y nss curl libcurl 패키지를 업데이트 할 수 없을 때-1 을 파라미터로 넣어주면 해결 가능하다. (https://github.com/userify/shim/issues/25) 1$ curl -XGET {{링크}} -k -1 참고 자료 http://www.kwangsiklee.com/2017/07/문제해결-centos-curl-ssl-connect-error/ https://wwwnghks.tistory.com/62","link":"/2020/11/21/ssl-connection-error/"},{"title":"［Node.js］Express.js로 NodeJS 시작하기","text":"express 제너레이터 설치1npm install express-generator ejs 템플릿을 이용하여 myapp 디렉토리에 생성1express myapp --view=ejs myapp 디렉토리로 이동하여 npm install(패키지 설치)1$ cd myapp &amp; npm install 서버 실행1$ npm start POST전송시 필요한 body-parser와 express-session 설치1$ npm install body-parser express-session 기존에는 NodeJS에서 POST 요청 데이터를 추출 할 수 있도록 하기 위하여 bodyParser를 설치해야 했는데 express-generator에 추가 되었다","link":"/2018/03/11/start-nodejs/"},{"title":"VSCode Git Private Key 오류","text":"1Git: git@github.com: Permission denied (publickey). 위와 같은 오류가 vscode 에서 발생하였습니다. 분명 터미널에서는 이슈가 없었는데, vscode에서만 이슈가 발생하였습니다. ssh key에 passphrase를 넣어주었는데, vscode에서는 설정하는 구간이 없었고, 이 부분이 문제가 되는것 같아 설정을 찾아보았으나 설정하는 영역이 따로 없는것 같아 구글링을 해보았는데 아직 기능으로 제공하고 있지 않은것 같았습니다. 현재 해당 이슈 https://github.com/microsoft/vscode/issues/13680 로 등록되어 있습니다. 이슈 코멘트 확인중 https://github.com/microsoft/vscode/issues/13680#issuecomment-1192145377 이 코멘트를 보았는데, git repo 설정을 git@github.com:hodory/source.hodory.github.io.git 가 아닌, https://github.com/hodory/source.hodory.github.io.git 와 같이 적용하면 되는 방법이 있었습니다. 명령어로는 아래와 같이 설정하면 ssh 방식이 아닌 https 방식으로 처리하기때문에 공개키를 등록 했을 경우 정상적으로 동작하는것을 확인 할 수 있었습니다. 1$ git remote set-url origin https://github.com/hodory/source.hodory.github.io.git","link":"/2022/08/10/vscode-git-private-key-%EC%98%A4%EB%A5%98/"},{"title":"［VueJS］vue.js에서 이벤트 버스 사용하기","text":"MPA(Multi Page Application)에서 Vue를 적용 시키던중 부모-자식간의 관계가 아닌 컴포넌트 간의 동작에 따른 데이터 변화와 이벤트 처리가 필요해졌습니다. 주로 공통 데이터를 다루기 위해 사용하는 부분이라 Vuex를 써볼까도 했지만, Vuex 튜토리얼에서 앱이 단순하다면 Vuex없이는 괜찮을 것입니다. 간단한 글로벌 이벤트 버스만 있으면됩니다 라는 글귀를 읽고, 글로벌 이벤트 버스를 사용하자로 마음을 굳혔습니다. 아래와 같이 공통으로 사용할 이벤트버스 js 파일을 생성합니다.Vue EventBus 객체를 생성하여 export 하여 다른 파일에서도 로드하여 사용 할 수 있도록 합니다. 1234// /js/eventBus.jsimport Vue from 'vue'const EventBus = new Vue();export default EventBus; 그 후 해당 이벤트 버스를 사용할 컴포넌트들에서 eventBus.js를 import 하여 아래와 같이 사용했습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/******** /js/Button.vue********/&lt;template&gt; &lt;button @click.prevent=&quot;onClickButton&quot;&gt;Click Me&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import EventBus from &quot;./eventBus.js&quot;;export default { props: ['code', 'title'], methods: { onClickButton() { EventBus.$emit(&quot;onModalButtonClick&quot;, this.code, this.title) } } }&lt;/script&gt;/******** /js/Modal.vue********/&lt;template&gt; &lt;div id=&quot;myModal&quot; class=&quot;modal&quot; v-show=&quot;_isShow&quot;&gt; ... &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import EventBus from './eventBus.js';export default { data() { return { _isShow: false, code: null, title: null, } }, mounted() { EventBus.$on(&quot;onModalButtonClick&quot;, (code, title) =&gt; { this.code = code; this.title = title; this._isShow = true; }); }}... &lt;/script&gt; 실제로는 위의 코드보다 복잡했지만, 예시에 불필요한 부분은 제거하였습니다.","link":"/2018/08/27/vuejs-eventbus/"},{"title":"［PHP］ PSR(PHP Standards Recommendations)이란?","text":"PSR이란?PHP Standards Recommendations의 약자로 PHP-FIG(PHP-FrameWork Interop Group)에서 만든 표준 권고안입니다. PSR-0 PSR-1 PSR-2 PSR-3 PSR-4 작성예정 목록 PSR-6 PSR-7 PSR-11 PSR-13 PSR-15 PSR-16 PSR-0 (DEPRECATED) : Autoloading Standard오토로딩 표준으로 PSR-4가 제정되며 DEPRECATED 되었습니다. \\&lt;Vendor Name&gt;\\(&lt;NameSpace&gt;\\)*&lt;Class Name&gt;의 구조를 따릅니다. 각 네임스페이스는 (&quot;Vendor Name&quot;)이 최상위 네임스페이스로 있어야합니다. 각 네임스페이스는 원하는 만큼 하위 네임스페이스를 가질 수 있습니다. 각 네임스페이스 구분자는 파일시스템에서 로딩될때 DIRECTORY_SEPARATOR로 변환됩니다. 클래스명의 각 _ 문자는 DIRECTORY_SEPARATOR로 변환됩니다. 기타 자세한 사항은 PSR-0에서 확인 가능합니다. Example)\\Doctrine\\Commone\\IsolatedClassLoader=&gt;/path/to/project/lib/vendor/Doctrine/Common/IsolatedClassLoader.php\\Symfony\\Core\\Request=&gt;/path/to/project/lib/vendor/Symfony/Core/Request.php PSR-1 : Basic Coding StandardPHP 코드를 공유하는데 있어 기술적 상호 운용성을 위해 고려 해야 할 표준 코딩 가이드입니다. &lt;?php 와 &lt;?= 태그만 사용해야합니다. PHP 코드에는 BOM(Byte Order Mark) 없이 UTF-8로만 사용해야합니다. 네임스페이스와 클래스는 PSR(PSR-0, PSR-4)의 오토로딩을 따라야합니다. 클래스명은 StudlyCaps 와 같이 첫글자를 대문자로 합니다. 12345678910&lt;?php// PHP 5.3 이후 버전namespace Vendor\\Model;class Foo{}// PHP 5.3 이전 버전class Vendor_Model_Foo{} 상수는 _를 구분자로 대문자로 선언해야합니다. ex)const CURRENT_VERSION = 1.0; 프로퍼티명에 대한 규칙은 정해져 있지않으나, 스코프에서 일관적이어야합니다. 메소드는 카멜케이스를 사용해야합니다. ex)camelCase() PSR-2 : Coding Style GuidePSR-1의 확장으로 표준 코딩 스타일 가이드를 다룹니다. PSR-1을 따라야합니다. 들여쓰기 할때는 탭을 사용하지 않고 스페이스 4개를 사용합니다. 라인 수에 대한 엄격한 제한은 아니지만, 한 줄에는 120자 이하, 라인 수는 80개 이하로 작성합니다. namespace선언과 use 선언들 후에는 한줄을 띄워 작성합니다. 클래스와 메소드들의 여는 괄호는 다음줄에 작성하고, 닫는 괄호는 내용이 끝난 다음 줄에 작성합니다. ex) 12345678910111213&lt;?phpnamespace Vendor\\Package;use BazClass as Baz;use OtherVendor\\OtherPackage\\BazClass;class TestClass extends Baz{ public function alert($msg) { echo $msg; }} 모든 프로퍼티와 메소드는 접근제어자가 선언되어야합니다. abstract와 final 키워드는 접근제어자 이전에 선언되고, static 키워드는 접근제어자 이후에 선언되어야합니다. 제어문은 사이에 스페이스가 있어야합니다. 메소드와 함수호출은 그렇지 않습니다. ex) 1234567&lt;?phppublic function Foo($a, $b){ if ($a === $b) { echo &quot;equal&quot;; }}Foo(1, 2); PHP 파일은 빈 줄로 끝나야 하며, PHP로만 이루어진 파일은 닫는 태그인 ?&gt;를 생략해야합니다. PSR-3 : Logger Interface로깅 라이브러리의 공통적인 인터페이스를 명세합니다.라이브러리가 Psr\\Log\\LoggerInterface의 객체를 받아 간편하고 보편적인 방법으로 그것에 로그를 작성할 수 있도록 하는것이 목표입니다. 로거 인터페이스는 8개의 RFC 5424 레벨(debug, info, notice, warning, error, critical, alert, emergency)로 로그 작성을 하기 위한 메소드를 제공합니다. 9번째 메소드인 log는 첫번째 인자로 로그 레벨을 받고, 호출시 해당 레벨의 메소드를 호출하는것과 같은 결과를 가집니다. 해당 레벨의 메소드가 정의되어 있지 않는 경우, Psr\\Log\\InvalidArgumentException 에러를 보내야합니다. 모든 메소드는 string 형식의 메시지를 받거나, __toString() 처리 된 object를 받습니다. 컨텍스트에 주어진 값을 execption에 보내거나, php error나 warning, notice로 보내면 안됩니다. PSR-4 : Autoloader파일 경로를 통해 클래스를 오토로딩 하기위한 명세로, PSR-0를 포함하고 있습니다. class라는 용어는 클래스와 인터페이스, 트레이트 또는 다른 비슷한 구조들을 의미합니다. 정규화 된 클래스명의 형식은 다음을 따릅니다. \\&lt;NamespaceName&gt;(\\&lt;SubNamespaceNames&gt;)*\\&lt;ClassName&gt; 네임스페이스의 맨 처음은 “Vendor namespace”로 알려진것으로 시작합니다. 하나 이상의 서브네임스페이스명을 가집니다. 끝을 클래스명으로 작성 합니다. 소문자와 대문자의 조합을 혼합하여 작성할 수 있습니다. 대소문자를 구분하여 참조해야합니다.123456789&lt;?php// guzzle/src/ClientInterface.phpnamespace GuzzleHttp;use GuzzleHttp\\Exception\\GuzzleException;interface ClientInterface{} GuzzleHttp\\Exception\\GuzzleException은GuzzleHttp의 Base-Directory(src) 안에 있는 Exception\\GuzzleException.php에 위치합니다. 참고자료 PSR 공식문서 PHP 표준 권고(PSR) - 정광섭님","link":"/2018/04/17/what-is-psr/"},{"title":"［Java］해당 클래스의 서비스는 어디서 주입되나요??","text":"회사 업무중 스프링 서비스 코드 푸시를 하였습니다. 다른 팀원들에게 인터페이스를 파라미터로 정의한것은 확인하였는데,혹시 해당 컨트롤러에 주입은 어디에서 되나요?` 라는 질문을 들었습니다. 123456@RestController@Slf4j@RequiredArgsConstructorpublic class YourController { private final YourService yourService;} 위와같이 컨트롤러가 선언되어있었습니다.(물론 예제입니다.) 해당 클래스의 yourService에 YourServiceImpl(인터페이스 구현체)는 어떻게 주입이 되는걸까요? 아직도 스프링의 Application Context에 의한 DI(의존성 주입)가 저는 이해하기 어려운것 같습니다. 인터페이스의 구현체가 Service 어노테이션을 사용해서 Application Context에 의해 관리되는 Bean으로 등록되면, 해당 인터페이스에 자동으로 주입이됩니다(이 부분은 정말 신기하다고 생각합니다.제가 PHP 개발자이고, Laravel 프레임워크의 간결함과 모던함을 좋아하는데,이렇게까지 사용해본적이 없어,해당 프레임워크 뿐 아니라, 다른 언어나 프레임워크에서도 이와같이 주입이 되는지 확답을 쓸 수 없습니다.) 2019.06.09 추가 : 의존성 주입 의존성 주입(Dependency Injection, DI)은 프로그래밍에서 구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나이다. DI는 그저 디자인 패턴으로 어디에서든 구현 가능합니다.예시로 Laravel 5.8 - 자동주입과 같이다른 프레임워크에서도 스프링처럼 DI가 구현되어 있습니다. 일반적으로 해당 클래스에 구현체를 주입하기 위해서는 1234567891011121314151617181920212223242526272829303132333435363738/* * controller/YourController.java */@RestController@Slf4jpublic class YourController { private final YourService yourService; YouController(YourServiceImpl yourService) { this.yourService = yourService; }}---/* * service/YourService.java */public interface YourService { void whatYouCall();}---/* * service/impl/YourServiceImpl.java */@Servicepublic class YourServiceImpl implements YourService { @Override public void whatYouCall() { ... }} 위와 같이 구현했을것입니다. 클래스에 YourService라는 Interface를 프로퍼티로 선언한 후,해당 클래스에 YourSericeImpl을 주입하여 주는것이죠. 일반적으로 제가 생각하는 방식 또한 위와 같으나,Spring Framework는 해당 클래스에 Spring Bean을 주입해줍니다.(????) @Service 어노테이션을 이용하여 YourServiceImpl 클래스는 YourService의 구현체로 스프링어플리케이션의 빈에 등록이 됩니다.더불어, 스프링의 DI에 의해 YourService에 주입될 때는 해당 인터페이스의 구현체가 주입이 되게 되죠….. 같은 인터페이스의 구현체가 여러개일 경우는 어떻게 해야할까요? 1231. 위의 코드와 같이 구현 클래스를 주입 받는 걸로 바꾼다.2. `@Qualifier` 어노테이션을 이용한다.3. 스프링 빈의 네임 기반으로 해야한다. 제가 아는 방안은 위와 같은 세가지 방안입니다.(해당 부분을 가르쳐주신 @jhkim님 감사합니다) 위와 같은 개념을 이해하였다면 Lombok을 사용하여 해당 부분을 더 간소화 시킬 수 있습니다. @RequiredArgsConstructor은 어떻게 동작할까요? 해당 어노테이션 인터페이스의 주석을 보면 이와 같습니다. 12Generates a constructor with required arguments.Required arguments are final fields and fields with constraints such as {@code @NonNull}. 위의 주석에 따르면 final로 선언된 필드를 매개변수로 갖는 생성자를 자동 생성하여줍니다. 이전의 실수 - AllArgsConstructor의 잘못된 사용를 통해 배울 수 있던 부분입니다. @RequiredArgsConstructor 어노테이션과 함께 private final YourService yourService; 이와 같이 선언 할 경우,해당 코드는 컴파일시 아래와 같이 변환됩니다. 123456789@RestController@Slf4jpublic class YourController { private final YourService yourService; YouController(YourService yourService) { this.yourService = yourService; } } 위에서 본 코드와 유사해지는데요 이와 같이 Lombok 어노테이션은 생성자를 직접 만들어주기때문에 간결한 코드를 유지할 수 있습니다. 허나 위의 코드와 다른점은 YourService를 생성자의 파라미터 타입으로 주느냐, YourServiceImpl을 생성자 파라미터 타입으로 주느냐의 차이인데 위에 언급한바와 같이, 스프링 DI는 스프링 빈에 등록된 클래스를 주입합니다. 고로, YourService 타입이지만, YourServiceImpl 클래스가 해당 인터페이스를 구현한 구현체이며, 스프링빈으로 등록되어 있기 때문에,해당 클래스가 주입이됩니다. 포스팅의 잘못된 부분이 있다면 코멘트 또는 메일로 보내주시면부족한 부분은 보완하고, 틀린 부분은 수정하겠습니다아직 프로그래밍에 서툴어서 제가 이해한 개념과 다를 수 있는데, 많은 도움 부탁드리겠습니다. 끝으로 긴 글을 읽어주셔서 감사합니다.","link":"/2019/06/05/where-is-constructor-inject/"},{"title":"［ETC］Triple DES(3-DES)를 사용하지 않는 이유","text":"대학교 프로젝트에서 T-DES 암호화 알고리즘을 사용하여 소켓 기반 채팅 프로그램을 만든 적이 있습니다. DES 암호화 알고리즘을 보완하기위해 DES를 3번 수행하는 방식입니다. 그렇다면 왜 3DES 암호화 알고리즘의 사용이 줄어들었을까요? 암호화키가 DES 표준에 따라 56비트로 제한됩니다. AES(Advanced Encryption Standard)가 미국 표준으로 승인되어 AES 암호화 알고리즘이 더 많이 쓰이고 있습니다. 암호화를 세번 하면서 생기는 속도의 문제점 (AES가 훨씬 빠르다고 합니다.) 결론적으로 대칭키 암호화 알고리즘에서는 DES 암호화 알고리즘을 AES 암호화 알고리즘이 대체하게 되어 없어졌다 할 수 있습니다. 기존에는 SHA-2 알고리즘이 나와 없어진 줄 알았으나, SHA(Secure Hash Algorithm) Encryption(암호화)과 Hash(해쉬)는 다른 의미였습니다. Encryption(암호화)는 양방향 통신을 위해 특정 키를 가지고 복호화가 가능한 출력을 만들어 내는 것입니다. 대표적으로는 아래와 같이 있습니다. 대칭 암호화 DES(Data Encryption Standard) T-DES(Triple Data Encryption Standard) AES(Advanced Encryption Standard) 비대칭 암호화 RSA Hash(해시)는 임의의 길이의 입력을 고정된 길이의 출력으로 바꾸어주고, 복호화가 되지않아 원문을 알 수 없으나, 같은 입력은 같은 출력을 보장합니다. 대표적으로는 아래와 같이 있습니다. MD5(Message Digest) SHA(Secure Hash Algorithm) 참고자료 AES와 3DES의 차이점 대칭키 암호화 - AES, 3DES AES와 SHA 차이","link":"/2018/04/18/why-not-use-3des/"},{"title":"［ETC］시니어 개발자의 조건을 다시 읽고","text":"시니어 개발자의 조건이라는 포스팅을 2017년 초에 접하고,북마크에 담아두었다가 오늘에서야 다시 열어보게 되었습니다. 주요 키워드는 아래의 6가지였습니다. 시스템을 알고 서비스를 개발 해야한다. 기반기술을 중요시 해야한다. 적절한 엔지니어링을 택해야 한다. 클린코드가 모든 경우에 정답은 아니다. 애자일은 만능이 아니다. 오픈소스를 무분별하게 가져다 쓰는것 보다, 내부 동작 원리를 이해하고 용도에 맞게 사용해야한다.부족한 부분을 기여할 수 있는 프로슈머가 되어야 한다. 필자분께서 결론에 담아주신 내용이 가장 인상이 깊었습니다. 쥬니어와 시니어가 같은 일을 하고 같은 품질의 결과물을 만들어 낸다면나이는 많고 연봉은 높은 시니어를 반길 이유가 없다.시니어는 기반 기술에 대한 높은 이해를 바탕으로 쥬니어와는 다른 고품질의 결과물을 만들 수 있어야 한다.그리고 쥬니어가 성장하고 본받을 수 있는 높은 기술력을 갖추고 리딩할 수 있어야 한다.단순히 1년의 경력을 10번 반복한 시니어는 아무런 경쟁력이 없다. 2019년의 저는 얼마만큼 위의 여섯가지 키워드에 근접하였을까요 2019년의 저에 대해 되돌아 보았습니다. 시스템을 알고, 서비스를 개발 해야한다.기반기술을 중요시 해야한다.시스템에 대한 이해와 기반기술지식이 기존에도 부족하다 느꼈고,알고리즘과 자료구조를 이해하고 개발을 하는것의 중요성을 느끼기도 하고, 수없이 듣기도 하였습니다.하지만 이직을 하는 때가 아니면 들여다 보지 않는 자세를 매번 후회하면서도똑같은 실수를 반복하고 있는것 같아, 빠르게 이 잘못된 반복의 고리를 끊어야 할 것 같습니다. 적절한 엔지니어링을 택해야 한다.2019년은 AWS 서비스내에서 다양한 플랫폼들을 이용하여, 서버리스 아키텍쳐를 구현하여 보기도 했고,VueJS와 Webpack을 이용하여 주로 프론트에 적용 시키도 하였습니다. 어느정도 새로운 기술에 대해 욕심도 있었기때문에 다양한 것들을 사용 해보았던것 같습니다. 서버리스 아키텍쳐를 도입하였던 가장 큰 이유는 FaaS(Function as a Service)라는 새로운 개념에 흥미가 있어 알아보고 있었고,짧은 시간동안, 빠르게, 관리 할 필요 없이 등 제가 기억하고 있는 키워드들이 만들려던 서비스와 가장 적합하다 생각하여,서버리스 아키텍쳐를 도입하게 되었습니다. 프론트에서 VueJS를 사용했던 이유는 DOM을 핸들링하는 주체가 데이터인데,DOM에 너무 중심적인 코드를 작성을 하다보니다른사람들이 코드만으로는 해당 코드가 어떻게 동작할지 예측이 전혀 불가능한 코드를 작성하게 되어기존에 공부하여 본 경험이 있어 도입 하게 되었습니다. 제가 선택한 엔지니어링이 최선이였을까? 라는 질문에는 아니다 라고 확실하게 대답할 수 있고,다른 누군가에게는 오버엔지니어링이다 라는 말을 들을 수 있을 것 같습니다. 클린코드가 모든 경우에 정답은 아니다.아직까지 클린코드라는 책을 읽지 못하여, 이 부분을 답할 수 없습니다…. 애자일은 만능이 아니다.현재 팀내에서 애자일을 지향하고 있으나, 애자일하게 흘러가기 힘든 상황도 얼마든지 존재할 수 있음을 느끼고 있습니다. 이상적인 개념이나, 항상 변수가 생겨 현재 진행하고 있는 스프린트도 지켜지지 않는 경우가 많았었습니다. 추구할 수 있으나 이것에 얽매이지 않고, 유연하게 대처하고 있는가?에 대해서는 그럴때도 있고 아닐때도 있다 인것 같습니다. 오픈소스에 대해 프로슈머가 되어야 한다.다양한 오픈 소스를 가져다 사용하고 있고, 오픈 소스에 기여하고자 하는 마음도 가지고 있습니다.기존에는 문서가 제대로 되어 있지 않을때, 코드를 사용하기 위해 내부 구현 코드를 보았다면근 3개월간은 사용하는 라이브러리들의 개발자들이 내부 구현 코드를 과연 어떻게 구현 해두었을까?라는 관심을 가지고내부 코드를 들여다보게 된 것 같습니다. 현재 가장 기여하고 싶은 프로젝트는 PHP Laravel Framework입니다.아무래도 실무에서 사용하였을때 부족한 부분을 찾기 가장 좋은 조건이고, 내부 동작에 대해서도 들여다 보게 될텐데아직까지 실무에 사용하여 본 적도 없고, 기본 동작정도만 사용 해 보았지,오히려 스프링 부트 프레임워크보다 더 조금 사용하여 본 프레임워크라 아쉬움이 큰 것 같습니다. 해당 글을 처음 접하였을때부터 필자 분께서 언급하신 단순히 1년의 경력을 10번 반복한 시니어가 되지 않아야겠다. 라고 생각 해왔지만항목들을 하나 하나씩 돌아보니, 더 많은 노력이 필요한 것 같습니다.","link":"/2019/06/18/%EC%8B%9C%EB%8B%88%EC%96%B4-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9D%98-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EB%8B%A4%EC%8B%9C-%EC%9D%BD%EA%B3%A0/"},{"title":"애드센스-테러를-당하다","text":"아침에 눈을 떠서 메일을 확인 하는데,구글 애드센스팀으로부터 아래와 같은 메일이 도착하였습니다. 애드센스 계정이 30일동안 정지 되었다는 메일이였는데,하루 수입이 $0.01도 안 됐기 때문에 그냥 그런가보다 했습니다. 그래도 왜 그럴까 싶어 알아보다가 GA를 확인해보니 해당 시간대에 155 세션이 잡혔고,모두 디바이스가 데스크탑인 국가 정보가 없는 경우 였습니다. 슬프게도 제 블로그는 일 조회수가 155가 안되기 때문에 이럴일이 없었죠….😂 애드센스 관리 페이지를 확인 하였을때도 이와 같이 무효 클릭: 직접 클릭 으로 정지를 당했습니다. 혹시나 애드센스 테러 라는 키워드로 구글에 검색을 해보았더니 유사 사례가 꽤나 있었습니다. 다른분들의 코멘트를 참조하여 이의제기는 신청 했지만, 메일에 기재되어 있듯이 이의제기가 받아 들여질거 같진 않습니다… 그래도 가끔 애드센스 눌리는 재미도 쏠쏠 했는데 아쉽습니다…","link":"/2019/07/30/%EC%95%A0%EB%93%9C%EC%84%BC%EC%8A%A4-%ED%85%8C%EB%9F%AC%EB%A5%BC-%EB%8B%B9%ED%95%98%EB%8B%A4/"}],"tags":[{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Laravel","slug":"Laravel","link":"/tags/Laravel/"},{"name":"Eloquent","slug":"Eloquent","link":"/tags/Eloquent/"},{"name":"ORM","slug":"ORM","link":"/tags/ORM/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Retrospection","slug":"Retrospection","link":"/tags/Retrospection/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"Conference","slug":"Conference","link":"/tags/Conference/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"PHPUnit","slug":"PHPUnit","link":"/tags/PHPUnit/"},{"name":"NOTION","slug":"NOTION","link":"/tags/NOTION/"},{"name":"GITHUB-ACTION","slug":"GITHUB-ACTION","link":"/tags/GITHUB-ACTION/"},{"name":"Notion","slug":"Notion","link":"/tags/Notion/"},{"name":"Composer","slug":"Composer","link":"/tags/Composer/"},{"name":"Packagist","slug":"Packagist","link":"/tags/Packagist/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"GCP","slug":"GCP","link":"/tags/GCP/"},{"name":"GAE","slug":"GAE","link":"/tags/GAE/"},{"name":"NuxtJS","slug":"NuxtJS","link":"/tags/NuxtJS/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"도커","slug":"도커","link":"/tags/%EB%8F%84%EC%BB%A4/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ES5","slug":"ES5","link":"/tags/ES5/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"ES5 vs ES6","slug":"ES5-vs-ES6","link":"/tags/ES5-vs-ES6/"},{"name":"Netlify","slug":"Netlify","link":"/tags/Netlify/"},{"name":"V8","slug":"V8","link":"/tags/V8/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"DataBase","slug":"DataBase","link":"/tags/DataBase/"},{"name":"postgresql","slug":"postgresql","link":"/tags/postgresql/"},{"name":"pgsql","slug":"pgsql","link":"/tags/pgsql/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"pgSQL vs MySQL","slug":"pgSQL-vs-MySQL","link":"/tags/pgSQL-vs-MySQL/"},{"name":"str_pad","slug":"str-pad","link":"/tags/str-pad/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"LogSystem","slug":"LogSystem","link":"/tags/LogSystem/"},{"name":"ERROR","slug":"ERROR","link":"/tags/ERROR/"},{"name":"INI_SET","slug":"INI-SET","link":"/tags/INI-SET/"},{"name":"PHP5","slug":"PHP5","link":"/tags/PHP5/"},{"name":"PHP4","slug":"PHP4","link":"/tags/PHP4/"},{"name":"annotation","slug":"annotation","link":"/tags/annotation/"},{"name":"Lombok","slug":"Lombok","link":"/tags/Lombok/"},{"name":"Annotation","slug":"Annotation","link":"/tags/Annotation/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"VSCODE","slug":"VSCODE","link":"/tags/VSCODE/"},{"name":"VueJS","slug":"VueJS","link":"/tags/VueJS/"},{"name":"PSR","slug":"PSR","link":"/tags/PSR/"},{"name":"Etc.","slug":"Etc","link":"/tags/Etc/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"회고록","slug":"회고록","link":"/tags/%ED%9A%8C%EA%B3%A0%EB%A1%9D/"}],"categories":[{"name":"PHP","slug":"PHP","link":"/categories/PHP/"},{"name":"ETC","slug":"ETC","link":"/categories/ETC/"},{"name":"AWS","slug":"ETC/AWS","link":"/categories/ETC/AWS/"},{"name":"Algorithm","slug":"ETC/Algorithm","link":"/categories/ETC/Algorithm/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"PHPUnit","slug":"PHP/PHPUnit","link":"/categories/PHP/PHPUnit/"},{"name":"Retrospection","slug":"ETC/Retrospection","link":"/categories/ETC/Retrospection/"},{"name":"NOTION","slug":"ETC/NOTION","link":"/categories/ETC/NOTION/"},{"name":"Notion","slug":"ETC/Notion","link":"/categories/ETC/Notion/"},{"name":"Conference","slug":"ETC/AWS/Conference","link":"/categories/ETC/AWS/Conference/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"GCP","slug":"ETC/GCP","link":"/categories/ETC/GCP/"},{"name":"Docker","slug":"ETC/Docker","link":"/categories/ETC/Docker/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"GITHUB-ACTION","slug":"ETC/NOTION/GITHUB-ACTION","link":"/categories/ETC/NOTION/GITHUB-ACTION/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Database","slug":"ETC/Database","link":"/categories/ETC/Database/"},{"name":"Zapier","slug":"ETC/Notion/Zapier","link":"/categories/ETC/Notion/Zapier/"},{"name":"Retrospection","slug":"ETC/AWS/Conference/Retrospection","link":"/categories/ETC/AWS/Conference/Retrospection/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"NodeJS","slug":"Javascript/NodeJS","link":"/categories/Javascript/NodeJS/"},{"name":"VSCODE","slug":"VSCODE","link":"/categories/VSCODE/"},{"name":"Vue.js","slug":"Javascript/Vue-js","link":"/categories/Javascript/Vue-js/"},{"name":"회고록","slug":"ETC/회고록","link":"/categories/ETC/%ED%9A%8C%EA%B3%A0%EB%A1%9D/"},{"name":"Netlify","slug":"Hexo/Netlify","link":"/categories/Hexo/Netlify/"},{"name":"SpringBoot","slug":"Java/SpringBoot","link":"/categories/Java/SpringBoot/"}],"pages":[{"title":"","text":"importScripts('https://cdn.onesignal.com/sdks/OneSignalSDK.js');","link":"/OneSignalSDKUpdaterWorker.js"},{"title":"","text":"importScripts('https://cdn.onesignal.com/sdks/OneSignalSDK.js');","link":"/OneSignalSDKWorker.js"},{"title":"","text":"{\"gcm_sender_id\":\"482941778795\",\"gcm_sender_id_comment\":\"Do not change the GCM Sender ID\"}","link":"/manifest.json"},{"title":"","text":"","link":"/about/index.html"}]}