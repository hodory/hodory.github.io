<!doctype html><html lang=ko><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>[PHP] Array And Class Object Performance Test - Web Developer Hodory</title><meta name=Description content><meta property="og:title" content="[PHP] Array And Class Object Performance Test"><meta property="og:description" content="PHP Dynamic Array Class With Constructor Class With Setter Illuminate\Support\Collection Collection + Class Based Collection Test Link https://3v4l.org/h08dj/perf https://3v4l.org/CU0MC/perf https://3v4l.org/IqmsA/perf 코드가 너무 길어서 테스트 불가 코드가 너무 길어서 테스트 불가 Memory Peak Memory Peak Usage: 536 MB Memory Peak Usage: 254 MB Memory Peak Usage: 254 MB Memory Peak Usage: 658 MB Memory Peak Usage: 660 MB Execution Time Execution Time: 2.32 seconds Execution Time: 3.38 seconds Execution Time: 4.25 seconds Execution Time: 3.55 seconds Execution Time: 5.96 seconds Code <?php ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); $start"><meta property="og:type" content="article"><meta property="og:url" content="http://blog.hodory.dev/2024/12/15/php-array-and-class-object-performance-test/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-15T15:00:00+00:00"><meta property="article:modified_time" content="2024-12-15T15:00:00+00:00"><meta property="og:site_name" content="Web Developer Hodory"><meta name=twitter:card content="summary"><meta name=twitter:title content="[PHP] Array And Class Object Performance Test"><meta name=twitter:description content="PHP Dynamic Array Class With Constructor Class With Setter Illuminate\Support\Collection Collection + Class Based Collection Test Link https://3v4l.org/h08dj/perf https://3v4l.org/CU0MC/perf https://3v4l.org/IqmsA/perf 코드가 너무 길어서 테스트 불가 코드가 너무 길어서 테스트 불가 Memory Peak Memory Peak Usage: 536 MB Memory Peak Usage: 254 MB Memory Peak Usage: 254 MB Memory Peak Usage: 658 MB Memory Peak Usage: 660 MB Execution Time Execution Time: 2.32 seconds Execution Time: 3.38 seconds Execution Time: 4.25 seconds Execution Time: 3.55 seconds Execution Time: 5.96 seconds Code <?php ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); $start"><meta name=application-name content="Web Developer Hodory"><meta name=apple-mobile-web-app-title content="Web Developer Hodory"><meta name=theme-color content="#f8f8f8"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2860780921894189" crossorigin=anonymous></script><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=canonical href=http://blog.hodory.dev/2024/12/15/php-array-and-class-object-performance-test/><link rel=prev href=http://blog.hodory.dev/2022/08/11/vscode-git-private-key-%EC%98%A4%EB%A5%98/><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/color.css><link rel=stylesheet href=/css/style.min.css><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/fontawesome-free/all.min.css><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload as=style onload='this.onload=null,this.rel="stylesheet"' href=/lib/animate/animate.min.css><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"[PHP] Array And Class Object Performance Test","inLanguage":"ko","mainEntityOfPage":{"@type":"WebPage","@id":"http://blog.hodory.dev/2024/12/15/php-array-and-class-object-performance-test/"},"genre":"posts","wordcount":35022,"url":"http://blog.hodory.dev/2024/12/15/php-array-and-class-object-performance-test/","datePublished":"2024-12-15T15:00:00+00:00","dateModified":"2024-12-15T15:00:00+00:00","publisher":{"@type":"Organization","name":"hodory"},"author":{"@type":"Person","name":"hodory"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>function setTheme(e){document.body.setAttribute("theme",e),document.documentElement.style.setProperty("color-scheme",e==="light"?"light":"dark"),window.theme=e,window.isDark=window.theme!=="light"}function saveTheme(e){window.localStorage&&localStorage.setItem("theme",e)}function getMeta(e){const t=document.getElementsByTagName("meta");for(let n=0;n<t.length;n++)if(t[n].getAttribute("name")===e)return t[n];return""}if(window.localStorage&&localStorage.getItem("theme")){let e=localStorage.getItem("theme");e==="light"||e==="dark"||e==="black"?setTheme(e):setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")}else"auto"==="light"||"auto"==="dark"||"auto"==="black"?(setTheme("auto"),saveTheme("auto")):(saveTheme("auto"),setTheme(window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"));let metaColors={light:"#f8f8f8",dark:"#252627",black:"#000000"};getMeta("theme-color").content=metaColors[document.body.getAttribute("theme")],window.switchThemeEventSet=new Set</script><div id=back-to-top></div><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Web Developer Hodory"><img class=logo loading=lazy src=/images/logo.png srcset="/images/logo.png, /images/logo.png 1.5x, /images/logo.png 2x" sizes=auto alt=/images/logo.png title=/images/logo.png>Web Developer Hodory</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/categories/>Categories </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-select" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
<select class=color-theme-select id=theme-select-desktop title="Switch Theme"><option value=light>Light</option><option value=dark>Dark</option><option value=black>Black</option><option value=auto>Auto</option></select></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Web Developer Hodory"><img class=logo loading=lazy src=/images/logo.png srcset="/images/logo.png, /images/logo.png 1.5x, /images/logo.png 2x" sizes=auto alt=/images/logo.png title=/images/logo.png>Web Developer Hodory</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>Posts</a><a class=menu-item href=/tags/ title>Tags</a><a class=menu-item href=/categories/ title>Categories</a><a href=javascript:void(0); class="menu-item theme-select" title="Switch Theme">
<i class="fas fa-adjust fa-fw"></i>
<select class=color-theme-select id=theme-select-mobile title="Switch Theme"><option value=light>Light</option><option value=dark>Dark</option><option value=black>Black</option><option value=auto>Auto</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto><nav id=TableOfContents></nav></div></div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC","true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">[PHP] Array And Class Object Performance Test</h1><div class=post-meta><div class=post-meta-line><span class=post-author><span class="author fas fa-user-circle fa-fw"></span><a href=/ title=Author rel=author class=author>hodory</a>
</span>&nbsp;<span class=post-category>included in </span>&nbsp;<span class=post-category>category <a href=/categories/php/><i class="far fa-folder fa-fw"></i>PHP</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2024-12-15>2024-12-15</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime=2024-12-15>2024-12-15</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;35022 words&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;70 minutes&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents></nav></div></div><div class=content id=content><table><thead><tr><th></th><th>PHP Dynamic Array</th><th>Class With Constructor</th><th>Class With Setter</th><th>Illuminate\Support\Collection</th><th>Collection + Class Based Collection</th></tr></thead><tbody><tr><td>Test Link</td><td><a href=https://3v4l.org/h08dj/perf target=_blank rel="noopener noreferrer">https://3v4l.org/h08dj/perf</a></td><td><a href=https://3v4l.org/CU0MC/perf target=_blank rel="noopener noreferrer">https://3v4l.org/CU0MC/perf</a></td><td><a href=https://3v4l.org/IqmsA/perf target=_blank rel="noopener noreferrer">https://3v4l.org/IqmsA/perf</a></td><td>코드가 너무 길어서 테스트 불가</td><td>코드가 너무 길어서 테스트 불가</td></tr><tr><td>Memory Peak</td><td>Memory Peak Usage: 536 MB</td><td>Memory Peak Usage: 254 MB</td><td>Memory Peak Usage: 254 MB</td><td>Memory Peak Usage: 658 MB</td><td>Memory Peak Usage: 660 MB</td></tr><tr><td>Execution Time</td><td>Execution Time: 2.32 seconds</td><td>Execution Time: 3.38 seconds</td><td>Execution Time: 4.25 seconds</td><td>Execution Time: 3.55 seconds</td><td>Execution Time: 5.96 seconds</td></tr><tr><td>Code</td><td>&lt;?php ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); $start = microtime(true); $product = []; for ($k = 0; $k &lt;= 1000; $k++) { $options = []; for ($j = 0; $j &lt;= 10; $j++) { $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItems[] = array( &rsquo;title&rsquo; => &lsquo;OptionItem&rsquo; . $i, &lsquo;description&rsquo; => &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, &lsquo;price&rsquo; => random_int(1000, 10000) ); } $options[] = array( &rsquo;title&rsquo; => &lsquo;Option&rsquo; . $j, &lsquo;description&rsquo; => &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, &lsquo;price&rsquo; => random_int(1000, 10000), &lsquo;items&rsquo; => $optionItems ); } $product[] = array( &rsquo;title&rsquo; => &lsquo;Product&rsquo; . $k, &lsquo;description&rsquo; => &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, &lsquo;price&rsquo; => random_int(1000, 10000), &lsquo;currency&rsquo; => &lsquo;USD&rsquo;, &lsquo;category&rsquo; => &lsquo;Category&rsquo; . $k, &lsquo;brand&rsquo; => &lsquo;Brand&rsquo; . $k, &lsquo;options&rsquo; => $options ); } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br>&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br>&rsquo;;</td><td>&lt;?php class Product { private string $title; private string $description; private int $price; private string $currency; private string $category; private string $brand; private array $options; /** * @param string $title * @param string $description * @param int $price * @param string $currency * @param string $category * @param string $brand * @param array $options */ public function __construct(string $title, string $description, int $price, string $currency, string $category, string $brand, array $options) { $this->title = $title; $this->description = $description; $this->price = $price; $this->currency = $currency; $this->category = $category; $this->brand = $brand; $this->options = $options; } /** * @return string */ public function getTitle(): string { return $this->title; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @return string */ public function getDescription(): string { return $this->description; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @return int */ public function getPrice(): int { return $this->price; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } /** * @return string */ public function getCurrency(): string { return $this->currency; } /** * @param string $currency */ public function setCurrency(string $currency): void { $this->currency = $currency; } /** * @return string */ public function getCategory(): string { return $this->category; } /** * @param string $category */ public function setCategory(string $category): void { $this->category = $category; } /** * @return string */ public function getBrand(): string { return $this->brand; } /** * @param string $brand */ public function setBrand(string $brand): void { $this->brand = $brand; } /** * @return array */ public function getOptions(): array { return $this->options; } /** * @param array $options */ public function setOptions(array $options): void { $this->options = $options; } } class Option { private string $title; private string $description; private int $price; private array $items; /** * @param string $title * @param string $description * @param int $price * @param array $items */ public function __construct(string $title, string $description, int $price, array $items) { $this->title = $title; $this->description = $description; $this->price = $price; $this->items = $items; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } /** * @param array $items */ public function setItems(array $items): void { $this->items = $items; } } class OptionItem { private string $title; private string $description; private int $price; /** * @param string $title * @param string $description * @param int $price */ public function __construct(string $title, string $description, int $price) { $this->title = $title; $this->description = $description; $this->price = $price; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } } $product = []; for ($k = 0; $k &lt;= 100; $k++) { $options = []; for ($j = 0; $j &lt;= 10; $j++) { $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItem = new OptionItem(title: &lsquo;OptionItem&rsquo; . $i, description: &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, price: random_int(1000, 10000)); $optionItems[] = $optionItem; } $option = new Option(title: &lsquo;Option&rsquo; . $j, description: &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, price: random_int(1000, 10000), items: $optionItems); $options[] = $option; } $product[] = new Product(title: &lsquo;Product&rsquo; . $k, description: &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, price: random_int(1000, 10000), currency: &lsquo;USD&rsquo;, category: &lsquo;Category&rsquo; . $k, brand: &lsquo;Brand&rsquo; . $k, options: $options); }</td><td>&lt;?php ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); class Product { private string $title; private string $description; private int $price; private string $currency; private string $category; private string $brand; private array $options; /** * @return string */ public function getTitle(): string { return $this->title; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @return string */ public function getDescription(): string { return $this->description; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @return int */ public function getPrice(): int { return $this->price; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } /** * @return string */ public function getCurrency(): string { return $this->currency; } /** * @param string $currency */ public function setCurrency(string $currency): void { $this->currency = $currency; } /** * @return string */ public function getCategory(): string { return $this->category; } /** * @param string $category */ public function setCategory(string $category): void { $this->category = $category; } /** * @return string */ public function getBrand(): string { return $this->brand; } /** * @param string $brand */ public function setBrand(string $brand): void { $this->brand = $brand; } /** * @return array */ public function getOptions(): array { return $this->options; } /** * @param array $options */ public function setOptions(array $options): void { $this->options = $options; } } class Option { private string $title; private string $description; private int $price; private array $items; /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } /** * @param array $items */ public function setItems(array $items): void { $this->items = $items; } } class OptionItem { private string $title; private string $description; private int $price; /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } } $start = microtime(true); $products = []; for ($k = 0; $k &lt;= 1000; $k++) { $product = new Product(); $product->setTitle(&lsquo;Product&rsquo; . $k); $product->setDescription(&lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;); $product->setPrice(random_int(1000, 10000)); $product->setCurrency(&lsquo;USD&rsquo;); $product->setCategory(&lsquo;Category&rsquo; . $k); $product->setBrand(&lsquo;Brand&rsquo; . $k); $options = []; for ($j = 0; $j &lt;= 10; $j++) { $option = new Option(); $option->setTitle(&lsquo;Option&rsquo; . $j); $option->setDescription(&lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;); $option->setPrice(random_int(1000, 10000)); $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItem = new OptionItem(); $optionItem->setTitle(&lsquo;Option Item&rsquo; . $i); $optionItem->setDescription(&lsquo;Option Item &rsquo; . $i . &rsquo; Description&rsquo;); $optionItem->setPrice(random_int(1000, 10000)); $optionItems[] = $optionItem; } $option->setItems($optionItems); $options[] = $option; } $product->setOptions($options); $products[] = $product; } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br>&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br>&rsquo;;</td><td>&lt;?php namespace Illuminate\Contracts\Support; ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); interface CanBeEscapedWhenCastToString { /** * Indicate that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); } ?> &lt;?php namespace Illuminate\Support\Traits; use Closure; use Illuminate\Support\HigherOrderWhenProxy; trait Conditionable { /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenParameter * @template TWhenReturnType * * @param (\Closure($this): TWhenParameter)|TWhenParameter|null $value * @param (callable($this, TWhenParameter): TWhenReturnType)|null $callback * @param (callable($this, TWhenParameter): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return new HigherOrderWhenProxy($this); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))->condition($value); } if ($value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessParameter * @template TUnlessReturnType * * @param (\Closure($this): TUnlessParameter)|TUnlessParameter|null $value * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $callback * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return (new HigherOrderWhenProxy($this))->negateConditionOnCapture(); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))->condition(! $value); } if (! $value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } } ?> &lt;?php namespace Illuminate\Support; use ArgumentCountError; use \ArrayAccess; use Illuminate\Support\Traits\Macroable; use InvalidArgumentException; use Random\Randomizer; class Arr { use Macroable; /** * Determine whether the given value is array accessible. * * @param mixed $value * @return bool */ public static function accessible($value) { return is_array($value) || $value instanceof ArrayAccess; } /** * Add an element to an array using &ldquo;dot&rdquo; notation if it doesn&rsquo;t exist. * * @param array $array * @param string|int|float $key * @param mixed $value * @return array */ public static function add($array, $key, $value) { if (is_null(static::get($array, $key))) { static::set($array, $key, $value); } return $array; } /** * Collapse an array of arrays into a single array. * * @param iterable $array * @return array */ public static function collapse($array) { $results = []; foreach ($array as $values) { if ($values instanceof Collection) { $values = $values->all(); } elseif (! is_array($values)) { continue; } $results[] = $values; } return array_merge([], &mldr;$results); } /** * Cross join the given arrays, returning all possible permutations. * * @param iterable &mldr;$arrays * @return array */ public static function crossJoin(&mldr;$arrays) { $results = [[]]; foreach ($arrays as $index => $array) { $append = []; foreach ($results as $product) { foreach ($array as $item) { $product[$index] = $item; $append[] = $product; } } $results = $append; } return $results; } /** * Divide an array into two arrays. One with keys and the other with values. * * @param array $array * @return array */ public static function divide($array) { return [array_keys($array), array_values($array)]; } /** * Flatten a multi-dimensional associative array with dots. * * @param iterable $array * @param string $prepend * @return array */ public static function dot($array, $prepend = &lsquo;&rsquo;) { $results = []; foreach ($array as $key => $value) { if (is_array($value) && ! empty($value)) { $results = array_merge($results, static::dot($value, $prepend.$key.&rsquo;.&rsquo;)); } else { $results[$prepend.$key] = $value; } } return $results; } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @param iterable $array * @return array */ public static function undot($array) { $results = []; foreach ($array as $key => $value) { static::set($results, $key, $value); } return $results; } /** * Get all of the given array except for a specified array of keys. * * @param array $array * @param array|string|int|float $keys * @return array */ public static function except($array, $keys) { static::forget($array, $keys); return $array; } /** * Determine if the given key exists in the provided array. * * @param \ArrayAccess|array $array * @param string|int|float $key * @return bool */ public static function exists($array, $key) { if ($array instanceof Enumerable) { return $array->has($key); } if ($array instanceof ArrayAccess) { return $array->offsetExists($key); } if (is_float($key)) { $key = (string) $key; } return array_key_exists($key, $array); } /** * Return the first element in an array passing a given truth test. * * @template TKey * @template TValue * @template TFirstDefault * * @param iterable&lt;TKey, TValue> $array * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public static function first($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { if (empty($array)) { return value($default); } foreach ($array as $item) { return $item; } return value($default); } foreach ($array as $key => $value) { if ($callback($value, $key)) { return $value; } } return value($default); } /** * Return the last element in an array passing a given truth test. * * @param array $array * @param callable|null $callback * @param mixed $default * @return mixed */ public static function last($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { return empty($array) ? value($default) : end($array); } return static::first(array_reverse($array, true), $callback, $default); } /** * Take the first or last {$limit} items from an array. * * @param array $array * @param int $limit * @return array */ public static function take($array, $limit) { if ($limit &lt; 0) { return array_slice($array, $limit, abs($limit)); } return array_slice($array, 0, $limit); } /** * Flatten a multi-dimensional array into a single level. * * @param iterable $array * @param int $depth * @return array */ public static function flatten($array, $depth = INF) { $result = []; foreach ($array as $item) { $item = $item instanceof Collection ? $item->all() : $item; if (! is_array($item)) { $result[] = $item; } else { $values = $depth === 1 ? array_values($item) : static::flatten($item, $depth - 1); foreach ($values as $value) { $result[] = $value; } } } return $result; } /** * Remove one or many array items from a given array using &ldquo;dot&rdquo; notation. * * @param array $array * @param array|string|int|float $keys * @return void */ public static function forget(&$array, $keys) { $original = &$array; $keys = (array) $keys; if (count($keys) === 0) { return; } foreach ($keys as $key) { // if the exact key exists in the top-level, remove it if (static::exists($array, $key)) { unset($array[$key]); continue; } $parts = explode(&rsquo;.&rsquo;, $key); // clean up before each pass $array = &$original; while (count($parts) > 1) { $part = array_shift($parts); if (isset($array[$part]) && static::accessible($array[$part])) { $array = &$array[$part]; } else { continue 2; } } unset($array[array_shift($parts)]); } } /** * Get an item from an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|int|null $key * @param mixed $default * @return mixed */ public static function get($array, $key, $default = null) { if (! static::accessible($array)) { return value($default); } if (is_null($key)) { return $array; } if (static::exists($array, $key)) { return $array[$key]; } if (! str_contains($key, &lsquo;.&rsquo;)) { return $array[$key] ?? value($default); } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($array) && static::exists($array, $segment)) { $array = $array[$segment]; } else { return value($default); } } return $array; } /** * Check if an item or items exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function has($array, $keys) { $keys = (array) $keys; if (! $array || $keys === []) { return false; } foreach ($keys as $key) { $subKeyArray = $array; if (static::exists($array, $key)) { continue; } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($subKeyArray) && static::exists($subKeyArray, $segment)) { $subKeyArray = $subKeyArray[$segment]; } else { return false; } } } return true; } /** * Determine if any of the keys exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function hasAny($array, $keys) { if (is_null($keys)) { return false; } $keys = (array) $keys; if (! $array) { return false; } if ($keys === []) { return false; } foreach ($keys as $key) { if (static::has($array, $key)) { return true; } } return false; } /** * Determines if an array is associative. * * An array is &ldquo;associative&rdquo; if it doesn&rsquo;t have sequential numerical keys beginning with zero. * * @param array $array * @return bool */ public static function isAssoc(array $array) { return ! array_is_list($array); } /** * Determines if an array is a list. * * An array is a &ldquo;list&rdquo; if all array keys are sequential integers starting from 0 with no gaps in between. * * @param array $array * @return bool */ public static function isList($array) { return array_is_list($array); } /** * Join all items using a string. The final items can use a separate glue string. * * @param array $array * @param string $glue * @param string $finalGlue * @return string */ public static function join($array, $glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return implode($glue, $array); } if (count($array) === 0) { return &lsquo;&rsquo;; } if (count($array) === 1) { return end($array); } $finalItem = array_pop($array); return implode($glue, $array).$finalGlue.$finalItem; } /** * Key an associative array by a field or using a callback. * * @param array $array * @param callable|array|string $keyBy * @return array */ public static function keyBy($array, $keyBy) { return Collection::make($array)->keyBy($keyBy)->all(); } /** * Prepend the key names of an associative array. * * @param array $array * @param string $prependWith * @return array */ public static function prependKeysWith($array, $prependWith) { return static::mapWithKeys($array, fn ($item, $key) => [$prependWith.$key => $item]); } /** * Get a subset of the items from the given array. * * @param array $array * @param array|string $keys * @return array */ public static function only($array, $keys) { return array_intersect_key($array, array_flip((array) $keys)); } /** * Select an array of values from an array. * * @param array $array * @param array|string $keys * @return array */ public static function select($array, $keys) { $keys = static::wrap($keys); return static::map($array, function ($item) use ($keys) { $result = []; foreach ($keys as $key) { if (Arr::accessible($item) && Arr::exists($item, $key)) { $result[$key] = $item[$key]; } elseif (is_object($item) && isset($item->{$key})) { $result[$key] = $item->{$key}; } } return $result; }); } /** * Pluck an array of values from an array. * * @param iterable $array * @param string|array|int|null $value * @param string|array|null $key * @return array */ public static function pluck($array, $value, $key = null) { $results = []; [$value, $key] = static::explodePluckParameters($value, $key); foreach ($array as $item) { $itemValue = data_get($item, $value); // If the key is &ldquo;null&rdquo;, we will just append the value to the array and keep // looping. Otherwise we will key the array using the value of the key we // received from the developer. Then we&rsquo;ll return the final array form. if (is_null($key)) { $results[] = $itemValue; } else { $itemKey = data_get($item, $key); if (is_object($itemKey) && method_exists($itemKey, &lsquo;__toString&rsquo;)) { $itemKey = (string) $itemKey; } $results[$itemKey] = $itemValue; } } return $results; } /** * Explode the &ldquo;value&rdquo; and &ldquo;key&rdquo; arguments passed to &ldquo;pluck&rdquo;. * * @param string|array $value * @param string|array|null $key * @return array */ protected static function explodePluckParameters($value, $key) { $value = is_string($value) ? explode(&rsquo;.&rsquo;, $value) : $value; $key = is_null($key) || is_array($key) ? $key : explode(&rsquo;.&rsquo;, $key); return [$value, $key]; } /** * Run a map over each of the items in the array. * * @param array $array * @param callable $callback * @return array */ public static function map(array $array, callable $callback) { $keys = array_keys($array); try { $items = array_map($callback, $array, $keys); } catch (ArgumentCountError) { $items = array_map($callback, $array); } return array_combine($keys, $items); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TKey * @template TValue * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param array&lt;TKey, TValue> $array * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue> $callback * @return array */ public static function mapWithKeys(array $array, callable $callback) { $result = []; foreach ($array as $key => $value) { $assoc = $callback($value, $key); foreach ($assoc as $mapKey => $mapValue) { $result[$mapKey] = $mapValue; } } return $result; } /** * Run a map over each nested chunk of items. * * @template TKey * @template TValue * * @param array&lt;TKey, array> $array * @param callable(mixed&mldr;): TValue $callback * @return array&lt;TKey, TValue> */ public static function mapSpread(array $array, callable $callback) { return static::map($array, function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&mldr;$chunk); }); } /** * Push an item onto the beginning of an array. * * @param array $array * @param mixed $value * @param mixed $key * @return array */ public static function prepend($array, $value, $key = null) { if (func_num_args() == 2) { array_unshift($array, $value); } else { $array = [$key => $value] + $array; } return $array; } /** * Get a value from the array, and remove it. * * @param array $array * @param string|int $key * @param mixed $default * @return mixed */ public static function pull(&$array, $key, $default = null) { $value = static::get($array, $key, $default); static::forget($array, $key); return $value; } /** * Convert the array into a query string. * * @param array $array * @return string */ public static function query($array) { return http_build_query($array, &lsquo;&rsquo;, &lsquo;&&rsquo;, PHP_QUERY_RFC3986); } /** * Get one or a specified number of random values from an array. * * @param array $array * @param int|null $number * @param bool $preserveKeys * @return mixed * * @throws \InvalidArgumentException */ public static function random($array, $number = null, $preserveKeys = false) { $requested = is_null($number) ? 1 : $number; $count = count($array); if ($requested > $count) { throw new InvalidArgumentException( &ldquo;You requested {$requested} items, but there are only {$count} items available.&rdquo; ); } if (empty($array) || (! is_null($number) && $number &lt;= 0)) { return is_null($number) ? null : []; } $keys = (new Randomizer)->pickArrayKeys($array, $requested); if (is_null($number)) { return $array[$keys[0]]; } $results = []; if ($preserveKeys) { foreach ($keys as $key) { $results[$key] = $array[$key]; } } else { foreach ($keys as $key) { $results[] = $array[$key]; } } return $results; } /** * Set an array item to a given value using &ldquo;dot&rdquo; notation. * * If no key is given to the method, the entire array will be replaced. * * @param array $array * @param string|int|null $key * @param mixed $value * @return array */ public static function set(&$array, $key, $value) { if (is_null($key)) { return $array = $value; } $keys = explode(&rsquo;.&rsquo;, $key); foreach ($keys as $i => $key) { if (count($keys) === 1) { break; } unset($keys[$i]); // If the key doesn&rsquo;t exist at this depth, we will just create an empty array // to hold the next value, allowing us to create the arrays to hold final // values at the correct depth. Then we&rsquo;ll keep digging into the array. if (! isset($array[$key]) || ! is_array($array[$key])) { $array[$key] = []; } $array = &$array[$key]; } $array[array_shift($keys)] = $value; return $array; } /** * Shuffle the given array and return the result. * * @param array $array * @return array */ public static function shuffle($array) { return (new Randomizer)->shuffleArray($array); } /** * Sort the array using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sort($array, $callback = null) { return Collection::make($array)->sortBy($callback)->all(); } /** * Sort the array in descending order using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sortDesc($array, $callback = null) { return Collection::make($array)->sortByDesc($callback)->all(); } /** * Recursively sort an array by keys and values. * * @param array $array * @param int $options * @param bool $descending * @return array */ public static function sortRecursive($array, $options = SORT_REGULAR, $descending = false) { foreach ($array as &$value) { if (is_array($value)) { $value = static::sortRecursive($value, $options, $descending); } } if (! array_is_list($array)) { $descending ? krsort($array, $options) : ksort($array, $options); } else { $descending ? rsort($array, $options) : sort($array, $options); } return $array; } /** * Recursively sort an array by keys and values in descending order. * * @param array $array * @param int $options * @return array */ public static function sortRecursiveDesc($array, $options = SORT_REGULAR) { return static::sortRecursive($array, $options, true); } /** * Conditionally compile classes from an array into a CSS class list. * * @param array $array * @return string */ public static function toCssClasses($array) { $classList = static::wrap($array); $classes = []; foreach ($classList as $class => $constraint) { if (is_numeric($class)) { $classes[] = $constraint; } elseif ($constraint) { $classes[] = $class; } } return implode(&rsquo; &lsquo;, $classes); } /** * Conditionally compile styles from an array into a style list. * * @param array $array * @return string */ public static function toCssStyles($array) { $styleList = static::wrap($array); $styles = []; foreach ($styleList as $class => $constraint) { if (is_numeric($class)) { $styles[] = Str::finish($constraint, &lsquo;;&rsquo;); } elseif ($constraint) { $styles[] = Str::finish($class, &lsquo;;&rsquo;); } } return implode(&rsquo; &lsquo;, $styles); } /** * Filter the array using the given callback. * * @param array $array * @param callable $callback * @return array */ public static function where($array, callable $callback) { return array_filter($array, $callback, ARRAY_FILTER_USE_BOTH); } /** * Filter items where the value is not null. * * @param array $array * @return array */ public static function whereNotNull($array) { return static::where($array, fn ($value) => ! is_null($value)); } /** * If the given value is not an array and not null, wrap it in one. * * @param mixed $value * @return array */ public static function wrap($value) { if (is_null($value)) { return []; } return is_array($value) ? $value : [$value]; } } ?> &lt;?php namespace Illuminate\Contracts\Support; interface Jsonable { /** * Convert the object to its JSON representation. * * @param int $options * @return string */ public function toJson($options = 0); } ?> &lt;?php namespace Illuminate\Contracts\Support; /** * @template TKey of array-key * @template TValue */ interface Arrayable { /** * Get the instance as an array. * * @return array&lt;TKey, TValue> */ public function toArray(); } ?> &lt;?php namespace Illuminate\Support\Traits; use BadMethodCallException; use ReflectionClass; use ReflectionMethod; trait Macroable { /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @param-closure-this static $macro * * @return void */ public static function macro($name, $macro) { static::$macros[$name] = $macro; } /** * Mix another object into the class. * * @param object $mixin * @param bool $replace * @return void * * @throws \ReflectionException */ public static function mixin($mixin, $replace = true) { $methods = (new ReflectionClass($mixin))->getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) { if ($replace || ! static::hasMacro($method->name)) { static::macro($method->name, $method->invoke($mixin)); } } } /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) { return isset(static::$macros[$name]); } /** * Flush the existing macros. * * @return void */ public static function flushMacros() { static::$macros = []; } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro->bindTo(null, static::class); } return $macro(&mldr;$parameters); } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro->bindTo($this, static::class); } return $macro(&mldr;$parameters); } } ?> &lt;?php namespace Illuminate\Support; use CachingIterator; use Countable; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use IteratorAggregate; use JsonSerializable; use \Traversable; /** * @template TKey of array-key * * @template-covariant TValue * * @extends \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue> * @extends \IteratorAggregate&lt;TKey, TValue> */ interface Enumerable extends Arrayable, Countable, IteratorAggregate, Jsonable, JsonSerializable { /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue>|iterable&lt;TMakeKey, TMakeValue>|null $items * @return static&lt;TMakeKey, TMakeValue> */ public static function make($items = []); /** * Create a new instance by invoking the callback a given amount of times. * * @param int $number * @param callable|null $callback * @return static */ public static function times($number, ?callable $callback = null); /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static */ public static function range($from, $to, $step = 1); /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue>|TWrapValue $value * @return static&lt;array-key, TWrapValue> */ public static function wrap($value); /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue>|static&lt;TUnwrapKey, TUnwrapValue> $value * @return array&lt;TUnwrapKey, TUnwrapValue> */ public static function unwrap($value); /** * Create a new instance with no items. * * @return static */ public static function empty(); /** * Get all items in the enumerable. * * @return array */ public function all(); /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null); /** * Get the median of a given key. * * @param string|array&lt;array-key, string>|null $key * @return float|int|null */ public function median($key = null); /** * Get the mode of a given key. * * @param string|array&lt;array-key, string>|null $key * @return array&lt;int, float|int>|null */ public function mode($key = null); /** * Collapse the items into a single enumerable. * * @return static&lt;int, mixed> */ public function collapse(); /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null); /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null); /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null); /** * Determine if an item exists in the enumerable. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null); /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null); /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue>|iterable&lt;TCrossJoinKey, TCrossJoinValue> &mldr;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&#187; */ public function crossJoin(&mldr;$lists); /** * Dump the collection and end the script. * * @param mixed &mldr;$args * @return never */ public function dd(&mldr;$args); /** * Dump the collection. * * @param mixed &mldr;$args * @return $this */ public function dump(&mldr;$args); /** * Get the items that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @return static */ public function diff($items); /** * Get the items that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback); /** * Get the items whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function diffAssoc($items); /** * Get the items whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback); /** * Get the items whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function diffKeys($items); /** * Get the items whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback); /** * Retrieve duplicate items. * * @param (callable(TValue): bool)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false); /** * Retrieve duplicate items using strict comparison. * * @param (callable(TValue): bool)|string|null $callback * @return static */ public function duplicatesStrict($callback = null); /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback); /** * Execute a callback over each nested chunk of items. * * @param callable $callback * @return static */ public function eachSpread(callable $callback); /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null); /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey> $keys * @return static */ public function except($keys); /** * Run a filter over each of the items. * * @param (callable(TValue): bool)|null $callback * @return static */ public function filter(?callable $callback = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenReturnType as null * * @param bool $value * @param (callable($this): TWhenReturnType)|null $callback * @param (callable($this): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value, ?callable $callback = null, ?callable $default = null); /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessReturnType * * @param bool $value * @param (callable($this): TUnlessReturnType) $callback * @param (callable($this): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value, callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null); /** * Filter items by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null); /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null); /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values); /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values); /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values); /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf>|array&lt;array-key, class-string&lt;TWhereInstanceOf&#187; $type * @return static&lt;TKey, TWhereInstanceOf> */ public function whereInstanceOf($type); /** * Get the first item from the enumerable passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue,TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null); /** * Get the first item by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null); /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static */ public function flatten($depth = INF); /** * Flip the values with their keys. * * @return static&lt;TValue, TKey> */ public function flip(); /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null); /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&#187; */ public function groupBy($groupBy, $preserveKeys = false); /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue> */ public function keyBy($keyBy); /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey> $key * @return bool */ public function has($key); /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key); /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string $value * @param string|null $glue * @return string */ public function implode($value, $glue = null); /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersect($items); /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback); /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersectAssoc($items); /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback); /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function intersectByKeys($items); /** * Determine if the collection is empty or not. * * @return bool */ public function isEmpty(); /** * Determine if the collection is not empty. * * @return bool */ public function isNotEmpty(); /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem(); /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;); /** * Get the keys of the collection items. * * @return static&lt;int, TKey> */ public function keys(); /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null); /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue> */ public function map(callable $callback); /** * Run a map over each nested chunk of items. * * @param callable $callback * @return static */ public function mapSpread(callable $callback); /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue> $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&#187; */ public function mapToDictionary(callable $callback); /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue> $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&#187; */ public function mapToGroups(callable $callback); /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue> $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue> */ public function mapWithKeys(callable $callback); /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue>|array&lt;TFlatMapKey, TFlatMapValue>) $callback * @return static&lt;TFlatMapKey, TFlatMapValue> */ public function flatMap(callable $callback); /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue> $class * @return static&lt;TKey, TMapIntoValue> */ public function mapInto($class); /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function merge($items); /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue>|iterable&lt;TKey, TMergeRecursiveValue> $items * @return static&lt;TKey, TValue|TMergeRecursiveValue> */ public function mergeRecursive($items); /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue>|iterable&lt;array-key, TCombineValue> $values * @return static&lt;TValue, TCombineValue> */ public function combine($values); /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function union($items); /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null); /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null); /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0); /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string $keys * @return static */ public function only($keys); /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage); /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return static&lt;int&lt;0, 1>, static&lt;TKey, TValue&#187; */ public function partition($key, $operator = null, $value = null); /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue> $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue> */ public function concat($source); /** * Get one or a specified number of items randomly from the collection. * * @param int|null $number * @return static&lt;int, TValue>|TValue * * @throws \InvalidArgumentException */ public function random($number = null); /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null); /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &mldr;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &mldr;$initial); /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replace($items); /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replaceRecursive($items); /** * Reverse items order. * * @return static */ public function reverse(); /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|callable(TValue,TKey): bool $value * @param bool $strict * @return TKey|bool */ public function search($value, $strict = false); /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false); /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false); /** * Shuffle the items in the collection. * * @return static */ public function shuffle(); /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static> */ public function sliding($size = 2, $step = 1); /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count); /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value); /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value); /** * Get a slice of items from the enumerable. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null); /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function split($numberOfGroups); /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null); /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null); /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static> */ public function chunk($size); /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue>): bool $callback * @return static&lt;int, static&lt;int, TValue&#187; */ public function chunkWhile(callable $callback); /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function splitIn($numberOfGroups); /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null); /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR); /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false); /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR); /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false); /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR); /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback); /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null); /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit); /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value); /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value); /** * Pass the collection to the given callback and then return it. * * @param callable(TValue): mixed $callback * @return $this */ public function tap(callable $callback); /** * Pass the enumerable to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback); /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue> $class * @return TPipeIntoValue */ public function pipeInto($class); /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable> $pipes * @return mixed */ public function pipeThrough($pipes); /** * Get the values of a given key. * * @param string|array&lt;array-key, string> $value * @param string|null $key * @return static&lt;array-key, mixed> */ public function pluck($value, $key = null); /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true); /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot(); /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false); /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null); /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue> */ public function values(); /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue> */ public function pad($size, $value); /** * Get the values iterator. * * @return \Traversable&lt;TKey, TValue> */ public function getIterator(): \Traversable; /** * Count the number of items in the collection. * * @return int */ public function count(): int; /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int> */ public function countBy($countBy = null); /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])->zip([4, 5, 6]); * => [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue>|iterable&lt;array-key, TZipValue> &mldr;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&#187; */ public function zip($items); /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue> */ public function collect(); /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed> */ public function toArray(); /** * Convert the object into something JSON serializable. * * @return mixed */ public function jsonSerialize(): mixed; /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0); /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING); /** * Convert the collection to its string representation. * * @return string */ public function __toString(); /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method); /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key); } ?> &lt;?php namespace Illuminate\Support\Traits; use BackedEnum; use CachingIterator; use Exception; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use Illuminate\Support\Arr; use Illuminate\Support\Collection; use Illuminate\Support\Enumerable; use Illuminate\Support\HigherOrderCollectionProxy; use InvalidArgumentException; use JsonSerializable; use \Traversable; use UnexpectedValueException; use UnitEnum; use WeakMap; /** * @template TKey of array-key * * @template-covariant TValue * * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $average * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $avg * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $contains * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $doesntContain * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $each * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $every * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $filter * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $first * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $flatMap * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $groupBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $keyBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $map * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $max * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $min * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $partition * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $percentage * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $reject * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $skipUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $skipWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $some * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $sortBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $sortByDesc * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $sum * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $takeUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $takeWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $unique * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $unless * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $until * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $when */ trait EnumeratesValues { use Conditionable; /** * Indicates that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @var bool */ protected $escapeWhenCastingToString = false; /** * The methods that can be proxied. * * @var array&lt;int, string> */ protected static $proxies = [ &lsquo;average&rsquo;, &lsquo;avg&rsquo;, &lsquo;contains&rsquo;, &lsquo;doesntContain&rsquo;, &rsquo;each&rsquo;, &rsquo;every&rsquo;, &lsquo;filter&rsquo;, &lsquo;first&rsquo;, &lsquo;flatMap&rsquo;, &lsquo;groupBy&rsquo;, &lsquo;keyBy&rsquo;, &lsquo;map&rsquo;, &lsquo;max&rsquo;, &lsquo;min&rsquo;, &lsquo;partition&rsquo;, &lsquo;percentage&rsquo;, &lsquo;reject&rsquo;, &lsquo;skipUntil&rsquo;, &lsquo;skipWhile&rsquo;, &lsquo;some&rsquo;, &lsquo;sortBy&rsquo;, &lsquo;sortByDesc&rsquo;, &lsquo;sum&rsquo;, &rsquo;takeUntil&rsquo;, &rsquo;takeWhile&rsquo;, &lsquo;unique&rsquo;, &lsquo;unless&rsquo;, &lsquo;until&rsquo;, &lsquo;when&rsquo;, ]; /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue>|iterable&lt;TMakeKey, TMakeValue>|null $items * @return static&lt;TMakeKey, TMakeValue> */ public static function make($items = []) { return new static($items); } /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue>|TWrapValue $value * @return static&lt;array-key, TWrapValue> */ public static function wrap($value) { return $value instanceof Enumerable ? new static($value) : new static(Arr::wrap($value)); } /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue>|static&lt;TUnwrapKey, TUnwrapValue> $value * @return array&lt;TUnwrapKey, TUnwrapValue> */ public static function unwrap($value) { return $value instanceof Enumerable ? $value->all() : $value; } /** * Create a new instance with no items. * * @return static */ public static function empty() { return new static([]); } /** * Create a new collection by invoking the callback a given amount of times. * * @template TTimesValue * * @param int $number * @param (callable(int): TTimesValue)|null $callback * @return static&lt;int, TTimesValue> */ public static function times($number, ?callable $callback = null) { if ($number &lt; 1) { return new static; } return static::range(1, $number) ->unless($callback == null) ->map($callback); } /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null) { $callback = $this->valueRetriever($callback); $reduced = $this->reduce(static function (&$reduce, $value) use ($callback) { if (! is_null($resolved = $callback($value))) { $reduce[0] += $resolved; $reduce[1]++; } return $reduce; }, [0, 0]); return $reduced[1] ? $reduced[0] / $reduced[1] : null; } /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null) { return $this->avg($callback); } /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null) { return $this->contains(&mldr;func_get_args()); } /** * Dump the given arguments and terminate execution. * * @param mixed &mldr;$args * @return never */ public function dd(&mldr;$args) { dd($this->all(), &mldr;$args); } /** * Dump the items. * * @param mixed &mldr;$args * @return $this */ public function dump(&mldr;$args) { dump($this->all(), &mldr;$args); return $this; } /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback) { foreach ($this as $key => $item) { if ($callback($item, $key) === false) { break; } } return $this; } /** * Execute a callback over each nested chunk of items. * * @param callable(&mldr;mixed): mixed $callback * @return static */ public function eachSpread(callable $callback) { return $this->each(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&mldr;$chunk); }); } /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null) { if (func_num_args() === 1) { $callback = $this->valueRetriever($key); foreach ($this as $k => $v) { if (! $callback($v, $k)) { return false; } } return true; } return $this->every($this->operatorForWhere(&mldr;func_get_args())); } /** * Get the first item by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null) { return $this->first($this->operatorForWhere(&mldr;func_get_args())); } /** * Get a single key&rsquo;s value from the first matching item in the collection. * * @template TValueDefault * * @param string $key * @param TValueDefault|(\Closure(): TValueDefault) $default * @return TValue|TValueDefault */ public function value($key, $default = null) { if ($value = $this->firstWhere($key)) { return data_get($value, $key, $default); } return value($default); } /** * Ensure that every item in the collection is of the expected type. * * @template TEnsureOfType * * @param class-string&lt;TEnsureOfType>|array&lt;array-key, class-string&lt;TEnsureOfType&#187; $type * @return static&lt;TKey, TEnsureOfType> * * @throws \UnexpectedValueException */ public function ensure($type) { $allowedTypes = is_array($type) ? $type : [$type]; return $this->each(function ($item, $index) use ($allowedTypes) { $itemType = get_debug_type($item); foreach ($allowedTypes as $allowedType) { if ($itemType === $allowedType || $item instanceof $allowedType) { return true; } } throw new UnexpectedValueException( sprintf(&ldquo;Collection should only include [%s] items, but &lsquo;%s&rsquo; found at position %d.&rdquo;, implode(&rsquo;, &lsquo;, $allowedTypes), $itemType, $index) ); }); } /** * Determine if the collection is not empty. * * @phpstan-assert-if-true TValue $this->first() * @phpstan-assert-if-true TValue $this->last() * * @phpstan-assert-if-false null $this->first() * @phpstan-assert-if-false null $this->last() * * @return bool */ public function isNotEmpty() { return ! $this->isEmpty(); } /** * Run a map over each nested chunk of items. * * @template TMapSpreadValue * * @param callable(mixed&mldr;): TMapSpreadValue $callback * @return static&lt;TKey, TMapSpreadValue> */ public function mapSpread(callable $callback) { return $this->map(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&mldr;$chunk); }); } /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue> $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&#187; */ public function mapToGroups(callable $callback) { $groups = $this->mapToDictionary($callback); return $groups->map([$this, &lsquo;make&rsquo;]); } /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue>|array&lt;TFlatMapKey, TFlatMapValue>) $callback * @return static&lt;TFlatMapKey, TFlatMapValue> */ public function flatMap(callable $callback) { return $this->map($callback)->collapse(); } /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue> $class * @return static&lt;TKey, TMapIntoValue> */ public function mapInto($class) { if (is_subclass_of($class, BackedEnum::class)) { return $this->map(fn ($value, $key) => $class::from($value)); } return $this->map(fn ($value, $key) => new $class($value, $key)); } /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null) { $callback = $this->valueRetriever($callback); return $this->map(fn ($value) => $callback($value)) ->filter(fn ($value) => ! is_null($value)) ->reduce(fn ($result, $value) => is_null($result) || $value &lt; $result ? $value : $result); } /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null) { $callback = $this->valueRetriever($callback); return $this->filter(fn ($value) => ! is_null($value))->reduce(function ($result, $item) use ($callback) { $value = $callback($item); return is_null($result) || $value > $result ? $value : $result; }); } /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage) { $offset = max(0, ($page - 1) * $perPage); return $this->slice($offset, $perPage); } /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param TValue|string|null $operator * @param TValue|null $value * @return static&lt;int&lt;0, 1>, static&lt;TKey, TValue&#187; */ public function partition($key, $operator = null, $value = null) { $passed = []; $failed = []; $callback = func_num_args() === 1 ? $this->valueRetriever($key) : $this->operatorForWhere(&mldr;func_get_args()); foreach ($this as $key => $item) { if ($callback($item, $key)) { $passed[$key] = $item; } else { $failed[$key] = $item; } } return new static([new static($passed), new static($failed)]); } /** * Calculate the percentage of items that pass a given truth test. * * @param (callable(TValue, TKey): bool) $callback * @param int $precision * @return float|null */ public function percentage(callable $callback, int $precision = 2) { if ($this->isEmpty()) { return null; } return round( $this->filter($callback)->count() / $this->count() * 100, $precision ); } /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null) { $callback = is_null($callback) ? $this->identity() : $this->valueRetriever($callback); return $this->reduce(fn ($result, $item) => $result + $callback($item), 0); } /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null) { return $this->when($this->isEmpty(), $callback, $default); } /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null) { return $this->when($this->isNotEmpty(), $callback, $default); } /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null) { return $this->whenNotEmpty($callback, $default); } /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null) { return $this->whenEmpty($callback, $default); } /** * Filter items by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null) { return $this->filter($this->operatorForWhere(&mldr;func_get_args())); } /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null) { return $this->whereStrict($key, null); } /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null) { return $this->where($key, &lsquo;!==&rsquo;, null); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value) { return $this->where($key, &lsquo;===&rsquo;, $value); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false) { $values = $this->getArrayableItems($values); return $this->filter(fn ($item) => in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values) { return $this->whereIn($key, $values, true); } /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values) { return $this->where($key, &lsquo;>=&rsquo;, reset($values))->where($key, &lsquo;&lt;=&rsquo;, end($values)); } /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values) { return $this->filter( fn ($item) => data_get($item, $key) &lt; reset($values) || data_get($item, $key) > end($values) ); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false) { $values = $this->getArrayableItems($values); return $this->reject(fn ($item) => in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values) { return $this->whereNotIn($key, $values, true); } /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf>|array&lt;array-key, class-string&lt;TWhereInstanceOf&#187; $type * @return static&lt;TKey, TWhereInstanceOf> */ public function whereInstanceOf($type) { return $this->filter(function ($value) use ($type) { if (is_array($type)) { foreach ($type as $classType) { if ($value instanceof $classType) { return true; } } return false; } return $value instanceof $type; }); } /** * Pass the collection to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback) { return $callback($this); } /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue> $class * @return TPipeIntoValue */ public function pipeInto($class) { return new $class($this); } /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable> $callbacks * @return mixed */ public function pipeThrough($callbacks) { return Collection::make($callbacks)->reduce( fn ($carry, $callback) => $callback($carry), $this, ); } /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null) { $result = $initial; foreach ($this as $key => $value) { $result = $callback($result, $value, $key); } return $result; } /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &mldr;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &mldr;$initial) { $result = $initial; foreach ($this as $key => $value) { $result = call_user_func_array($callback, array_merge($result, [$value, $key])); if (! is_array($result)) { throw new UnexpectedValueException(sprintf( &ldquo;%s::reduceSpread expects reducer to return an array, but got a &lsquo;%s&rsquo; instead.&rdquo;, class_basename(static::class), gettype($result) )); } } return $result; } /** * Reduce an associative collection to a single value. * * @template TReduceWithKeysInitial * @template TReduceWithKeysReturnType * * @param callable(TReduceWithKeysInitial|TReduceWithKeysReturnType, TValue, TKey): TReduceWithKeysReturnType $callback * @param TReduceWithKeysInitial $initial * @return TReduceWithKeysReturnType */ public function reduceWithKeys(callable $callback, $initial = null) { return $this->reduce($callback, $initial); } /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true) { $useAsCallable = $this->useAsCallable($callback); return $this->filter(function ($value, $key) use ($callback, $useAsCallable) { return $useAsCallable ? ! $callback($value, $key) : $value != $callback; }); } /** * Pass the collection to the given callback and then return it. * * @param callable($this): mixed $callback * @return $this */ public function tap(callable $callback) { $callback($this); return $this; } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { $callback = $this->valueRetriever($key); $exists = []; return $this->reject(function ($item, $key) use ($callback, $strict, &$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null) { return $this->unique($key, true); } /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue> */ public function collect() { return new Collection($this->all()); } /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed> */ public function toArray() { return $this->map(fn ($value) => $value instanceof Arrayable ? $value->toArray() : $value)->all(); } /** * Convert the object into something JSON serializable. * * @return array&lt;TKey, mixed> */ public function jsonSerialize(): array { return array_map(function ($value) { if ($value instanceof JsonSerializable) { return $value->jsonSerialize(); } elseif ($value instanceof Jsonable) { return json_decode($value->toJson(), true); } elseif ($value instanceof Arrayable) { return $value->toArray(); } return $value; }, $this->all()); } /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0) { return json_encode($this->jsonSerialize(), $options); } /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING) { return new CachingIterator($this->getIterator(), $flags); } /** * Convert the collection to its string representation. * * @return string */ public function __toString() { return $this->escapeWhenCastingToString ? e($this->toJson()) : $this->toJson(); } /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true) { $this->escapeWhenCastingToString = $escape; return $this; } /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method) { static::$proxies[] = $method; } /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key) { if (! in_array($key, static::$proxies)) { throw new Exception(&ldquo;Property [{$key}] does not exist on this collection instance.&rdquo;); } return new HigherOrderCollectionProxy($this, $key); } /** * Results array of items from Collection or Arrayable. * * @param mixed $items * @return array&lt;TKey, TValue> */ protected function getArrayableItems($items) { if (is_array($items)) { return $items; } return match (true) { $items instanceof WeakMap => throw new InvalidArgumentException(&lsquo;Collections can not be created using instances of WeakMap.&rsquo;), $items instanceof Enumerable => $items->all(), $items instanceof Arrayable => $items->toArray(), $items instanceof \Traversable => iterator_to_array($items), $items instanceof Jsonable => json_decode($items->toJson(), true), $items instanceof JsonSerializable => (array) $items->jsonSerialize(), $items instanceof UnitEnum => [$items], default => (array) $items, }; } /** * Get an operator checker callback. * * @param callable|string $key * @param string|null $operator * @param mixed $value * @return \Closure */ protected function operatorForWhere($key, $operator = null, $value = null) { if ($this->useAsCallable($key)) { return $key; } if (func_num_args() === 1) { $value = true; $operator = &lsquo;=&rsquo;; } if (func_num_args() === 2) { $value = $operator; $operator = &lsquo;=&rsquo;; } return function ($item) use ($key, $operator, $value) { $retrieved = data_get($item, $key); $strings = array_filter([$retrieved, $value], function ($value) { return is_string($value) || (is_object($value) && method_exists($value, &lsquo;__toString&rsquo;)); }); if (count($strings) &lt; 2 && count(array_filter([$retrieved, $value], &lsquo;is_object&rsquo;)) == 1) { return in_array($operator, [&rsquo;!=&rsquo;, &lsquo;&lt;>&rsquo;, &lsquo;!==&rsquo;]); } switch ($operator) { default: case &lsquo;=&rsquo;: case &lsquo;==&rsquo;: return $retrieved == $value; case &lsquo;!=&rsquo;: case &lsquo;&lt;>&rsquo;: return $retrieved != $value; case &lsquo;&lt;&rsquo;: return $retrieved &lt; $value; case &lsquo;>&rsquo;: return $retrieved > $value; case &lsquo;&lt;=&rsquo;: return $retrieved &lt;= $value; case &lsquo;>=&rsquo;: return $retrieved >= $value; case &lsquo;===&rsquo;: return $retrieved === $value; case &lsquo;!==&rsquo;: return $retrieved !== $value; case &lsquo;&lt;=>&rsquo;: return $retrieved &lt;=> $value; } }; } /** * Determine if the given value is callable, but not a string. * * @param mixed $value * @return bool */ protected function useAsCallable($value) { return ! is_string($value) && is_callable($value); } /** * Get a value retrieving callback. * * @param callable|string|null $value * @return callable */ protected function valueRetriever($value) { if ($this->useAsCallable($value)) { return $value; } return fn ($item) => data_get($item, $value); } /** * Make a function to check an item&rsquo;s equality. * * @param mixed $value * @return \Closure(mixed): bool */ protected function equality($value) { return fn ($item) => $item === $value; } /** * Make a function using another function, by negating its result. * * @param \Closure $callback * @return \Closure */ protected function negate(Closure $callback) { return fn (&mldr;$params) => ! $callback(&mldr;$params); } /** * Make a function that returns what&rsquo;s passed to it. * * @return \Closure(TValue): TValue */ protected function identity() { return fn ($value) => $value; } } ?> &lt;?php namespace Illuminate\Support; use ArrayIterator; use Illuminate\Contracts\Support\CanBeEscapedWhenCastToString; use Illuminate\Support\Traits\EnumeratesValues; use stdClass; /** * @template TKey of array-key * * @template-covariant TValue * * @implements \ArrayAccess&lt;TKey, TValue> * @implements \Illuminate\Support\Enumerable&lt;TKey, TValue> */ class Collection implements \ArrayAccess, CanBeEscapedWhenCastToString, Enumerable { /** * @use \Illuminate\Support\Traits\EnumeratesValues&lt;TKey, TValue> */ use EnumeratesValues, Traits\Macroable; /** * The items contained in the collection. * * @var array&lt;TKey, TValue> */ protected $items = []; /** * Create a new collection. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue>|null $items * @return void */ public function __construct($items = []) { $this->items = $this->getArrayableItems($items); } /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static&lt;int, int> */ public static function range($from, $to, $step = 1) { return new static(range($from, $to, $step)); } /** * Get all of the items in the collection. * * @return array&lt;TKey, TValue> */ public function all() { return $this->items; } /** * Get a lazy collection for the items in this collection. * * @return \Illuminate\Support\LazyCollection&lt;TKey, TValue> */ public function lazy() { return new LazyCollection($this->items); } /** * Get the median of a given key. * * @param string|array&lt;array-key, string>|null $key * @return float|int|null */ public function median($key = null) { $values = (isset($key) ? $this->pluck($key) : $this) ->filter(fn ($item) => ! is_null($item)) ->sort()->values(); $count = $values->count(); if ($count === 0) { return; } $middle = (int) ($count / 2); if ($count % 2) { return $values->get($middle); } return (new static([ $values->get($middle - 1), $values->get($middle), ]))->average(); } /** * Get the mode of a given key. * * @param string|array&lt;array-key, string>|null $key * @return array&lt;int, float|int>|null */ public function mode($key = null) { if ($this->count() === 0) { return; } $collection = isset($key) ? $this->pluck($key) : $this; $counts = new static; $collection->each(fn ($value) => $counts[$value] = isset($counts[$value]) ? $counts[$value] + 1 : 1); $sorted = $counts->sort(); $highestValue = $sorted->last(); return $sorted->filter(fn ($value) => $value == $highestValue) ->sort()->keys()->all(); } /** * Collapse the collection of items into a single array. * * @return static&lt;int, mixed> */ public function collapse() { return new static(Arr::collapse($this->items)); } /** * Collapse the collection of items into a single array while preserving its keys. * * @return static&lt;mixed, mixed> */ public function collapseWithKeys() { $results = []; foreach ($this->items as $key => $values) { if ($values instanceof Collection) { $values = $values->all(); } elseif (! is_array($values)) { continue; } $results[$key] = $values; } return new static(array_replace(&mldr;$results)); } /** * Determine if an item exists in the collection. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null) { if (func_num_args() === 1) { if ($this->useAsCallable($key)) { $placeholder = new stdClass; return $this->first($key, $placeholder) !== $placeholder; } return in_array($key, $this->items); } return $this->contains($this->operatorForWhere(&mldr;func_get_args())); } /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null) { if (func_num_args() === 2) { return $this->contains(fn ($item) => data_get($item, $key) === $value); } if ($this->useAsCallable($key)) { return ! is_null($this->first($key)); } return in_array($key, $this->items, true); } /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null) { return ! $this->contains(&mldr;func_get_args()); } /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue>|iterable&lt;TCrossJoinKey, TCrossJoinValue> &mldr;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&#187; */ public function crossJoin(&mldr;$lists) { return new static(Arr::crossJoin( $this->items, &mldr;array_map([$this, &lsquo;getArrayableItems&rsquo;], $lists) )); } /** * Get the items in the collection that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @return static */ public function diff($items) { return new static(array_diff($this->items, $this->getArrayableItems($items))); } /** * Get the items in the collection that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback) { return new static(array_udiff($this->items, $this->getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function diffAssoc($items) { return new static(array_diff_assoc($this->items, $this->getArrayableItems($items))); } /** * Get the items in the collection whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback) { return new static(array_diff_uassoc($this->items, $this->getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function diffKeys($items) { return new static(array_diff_key($this->items, $this->getArrayableItems($items))); } /** * Get the items in the collection whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback) { return new static(array_diff_ukey($this->items, $this->getArrayableItems($items), $callback)); } /** * Retrieve duplicate items from the collection. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false) { $items = $this->map($this->valueRetriever($callback)); $uniqueItems = $items->unique(null, $strict); $compare = $this->duplicateComparator($strict); $duplicates = new static; foreach ($items as $key => $value) { if ($uniqueItems->isNotEmpty() && $compare($value, $uniqueItems->first())) { $uniqueItems->shift(); } else { $duplicates[$key] = $value; } } return $duplicates; } /** * Retrieve duplicate items from the collection using strict comparison. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @return static */ public function duplicatesStrict($callback = null) { return $this->duplicates($callback, true); } /** * Get the comparison function to detect duplicates. * * @param bool $strict * @return callable(TValue, TValue): bool */ protected function duplicateComparator($strict) { if ($strict) { return fn ($a, $b) => $a === $b; } return fn ($a, $b) => $a == $b; } /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string $keys * @return static */ public function except($keys) { if (is_null($keys)) { return new static($this->items); } if ($keys instanceof Enumerable) { $keys = $keys->all(); } elseif (! is_array($keys)) { $keys = func_get_args(); } return new static(Arr::except($this->items, $keys)); } /** * Run a filter over each of the items. * * @param (callable(TValue, TKey): bool)|null $callback * @return static */ public function filter(?callable $callback = null) { if ($callback) { return new static(Arr::where($this->items, $callback)); } return new static(array_filter($this->items)); } /** * Get the first item from the collection passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null) { return Arr::first($this->items, $callback, $default); } /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static&lt;int, mixed> */ public function flatten($depth = INF) { return new static(Arr::flatten($this->items, $depth)); } /** * Flip the items in the collection. * * @return static&lt;TValue, TKey> */ public function flip() { return new static(array_flip($this->items)); } /** * Remove an item from the collection by key. * * \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TKey>|TKey $keys * * @return $this */ public function forget($keys) { foreach ($this->getArrayableItems($keys) as $key) { $this->offsetUnset($key); } return $this; } /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null) { if (array_key_exists($key, $this->items)) { return $this->items[$key]; } return value($default); } /** * Get an item from the collection by key or add it to collection if it does not exist. * * @template TGetOrPutValue * * @param mixed $key * @param TGetOrPutValue|(\Closure(): TGetOrPutValue) $value * @return TValue|TGetOrPutValue */ public function getOrPut($key, $value) { if (array_key_exists($key, $this->items)) { return $this->items[$key]; } $this->offsetSet($key, $value = value($value)); return $value; } /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&#187; */ public function groupBy($groupBy, $preserveKeys = false) { if (! $this->useAsCallable($groupBy) && is_array($groupBy)) { $nextGroups = $groupBy; $groupBy = array_shift($nextGroups); } $groupBy = $this->valueRetriever($groupBy); $results = []; foreach ($this->items as $key => $value) { $groupKeys = $groupBy($value, $key); if (! is_array($groupKeys)) { $groupKeys = [$groupKeys]; } foreach ($groupKeys as $groupKey) { $groupKey = match (true) { is_bool($groupKey) => (int) $groupKey, $groupKey instanceof \BackedEnum => $groupKey->value, $groupKey instanceof \Stringable => (string) $groupKey, default => $groupKey, }; if (! array_key_exists($groupKey, $results)) { $results[$groupKey] = new static; } $results[$groupKey]->offsetSet($preserveKeys ? $key : null, $value); } } $result = new static($results); if (! empty($nextGroups)) { return $result->map->groupBy($nextGroups, $preserveKeys); } return $result; } /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue> */ public function keyBy($keyBy) { $keyBy = $this->valueRetriever($keyBy); $results = []; foreach ($this->items as $key => $item) { $resolvedKey = $keyBy($item, $key); if (is_object($resolvedKey)) { $resolvedKey = (string) $resolvedKey; } $results[$resolvedKey] = $item; } return new static($results); } /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey> $key * @return bool */ public function has($key) { $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if (! array_key_exists($value, $this->items)) { return false; } } return true; } /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key) { if ($this->isEmpty()) { return false; } $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if ($this->has($value)) { return true; } } return false; } /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string|null $value * @param string|null $glue * @return string */ public function implode($value, $glue = null) { if ($this->useAsCallable($value)) { return implode($glue ?? &lsquo;&rsquo;, $this->map($value)->all()); } $first = $this->first(); if (is_array($first) || (is_object($first) && ! $first instanceof Stringable)) { return implode($glue ?? &lsquo;&rsquo;, $this->pluck($value)->all()); } return implode($value ?? &lsquo;&rsquo;, $this->items); } /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersect($items) { return new static(array_intersect($this->items, $this->getArrayableItems($items))); } /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback) { return new static(array_uintersect($this->items, $this->getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersectAssoc($items) { return new static(array_intersect_assoc($this->items, $this->getArrayableItems($items))); } /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback) { return new static(array_intersect_uassoc($this->items, $this->getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function intersectByKeys($items) { return new static(array_intersect_key( $this->items, $this->getArrayableItems($items) )); } /** * Determine if the collection is empty or not. * * @phpstan-assert-if-true null $this->first() * @phpstan-assert-if-true null $this->last() * * @phpstan-assert-if-false TValue $this->first() * @phpstan-assert-if-false TValue $this->last() * * @return bool */ public function isEmpty() { return empty($this->items); } /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem() { return $this->count() === 1; } /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return $this->implode($glue); } $count = $this->count(); if ($count === 0) { return &lsquo;&rsquo;; } if ($count === 1) { return $this->last(); } $collection = new static($this->items); $finalItem = $collection->pop(); return $collection->implode($glue).$finalGlue.$finalItem; } /** * Get the keys of the collection items. * * @return static&lt;int, TKey> */ public function keys() { return new static(array_keys($this->items)); } /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null) { return Arr::last($this->items, $callback, $default); } /** * Get the values of a given key. * * @param string|int|array&lt;array-key, string>|null $value * @param string|null $key * @return static&lt;array-key, mixed> */ public function pluck($value, $key = null) { return new static(Arr::pluck($this->items, $value, $key)); } /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue> */ public function map(callable $callback) { return new static(Arr::map($this->items, $callback)); } /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue> $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&#187; */ public function mapToDictionary(callable $callback) { $dictionary = []; foreach ($this->items as $key => $item) { $pair = $callback($item, $key); $key = key($pair); $value = reset($pair); if (! isset($dictionary[$key])) { $dictionary[$key] = []; } $dictionary[$key][] = $value; } return new static($dictionary); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue> $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue> */ public function mapWithKeys(callable $callback) { return new static(Arr::mapWithKeys($this->items, $callback)); } /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function merge($items) { return new static(array_merge($this->items, $this->getArrayableItems($items))); } /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue>|iterable&lt;TKey, TMergeRecursiveValue> $items * @return static&lt;TKey, TValue|TMergeRecursiveValue> */ public function mergeRecursive($items) { return new static(array_merge_recursive($this->items, $this->getArrayableItems($items))); } /** * Multiply the items in the collection by the multiplier. * * @param int $multiplier * @return static */ public function multiply(int $multiplier) { $new = new static; for ($i = 0; $i &lt; $multiplier; $i++) { $new->push(&mldr;$this->items); } return $new; } /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue>|iterable&lt;array-key, TCombineValue> $values * @return static&lt;TValue, TCombineValue> */ public function combine($values) { return new static(array_combine($this->all(), $this->getArrayableItems($values))); } /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function union($items) { return new static($this->items + $this->getArrayableItems($items)); } /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0) { $new = []; $position = 0; foreach ($this->slice($offset)->items as $item) { if ($position % $step === 0) { $new[] = $item; } $position++; } return new static($new); } /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string|null $keys * @return static */ public function only($keys) { if (is_null($keys)) { return new static($this->items); } if ($keys instanceof Enumerable) { $keys = $keys->all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::only($this->items, $keys)); } /** * Select specific values from the items within the collection. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string|null $keys * @return static */ public function select($keys) { if (is_null($keys)) { return new static($this->items); } if ($keys instanceof Enumerable) { $keys = $keys->all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::select($this->items, $keys)); } /** * Get and remove the last N items from the collection. * * @param int $count * @return static&lt;int, TValue>|TValue|null */ public function pop($count = 1) { if ($count === 1) { return array_pop($this->items); } if ($this->isEmpty()) { return new static; } $results = []; $collectionCount = $this->count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_pop($this->items)); } return new static($results); } /** * Push an item onto the beginning of the collection. * * @param TValue $value * @param TKey $key * @return $this */ public function prepend($value, $key = null) { $this->items = Arr::prepend($this->items, &mldr;func_get_args()); return $this; } /** * Push one or more items onto the end of the collection. * * @param TValue &mldr;$values * @return $this */ public function push(&mldr;$values) { foreach ($values as $value) { $this->items[] = $value; } return $this; } /** * Prepend one or more items to the beginning of the collection. * * @param TValue &mldr;$values * @return $this */ public function unshift(&mldr;$values) { array_unshift($this->items, &mldr;$values); return $this; } /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue> $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue> */ public function concat($source) { $result = new static($this); foreach ($source as $item) { $result->push($item); } return $result; } /** * Get and remove an item from the collection. * * @template TPullDefault * * @param TKey $key * @param TPullDefault|(\Closure(): TPullDefault) $default * @return TValue|TPullDefault */ public function pull($key, $default = null) { return Arr::pull($this->items, $key, $default); } /** * Put an item in the collection by key. * * @param TKey $key * @param TValue $value * @return $this */ public function put($key, $value) { $this->offsetSet($key, $value); return $this; } /** * Get one or a specified number of items randomly from the collection. * * @param (callable(self&lt;TKey, TValue>): int)|int|null $number * @param bool $preserveKeys * @return static&lt;int, TValue>|TValue * * @throws \InvalidArgumentException */ public function random($number = null, $preserveKeys = false) { if (is_null($number)) { return Arr::random($this->items); } if (is_callable($number)) { return new static(Arr::random($this->items, $number($this), $preserveKeys)); } return new static(Arr::random($this->items, $number, $preserveKeys)); } /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replace($items) { return new static(array_replace($this->items, $this->getArrayableItems($items))); } /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replaceRecursive($items) { return new static(array_replace_recursive($this->items, $this->getArrayableItems($items))); } /** * Reverse items order. * * @return static */ public function reverse() { return new static(array_reverse($this->items, true)); } /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TKey|false */ public function search($value, $strict = false) { if (! $this->useAsCallable($value)) { return array_search($value, $this->items, $strict); } foreach ($this->items as $key => $item) { if ($value($item, $key)) { return $key; } } return false; } /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false) { $key = $this->search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this->keys())->search($key); if ($position === 0) { return null; } return $this->get($keys->get($position - 1)); } /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false) { $key = $this->search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this->keys())->search($key); if ($position === $keys->count() - 1) { return null; } return $this->get($keys->get($position + 1)); } /** * Get and remove the first N items from the collection. * * @param int $count * @return static&lt;int, TValue>|TValue|null * * @throws \InvalidArgumentException */ public function shift($count = 1) { if ($count &lt; 0) { throw new InvalidArgumentException(&lsquo;Number of shifted items may not be less than zero.&rsquo;); } if ($this->isEmpty()) { return null; } if ($count === 0) { return new static; } if ($count === 1) { return array_shift($this->items); } $results = []; $collectionCount = $this->count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_shift($this->items)); } return new static($results); } /** * Shuffle the items in the collection. * * @return static */ public function shuffle() { return new static(Arr::shuffle($this->items)); } /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static> */ public function sliding($size = 2, $step = 1) { $chunks = floor(($this->count() - $size) / $step) + 1; return static::times($chunks, fn ($number) => $this->slice(($number - 1) * $step, $size)); } /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count) { return $this->slice($count); } /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value) { return new static($this->lazy()->skipUntil($value)->all()); } /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value) { return new static($this->lazy()->skipWhile($value)->all()); } /** * Slice the underlying collection array. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null) { return new static(array_slice($this->items, $offset, $length, true)); } /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function split($numberOfGroups) { if ($this->isEmpty()) { return new static; } $groups = new static; $groupSize = floor($this->count() / $numberOfGroups); $remain = $this->count() % $numberOfGroups; $start = 0; for ($i = 0; $i &lt; $numberOfGroups; $i++) { $size = $groupSize; if ($i &lt; $remain) { $size++; } if ($size) { $groups->push(new static(array_slice($this->items, $start, $size))); $start += $size; } } return $groups; } /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function splitIn($numberOfGroups) { return $this->chunk((int) ceil($this->count() / $numberOfGroups)); } /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null) { $filter = func_num_args() > 1 ? $this->operatorForWhere(&mldr;func_get_args()) : $key; $items = $this->unless($filter == null)->filter($filter); $count = $items->count(); if ($count === 0) { throw new ItemNotFoundException; } if ($count > 1) { throw new MultipleItemsFoundException($count); } return $items->first(); } /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null) { $filter = func_num_args() > 1 ? $this->operatorForWhere(&mldr;func_get_args()) : $key; $placeholder = new stdClass(); $item = $this->first($filter, $placeholder); if ($item === $placeholder) { throw new ItemNotFoundException; } return $item; } /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static> */ public function chunk($size) { if ($size &lt;= 0) { return new static; } $chunks = []; foreach (array_chunk($this->items, $size, true) as $chunk) { $chunks[] = new static($chunk); } return new static($chunks); } /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue>): bool $callback * @return static&lt;int, static&lt;int, TValue&#187; */ public function chunkWhile(callable $callback) { return new static( $this->lazy()->chunkWhile($callback)->mapInto(static::class) ); } /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null) { $items = $this->items; $callback && is_callable($callback) ? uasort($items, $callback) : asort($items, $callback ?? SORT_REGULAR); return new static($items); } /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR) { $items = $this->items; arsort($items, $options); return new static($items); } /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false) { if (is_array($callback) && ! is_callable($callback)) { return $this->sortByMany($callback, $options); } $results = []; $callback = $this->valueRetriever($callback); // First we will loop through the items and get the comparator from a callback // function which we were given. Then, we will sort the returned values and // grab all the corresponding values for the sorted keys from this array. foreach ($this->items as $key => $value) { $results[$key] = $callback($value, $key); } $descending ? arsort($results, $options) : asort($results, $options); // Once we have sorted all of the keys in the array, we will loop through them // and grab the corresponding model so we can set the underlying items list // to the sorted version. Then we&rsquo;ll just return the collection instance. foreach (array_keys($results) as $key) { $results[$key] = $this->items[$key]; } return new static($results); } /** * Sort the collection using multiple comparisons. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}> $comparisons * @param int $options * @return static */ protected function sortByMany(array $comparisons = [], int $options = SORT_REGULAR) { $items = $this->items; uasort($items, function ($a, $b) use ($comparisons, $options) { foreach ($comparisons as $comparison) { $comparison = Arr::wrap($comparison); $prop = $comparison[0]; $ascending = Arr::get($comparison, 1, true) === true || Arr::get($comparison, 1, true) === &lsquo;asc&rsquo;; if (! is_string($prop) && is_callable($prop)) { $result = $prop($a, $b); } else { $values = [data_get($a, $prop), data_get($b, $prop)]; if (! $ascending) { $values = array_reverse($values); } if (($options & SORT_FLAG_CASE) === SORT_FLAG_CASE) { if (($options & SORT_NATURAL) === SORT_NATURAL) { $result = strnatcasecmp($values[0], $values[1]); } else { $result = strcasecmp($values[0], $values[1]); } } else { $result = match ($options) { SORT_NUMERIC => intval($values[0]) &lt;=> intval($values[1]), SORT_STRING => strcmp($values[0], $values[1]), SORT_NATURAL => strnatcmp((string) $values[0], (string) $values[1]), SORT_LOCALE_STRING => strcoll($values[0], $values[1]), default => $values[0] &lt;=> $values[1], }; } } if ($result === 0) { continue; } return $result; } }); return new static($items); } /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR) { if (is_array($callback) && ! is_callable($callback)) { foreach ($callback as $index => $key) { $comparison = Arr::wrap($key); $comparison[1] = &lsquo;desc&rsquo;; $callback[$index] = $comparison; } } return $this->sortBy($callback, $options, true); } /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false) { $items = $this->items; $descending ? krsort($items, $options) : ksort($items, $options); return new static($items); } /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR) { return $this->sortKeys($options, true); } /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback) { $items = $this->items; uksort($items, $callback); return new static($items); } /** * Splice a portion of the underlying collection array. * * @param int $offset * @param int|null $length * @param array&lt;array-key, TValue> $replacement * @return static */ public function splice($offset, $length = null, $replacement = []) { if (func_num_args() === 1) { return new static(array_splice($this->items, $offset)); } return new static(array_splice($this->items, $offset, $length, $this->getArrayableItems($replacement))); } /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit) { if ($limit &lt; 0) { return $this->slice($limit, abs($limit)); } return $this->slice(0, $limit); } /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value) { return new static($this->lazy()->takeUntil($value)->all()); } /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value) { return new static($this->lazy()->takeWhile($value)->all()); } /** * Transform each item in the collection using a callback. * * @param callable(TValue, TKey): TValue $callback * @return $this */ public function transform(callable $callback) { $this->items = $this->map($callback)->all(); return $this; } /** * Flatten a multi-dimensional associative array with dots. * * @return static */ public function dot() { return new static(Arr::dot($this->all())); } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot() { return new static(Arr::undot($this->all())); } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { if (is_null($key) && $strict === false) { return new static(array_unique($this->items, SORT_REGULAR)); } $callback = $this->valueRetriever($key); $exists = []; return $this->reject(function ($item, $key) use ($callback, $strict, &$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue> */ public function values() { return new static(array_values($this->items)); } /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])->zip([4, 5, 6]); * => [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue>|iterable&lt;array-key, TZipValue> &mldr;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&#187; */ public function zip($items) { $arrayableItems = array_map(fn ($items) => $this->getArrayableItems($items), func_get_args()); $params = array_merge([fn () => new static(func_get_args()), $this->items], $arrayableItems); return new static(array_map(&mldr;$params)); } /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue> */ public function pad($size, $value) { return new static(array_pad($this->items, $size, $value)); } /** * Get an iterator for the items. * * @return \ArrayIterator&lt;TKey, TValue> */ public function getIterator(): \Traversable { return new ArrayIterator($this->items); } /** * Count the number of items in the collection. * * @return int */ public function count(): int { return count($this->items); } /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int> */ public function countBy($countBy = null) { return new static($this->lazy()->countBy($countBy)->all()); } /** * Add an item to the collection. * * @param TValue $item * @return $this */ public function add($item) { $this->items[] = $item; return $this; } /** * Get a base Support collection instance from this collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue> */ public function toBase() { return new self($this); } /** * Determine if an item exists at an offset. * * @param TKey $key * @return bool */ public function offsetExists($key): bool { return isset($this->items[$key]); } /** * Get an item at a given offset. * * @param TKey $key * @return TValue */ public function offsetGet($key): mixed { return $this->items[$key]; } /** * Set the item at a given offset. * * @param TKey|null $key * @param TValue $value * @return void */ public function offsetSet($key, $value): void { if (is_null($key)) { $this->items[] = $value; } else { $this->items[$key] = $value; } } /** * Unset the item at a given offset. * * @param TKey $key * @return void */ public function offsetUnset($key): void { unset($this->items[$key]); } } ?> &lt;?php $start = microtime(true); $product = []; for ($k = 0; $k &lt;= 1000; $k++) { $options = []; for ($j = 0; $j &lt;= 10; $j++) { $optionItems = []; for ($i = 0; $i &lt;= 100; $i++) { $optionItems[] = new Collection(array( &rsquo;title&rsquo; => &lsquo;OptionItem&rsquo; . $i, &lsquo;description&rsquo; => &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, &lsquo;price&rsquo; => random_int(1000, 10000) )); } $options[] = new Collection(array( &rsquo;title&rsquo; => &lsquo;Option&rsquo; . $j, &lsquo;description&rsquo; => &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, &lsquo;price&rsquo; => random_int(1000, 10000), &lsquo;items&rsquo; => $optionItems )); } $product[] = new Collection(array( &rsquo;title&rsquo; => &lsquo;Product&rsquo; . $k, &lsquo;description&rsquo; => &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, &lsquo;price&rsquo; => random_int(1000, 10000), &lsquo;currency&rsquo; => &lsquo;USD&rsquo;, &lsquo;category&rsquo; => &lsquo;Category&rsquo; . $k, &lsquo;brand&rsquo; => &lsquo;Brand&rsquo; . $k, &lsquo;options&rsquo; => $options )); } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br>&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br>&rsquo;;</td><td>&lt;?php namespace Illuminate\Contracts\Support; ini_set(&lsquo;memory_limit&rsquo;, &lsquo;1024M&rsquo;); interface CanBeEscapedWhenCastToString { /** * Indicate that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); } ?> &lt;?php namespace Illuminate\Support\Traits; use Closure; use Illuminate\Support\HigherOrderWhenProxy; trait Conditionable { /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenParameter * @template TWhenReturnType * * @param (\Closure($this): TWhenParameter)|TWhenParameter|null $value * @param (callable($this, TWhenParameter): TWhenReturnType)|null $callback * @param (callable($this, TWhenParameter): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return new HigherOrderWhenProxy($this); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))->condition($value); } if ($value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessParameter * @template TUnlessReturnType * * @param (\Closure($this): TUnlessParameter)|TUnlessParameter|null $value * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $callback * @param (callable($this, TUnlessParameter): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value = null, ?callable $callback = null, ?callable $default = null) { $value = $value instanceof Closure ? $value($this) : $value; if (func_num_args() === 0) { return (new HigherOrderWhenProxy($this))->negateConditionOnCapture(); } if (func_num_args() === 1) { return (new HigherOrderWhenProxy($this))->condition(! $value); } if (! $value) { return $callback($this, $value) ?? $this; } elseif ($default) { return $default($this, $value) ?? $this; } return $this; } } ?> &lt;?php namespace Illuminate\Support; use ArgumentCountError; use \ArrayAccess; use Illuminate\Support\Traits\Macroable; use InvalidArgumentException; use Random\Randomizer; class Arr { use Macroable; /** * Determine whether the given value is array accessible. * * @param mixed $value * @return bool */ public static function accessible($value) { return is_array($value) || $value instanceof ArrayAccess; } /** * Add an element to an array using &ldquo;dot&rdquo; notation if it doesn&rsquo;t exist. * * @param array $array * @param string|int|float $key * @param mixed $value * @return array */ public static function add($array, $key, $value) { if (is_null(static::get($array, $key))) { static::set($array, $key, $value); } return $array; } /** * Collapse an array of arrays into a single array. * * @param iterable $array * @return array */ public static function collapse($array) { $results = []; foreach ($array as $values) { if ($values instanceof Collection) { $values = $values->all(); } elseif (! is_array($values)) { continue; } $results[] = $values; } return array_merge([], &mldr;$results); } /** * Cross join the given arrays, returning all possible permutations. * * @param iterable &mldr;$arrays * @return array */ public static function crossJoin(&mldr;$arrays) { $results = [[]]; foreach ($arrays as $index => $array) { $append = []; foreach ($results as $product) { foreach ($array as $item) { $product[$index] = $item; $append[] = $product; } } $results = $append; } return $results; } /** * Divide an array into two arrays. One with keys and the other with values. * * @param array $array * @return array */ public static function divide($array) { return [array_keys($array), array_values($array)]; } /** * Flatten a multi-dimensional associative array with dots. * * @param iterable $array * @param string $prepend * @return array */ public static function dot($array, $prepend = &lsquo;&rsquo;) { $results = []; foreach ($array as $key => $value) { if (is_array($value) && ! empty($value)) { $results = array_merge($results, static::dot($value, $prepend.$key.&rsquo;.&rsquo;)); } else { $results[$prepend.$key] = $value; } } return $results; } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @param iterable $array * @return array */ public static function undot($array) { $results = []; foreach ($array as $key => $value) { static::set($results, $key, $value); } return $results; } /** * Get all of the given array except for a specified array of keys. * * @param array $array * @param array|string|int|float $keys * @return array */ public static function except($array, $keys) { static::forget($array, $keys); return $array; } /** * Determine if the given key exists in the provided array. * * @param \ArrayAccess|array $array * @param string|int|float $key * @return bool */ public static function exists($array, $key) { if ($array instanceof Enumerable) { return $array->has($key); } if ($array instanceof ArrayAccess) { return $array->offsetExists($key); } if (is_float($key)) { $key = (string) $key; } return array_key_exists($key, $array); } /** * Return the first element in an array passing a given truth test. * * @template TKey * @template TValue * @template TFirstDefault * * @param iterable&lt;TKey, TValue> $array * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public static function first($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { if (empty($array)) { return value($default); } foreach ($array as $item) { return $item; } return value($default); } foreach ($array as $key => $value) { if ($callback($value, $key)) { return $value; } } return value($default); } /** * Return the last element in an array passing a given truth test. * * @param array $array * @param callable|null $callback * @param mixed $default * @return mixed */ public static function last($array, ?callable $callback = null, $default = null) { if (is_null($callback)) { return empty($array) ? value($default) : end($array); } return static::first(array_reverse($array, true), $callback, $default); } /** * Take the first or last {$limit} items from an array. * * @param array $array * @param int $limit * @return array */ public static function take($array, $limit) { if ($limit &lt; 0) { return array_slice($array, $limit, abs($limit)); } return array_slice($array, 0, $limit); } /** * Flatten a multi-dimensional array into a single level. * * @param iterable $array * @param int $depth * @return array */ public static function flatten($array, $depth = INF) { $result = []; foreach ($array as $item) { $item = $item instanceof Collection ? $item->all() : $item; if (! is_array($item)) { $result[] = $item; } else { $values = $depth === 1 ? array_values($item) : static::flatten($item, $depth - 1); foreach ($values as $value) { $result[] = $value; } } } return $result; } /** * Remove one or many array items from a given array using &ldquo;dot&rdquo; notation. * * @param array $array * @param array|string|int|float $keys * @return void */ public static function forget(&$array, $keys) { $original = &$array; $keys = (array) $keys; if (count($keys) === 0) { return; } foreach ($keys as $key) { // if the exact key exists in the top-level, remove it if (static::exists($array, $key)) { unset($array[$key]); continue; } $parts = explode(&rsquo;.&rsquo;, $key); // clean up before each pass $array = &$original; while (count($parts) > 1) { $part = array_shift($parts); if (isset($array[$part]) && static::accessible($array[$part])) { $array = &$array[$part]; } else { continue 2; } } unset($array[array_shift($parts)]); } } /** * Get an item from an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|int|null $key * @param mixed $default * @return mixed */ public static function get($array, $key, $default = null) { if (! static::accessible($array)) { return value($default); } if (is_null($key)) { return $array; } if (static::exists($array, $key)) { return $array[$key]; } if (! str_contains($key, &lsquo;.&rsquo;)) { return $array[$key] ?? value($default); } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($array) && static::exists($array, $segment)) { $array = $array[$segment]; } else { return value($default); } } return $array; } /** * Check if an item or items exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function has($array, $keys) { $keys = (array) $keys; if (! $array || $keys === []) { return false; } foreach ($keys as $key) { $subKeyArray = $array; if (static::exists($array, $key)) { continue; } foreach (explode(&rsquo;.&rsquo;, $key) as $segment) { if (static::accessible($subKeyArray) && static::exists($subKeyArray, $segment)) { $subKeyArray = $subKeyArray[$segment]; } else { return false; } } } return true; } /** * Determine if any of the keys exist in an array using &ldquo;dot&rdquo; notation. * * @param \ArrayAccess|array $array * @param string|array $keys * @return bool */ public static function hasAny($array, $keys) { if (is_null($keys)) { return false; } $keys = (array) $keys; if (! $array) { return false; } if ($keys === []) { return false; } foreach ($keys as $key) { if (static::has($array, $key)) { return true; } } return false; } /** * Determines if an array is associative. * * An array is &ldquo;associative&rdquo; if it doesn&rsquo;t have sequential numerical keys beginning with zero. * * @param array $array * @return bool */ public static function isAssoc(array $array) { return ! array_is_list($array); } /** * Determines if an array is a list. * * An array is a &ldquo;list&rdquo; if all array keys are sequential integers starting from 0 with no gaps in between. * * @param array $array * @return bool */ public static function isList($array) { return array_is_list($array); } /** * Join all items using a string. The final items can use a separate glue string. * * @param array $array * @param string $glue * @param string $finalGlue * @return string */ public static function join($array, $glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return implode($glue, $array); } if (count($array) === 0) { return &lsquo;&rsquo;; } if (count($array) === 1) { return end($array); } $finalItem = array_pop($array); return implode($glue, $array).$finalGlue.$finalItem; } /** * Key an associative array by a field or using a callback. * * @param array $array * @param callable|array|string $keyBy * @return array */ public static function keyBy($array, $keyBy) { return Collection::make($array)->keyBy($keyBy)->all(); } /** * Prepend the key names of an associative array. * * @param array $array * @param string $prependWith * @return array */ public static function prependKeysWith($array, $prependWith) { return static::mapWithKeys($array, fn ($item, $key) => [$prependWith.$key => $item]); } /** * Get a subset of the items from the given array. * * @param array $array * @param array|string $keys * @return array */ public static function only($array, $keys) { return array_intersect_key($array, array_flip((array) $keys)); } /** * Select an array of values from an array. * * @param array $array * @param array|string $keys * @return array */ public static function select($array, $keys) { $keys = static::wrap($keys); return static::map($array, function ($item) use ($keys) { $result = []; foreach ($keys as $key) { if (Arr::accessible($item) && Arr::exists($item, $key)) { $result[$key] = $item[$key]; } elseif (is_object($item) && isset($item->{$key})) { $result[$key] = $item->{$key}; } } return $result; }); } /** * Pluck an array of values from an array. * * @param iterable $array * @param string|array|int|null $value * @param string|array|null $key * @return array */ public static function pluck($array, $value, $key = null) { $results = []; [$value, $key] = static::explodePluckParameters($value, $key); foreach ($array as $item) { $itemValue = data_get($item, $value); // If the key is &ldquo;null&rdquo;, we will just append the value to the array and keep // looping. Otherwise we will key the array using the value of the key we // received from the developer. Then we&rsquo;ll return the final array form. if (is_null($key)) { $results[] = $itemValue; } else { $itemKey = data_get($item, $key); if (is_object($itemKey) && method_exists($itemKey, &lsquo;__toString&rsquo;)) { $itemKey = (string) $itemKey; } $results[$itemKey] = $itemValue; } } return $results; } /** * Explode the &ldquo;value&rdquo; and &ldquo;key&rdquo; arguments passed to &ldquo;pluck&rdquo;. * * @param string|array $value * @param string|array|null $key * @return array */ protected static function explodePluckParameters($value, $key) { $value = is_string($value) ? explode(&rsquo;.&rsquo;, $value) : $value; $key = is_null($key) || is_array($key) ? $key : explode(&rsquo;.&rsquo;, $key); return [$value, $key]; } /** * Run a map over each of the items in the array. * * @param array $array * @param callable $callback * @return array */ public static function map(array $array, callable $callback) { $keys = array_keys($array); try { $items = array_map($callback, $array, $keys); } catch (ArgumentCountError) { $items = array_map($callback, $array); } return array_combine($keys, $items); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TKey * @template TValue * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param array&lt;TKey, TValue> $array * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue> $callback * @return array */ public static function mapWithKeys(array $array, callable $callback) { $result = []; foreach ($array as $key => $value) { $assoc = $callback($value, $key); foreach ($assoc as $mapKey => $mapValue) { $result[$mapKey] = $mapValue; } } return $result; } /** * Run a map over each nested chunk of items. * * @template TKey * @template TValue * * @param array&lt;TKey, array> $array * @param callable(mixed&mldr;): TValue $callback * @return array&lt;TKey, TValue> */ public static function mapSpread(array $array, callable $callback) { return static::map($array, function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&mldr;$chunk); }); } /** * Push an item onto the beginning of an array. * * @param array $array * @param mixed $value * @param mixed $key * @return array */ public static function prepend($array, $value, $key = null) { if (func_num_args() == 2) { array_unshift($array, $value); } else { $array = [$key => $value] + $array; } return $array; } /** * Get a value from the array, and remove it. * * @param array $array * @param string|int $key * @param mixed $default * @return mixed */ public static function pull(&$array, $key, $default = null) { $value = static::get($array, $key, $default); static::forget($array, $key); return $value; } /** * Convert the array into a query string. * * @param array $array * @return string */ public static function query($array) { return http_build_query($array, &lsquo;&rsquo;, &lsquo;&&rsquo;, PHP_QUERY_RFC3986); } /** * Get one or a specified number of random values from an array. * * @param array $array * @param int|null $number * @param bool $preserveKeys * @return mixed * * @throws \InvalidArgumentException */ public static function random($array, $number = null, $preserveKeys = false) { $requested = is_null($number) ? 1 : $number; $count = count($array); if ($requested > $count) { throw new InvalidArgumentException( &ldquo;You requested {$requested} items, but there are only {$count} items available.&rdquo; ); } if (empty($array) || (! is_null($number) && $number &lt;= 0)) { return is_null($number) ? null : []; } $keys = (new Randomizer)->pickArrayKeys($array, $requested); if (is_null($number)) { return $array[$keys[0]]; } $results = []; if ($preserveKeys) { foreach ($keys as $key) { $results[$key] = $array[$key]; } } else { foreach ($keys as $key) { $results[] = $array[$key]; } } return $results; } /** * Set an array item to a given value using &ldquo;dot&rdquo; notation. * * If no key is given to the method, the entire array will be replaced. * * @param array $array * @param string|int|null $key * @param mixed $value * @return array */ public static function set(&$array, $key, $value) { if (is_null($key)) { return $array = $value; } $keys = explode(&rsquo;.&rsquo;, $key); foreach ($keys as $i => $key) { if (count($keys) === 1) { break; } unset($keys[$i]); // If the key doesn&rsquo;t exist at this depth, we will just create an empty array // to hold the next value, allowing us to create the arrays to hold final // values at the correct depth. Then we&rsquo;ll keep digging into the array. if (! isset($array[$key]) || ! is_array($array[$key])) { $array[$key] = []; } $array = &$array[$key]; } $array[array_shift($keys)] = $value; return $array; } /** * Shuffle the given array and return the result. * * @param array $array * @return array */ public static function shuffle($array) { return (new Randomizer)->shuffleArray($array); } /** * Sort the array using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sort($array, $callback = null) { return Collection::make($array)->sortBy($callback)->all(); } /** * Sort the array in descending order using the given callback or &ldquo;dot&rdquo; notation. * * @param array $array * @param callable|array|string|null $callback * @return array */ public static function sortDesc($array, $callback = null) { return Collection::make($array)->sortByDesc($callback)->all(); } /** * Recursively sort an array by keys and values. * * @param array $array * @param int $options * @param bool $descending * @return array */ public static function sortRecursive($array, $options = SORT_REGULAR, $descending = false) { foreach ($array as &$value) { if (is_array($value)) { $value = static::sortRecursive($value, $options, $descending); } } if (! array_is_list($array)) { $descending ? krsort($array, $options) : ksort($array, $options); } else { $descending ? rsort($array, $options) : sort($array, $options); } return $array; } /** * Recursively sort an array by keys and values in descending order. * * @param array $array * @param int $options * @return array */ public static function sortRecursiveDesc($array, $options = SORT_REGULAR) { return static::sortRecursive($array, $options, true); } /** * Conditionally compile classes from an array into a CSS class list. * * @param array $array * @return string */ public static function toCssClasses($array) { $classList = static::wrap($array); $classes = []; foreach ($classList as $class => $constraint) { if (is_numeric($class)) { $classes[] = $constraint; } elseif ($constraint) { $classes[] = $class; } } return implode(&rsquo; &lsquo;, $classes); } /** * Conditionally compile styles from an array into a style list. * * @param array $array * @return string */ public static function toCssStyles($array) { $styleList = static::wrap($array); $styles = []; foreach ($styleList as $class => $constraint) { if (is_numeric($class)) { $styles[] = Str::finish($constraint, &lsquo;;&rsquo;); } elseif ($constraint) { $styles[] = Str::finish($class, &lsquo;;&rsquo;); } } return implode(&rsquo; &lsquo;, $styles); } /** * Filter the array using the given callback. * * @param array $array * @param callable $callback * @return array */ public static function where($array, callable $callback) { return array_filter($array, $callback, ARRAY_FILTER_USE_BOTH); } /** * Filter items where the value is not null. * * @param array $array * @return array */ public static function whereNotNull($array) { return static::where($array, fn ($value) => ! is_null($value)); } /** * If the given value is not an array and not null, wrap it in one. * * @param mixed $value * @return array */ public static function wrap($value) { if (is_null($value)) { return []; } return is_array($value) ? $value : [$value]; } } ?> &lt;?php namespace Illuminate\Contracts\Support; interface Jsonable { /** * Convert the object to its JSON representation. * * @param int $options * @return string */ public function toJson($options = 0); } ?> &lt;?php namespace Illuminate\Contracts\Support; /** * @template TKey of array-key * @template TValue */ interface Arrayable { /** * Get the instance as an array. * * @return array&lt;TKey, TValue> */ public function toArray(); } ?> &lt;?php namespace Illuminate\Support\Traits; use BadMethodCallException; use ReflectionClass; use ReflectionMethod; trait Macroable { /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @param-closure-this static $macro * * @return void */ public static function macro($name, $macro) { static::$macros[$name] = $macro; } /** * Mix another object into the class. * * @param object $mixin * @param bool $replace * @return void * * @throws \ReflectionException */ public static function mixin($mixin, $replace = true) { $methods = (new ReflectionClass($mixin))->getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) { if ($replace || ! static::hasMacro($method->name)) { static::macro($method->name, $method->invoke($mixin)); } } } /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) { return isset(static::$macros[$name]); } /** * Flush the existing macros. * * @return void */ public static function flushMacros() { static::$macros = []; } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro->bindTo(null, static::class); } return $macro(&mldr;$parameters); } /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) { if (! static::hasMacro($method)) { throw new BadMethodCallException(sprintf( &lsquo;Method %s::%s does not exist.&rsquo;, static::class, $method )); } $macro = static::$macros[$method]; if ($macro instanceof Closure) { $macro = $macro->bindTo($this, static::class); } return $macro(&mldr;$parameters); } } ?> &lt;?php namespace Illuminate\Support; use CachingIterator; use Countable; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use IteratorAggregate; use JsonSerializable; use \Traversable; /** * @template TKey of array-key * * @template-covariant TValue * * @extends \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue> * @extends \IteratorAggregate&lt;TKey, TValue> */ interface Enumerable extends Arrayable, Countable, IteratorAggregate, Jsonable, JsonSerializable { /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue>|iterable&lt;TMakeKey, TMakeValue>|null $items * @return static&lt;TMakeKey, TMakeValue> */ public static function make($items = []); /** * Create a new instance by invoking the callback a given amount of times. * * @param int $number * @param callable|null $callback * @return static */ public static function times($number, ?callable $callback = null); /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static */ public static function range($from, $to, $step = 1); /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue>|TWrapValue $value * @return static&lt;array-key, TWrapValue> */ public static function wrap($value); /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue>|static&lt;TUnwrapKey, TUnwrapValue> $value * @return array&lt;TUnwrapKey, TUnwrapValue> */ public static function unwrap($value); /** * Create a new instance with no items. * * @return static */ public static function empty(); /** * Get all items in the enumerable. * * @return array */ public function all(); /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null); /** * Get the median of a given key. * * @param string|array&lt;array-key, string>|null $key * @return float|int|null */ public function median($key = null); /** * Get the mode of a given key. * * @param string|array&lt;array-key, string>|null $key * @return array&lt;int, float|int>|null */ public function mode($key = null); /** * Collapse the items into a single enumerable. * * @return static&lt;int, mixed> */ public function collapse(); /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null); /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null); /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null); /** * Determine if an item exists in the enumerable. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null); /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null); /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue>|iterable&lt;TCrossJoinKey, TCrossJoinValue> &mldr;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&#187; */ public function crossJoin(&mldr;$lists); /** * Dump the collection and end the script. * * @param mixed &mldr;$args * @return never */ public function dd(&mldr;$args); /** * Dump the collection. * * @param mixed &mldr;$args * @return $this */ public function dump(&mldr;$args); /** * Get the items that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @return static */ public function diff($items); /** * Get the items that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback); /** * Get the items whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function diffAssoc($items); /** * Get the items whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback); /** * Get the items whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function diffKeys($items); /** * Get the items whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback); /** * Retrieve duplicate items. * * @param (callable(TValue): bool)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false); /** * Retrieve duplicate items using strict comparison. * * @param (callable(TValue): bool)|string|null $callback * @return static */ public function duplicatesStrict($callback = null); /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback); /** * Execute a callback over each nested chunk of items. * * @param callable $callback * @return static */ public function eachSpread(callable $callback); /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null); /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey> $keys * @return static */ public function except($keys); /** * Run a filter over each of the items. * * @param (callable(TValue): bool)|null $callback * @return static */ public function filter(?callable $callback = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) truthy. * * @template TWhenReturnType as null * * @param bool $value * @param (callable($this): TWhenReturnType)|null $callback * @param (callable($this): TWhenReturnType)|null $default * @return $this|TWhenReturnType */ public function when($value, ?callable $callback = null, ?callable $default = null); /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null); /** * Apply the callback if the given &ldquo;value&rdquo; is (or resolves to) falsy. * * @template TUnlessReturnType * * @param bool $value * @param (callable($this): TUnlessReturnType) $callback * @param (callable($this): TUnlessReturnType)|null $default * @return $this|TUnlessReturnType */ public function unless($value, callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null); /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null); /** * Filter items by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null); /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null); /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values); /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values); /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values); /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false); /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values); /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf>|array&lt;array-key, class-string&lt;TWhereInstanceOf&#187; $type * @return static&lt;TKey, TWhereInstanceOf> */ public function whereInstanceOf($type); /** * Get the first item from the enumerable passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue,TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null); /** * Get the first item by the given key value pair. * * @param string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null); /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static */ public function flatten($depth = INF); /** * Flip the values with their keys. * * @return static&lt;TValue, TKey> */ public function flip(); /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null); /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&#187; */ public function groupBy($groupBy, $preserveKeys = false); /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue> */ public function keyBy($keyBy); /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey> $key * @return bool */ public function has($key); /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key); /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string $value * @param string|null $glue * @return string */ public function implode($value, $glue = null); /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersect($items); /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback); /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersectAssoc($items); /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback); /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function intersectByKeys($items); /** * Determine if the collection is empty or not. * * @return bool */ public function isEmpty(); /** * Determine if the collection is not empty. * * @return bool */ public function isNotEmpty(); /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem(); /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;); /** * Get the keys of the collection items. * * @return static&lt;int, TKey> */ public function keys(); /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null); /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue> */ public function map(callable $callback); /** * Run a map over each nested chunk of items. * * @param callable $callback * @return static */ public function mapSpread(callable $callback); /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue> $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&#187; */ public function mapToDictionary(callable $callback); /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue> $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&#187; */ public function mapToGroups(callable $callback); /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue> $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue> */ public function mapWithKeys(callable $callback); /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue>|array&lt;TFlatMapKey, TFlatMapValue>) $callback * @return static&lt;TFlatMapKey, TFlatMapValue> */ public function flatMap(callable $callback); /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue> $class * @return static&lt;TKey, TMapIntoValue> */ public function mapInto($class); /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function merge($items); /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue>|iterable&lt;TKey, TMergeRecursiveValue> $items * @return static&lt;TKey, TValue|TMergeRecursiveValue> */ public function mergeRecursive($items); /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue>|iterable&lt;array-key, TCombineValue> $values * @return static&lt;TValue, TCombineValue> */ public function combine($values); /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function union($items); /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null); /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null); /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0); /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string $keys * @return static */ public function only($keys); /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage); /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return static&lt;int&lt;0, 1>, static&lt;TKey, TValue&#187; */ public function partition($key, $operator = null, $value = null); /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue> $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue> */ public function concat($source); /** * Get one or a specified number of items randomly from the collection. * * @param int|null $number * @return static&lt;int, TValue>|TValue * * @throws \InvalidArgumentException */ public function random($number = null); /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null); /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &mldr;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &mldr;$initial); /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replace($items); /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replaceRecursive($items); /** * Reverse items order. * * @return static */ public function reverse(); /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|callable(TValue,TKey): bool $value * @param bool $strict * @return TKey|bool */ public function search($value, $strict = false); /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false); /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false); /** * Shuffle the items in the collection. * * @return static */ public function shuffle(); /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static> */ public function sliding($size = 2, $step = 1); /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count); /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value); /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value); /** * Get a slice of items from the enumerable. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null); /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function split($numberOfGroups); /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null); /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null); /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static> */ public function chunk($size); /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue>): bool $callback * @return static&lt;int, static&lt;int, TValue&#187; */ public function chunkWhile(callable $callback); /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function splitIn($numberOfGroups); /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null); /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR); /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false); /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR); /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false); /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR); /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback); /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null); /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit); /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value); /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value); /** * Pass the collection to the given callback and then return it. * * @param callable(TValue): mixed $callback * @return $this */ public function tap(callable $callback); /** * Pass the enumerable to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback); /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue> $class * @return TPipeIntoValue */ public function pipeInto($class); /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable> $pipes * @return mixed */ public function pipeThrough($pipes); /** * Get the values of a given key. * * @param string|array&lt;array-key, string> $value * @param string|null $key * @return static&lt;array-key, mixed> */ public function pluck($value, $key = null); /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true); /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot(); /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false); /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null); /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue> */ public function values(); /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue> */ public function pad($size, $value); /** * Get the values iterator. * * @return \Traversable&lt;TKey, TValue> */ public function getIterator(): \Traversable; /** * Count the number of items in the collection. * * @return int */ public function count(): int; /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int> */ public function countBy($countBy = null); /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])->zip([4, 5, 6]); * => [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue>|iterable&lt;array-key, TZipValue> &mldr;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&#187; */ public function zip($items); /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue> */ public function collect(); /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed> */ public function toArray(); /** * Convert the object into something JSON serializable. * * @return mixed */ public function jsonSerialize(): mixed; /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0); /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING); /** * Convert the collection to its string representation. * * @return string */ public function __toString(); /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true); /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method); /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key); } ?> &lt;?php namespace Illuminate\Support\Traits; use BackedEnum; use CachingIterator; use Exception; use Illuminate\Contracts\Support\Arrayable; use Illuminate\Contracts\Support\Jsonable; use Illuminate\Support\Arr; use Illuminate\Support\Collection; use Illuminate\Support\Enumerable; use Illuminate\Support\HigherOrderCollectionProxy; use InvalidArgumentException; use JsonSerializable; use \Traversable; use UnexpectedValueException; use UnitEnum; use WeakMap; /** * @template TKey of array-key * * @template-covariant TValue * * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $average * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $avg * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $contains * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $doesntContain * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $each * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $every * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $filter * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $first * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $flatMap * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $groupBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $keyBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $map * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $max * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $min * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $partition * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $percentage * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $reject * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $skipUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $skipWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $some * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $sortBy * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $sortByDesc * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $sum * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $takeUntil * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $takeWhile * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $unique * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $unless * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $until * @property-read HigherOrderCollectionProxy&lt;TKey, TValue> $when */ trait EnumeratesValues { use Conditionable; /** * Indicates that the object&rsquo;s string representation should be escaped when __toString is invoked. * * @var bool */ protected $escapeWhenCastingToString = false; /** * The methods that can be proxied. * * @var array&lt;int, string> */ protected static $proxies = [ &lsquo;average&rsquo;, &lsquo;avg&rsquo;, &lsquo;contains&rsquo;, &lsquo;doesntContain&rsquo;, &rsquo;each&rsquo;, &rsquo;every&rsquo;, &lsquo;filter&rsquo;, &lsquo;first&rsquo;, &lsquo;flatMap&rsquo;, &lsquo;groupBy&rsquo;, &lsquo;keyBy&rsquo;, &lsquo;map&rsquo;, &lsquo;max&rsquo;, &lsquo;min&rsquo;, &lsquo;partition&rsquo;, &lsquo;percentage&rsquo;, &lsquo;reject&rsquo;, &lsquo;skipUntil&rsquo;, &lsquo;skipWhile&rsquo;, &lsquo;some&rsquo;, &lsquo;sortBy&rsquo;, &lsquo;sortByDesc&rsquo;, &lsquo;sum&rsquo;, &rsquo;takeUntil&rsquo;, &rsquo;takeWhile&rsquo;, &lsquo;unique&rsquo;, &lsquo;unless&rsquo;, &lsquo;until&rsquo;, &lsquo;when&rsquo;, ]; /** * Create a new collection instance if the value isn&rsquo;t one already. * * @template TMakeKey of array-key * @template TMakeValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TMakeKey, TMakeValue>|iterable&lt;TMakeKey, TMakeValue>|null $items * @return static&lt;TMakeKey, TMakeValue> */ public static function make($items = []) { return new static($items); } /** * Wrap the given value in a collection if applicable. * * @template TWrapValue * * @param iterable&lt;array-key, TWrapValue>|TWrapValue $value * @return static&lt;array-key, TWrapValue> */ public static function wrap($value) { return $value instanceof Enumerable ? new static($value) : new static(Arr::wrap($value)); } /** * Get the underlying items from the given collection if applicable. * * @template TUnwrapKey of array-key * @template TUnwrapValue * * @param array&lt;TUnwrapKey, TUnwrapValue>|static&lt;TUnwrapKey, TUnwrapValue> $value * @return array&lt;TUnwrapKey, TUnwrapValue> */ public static function unwrap($value) { return $value instanceof Enumerable ? $value->all() : $value; } /** * Create a new instance with no items. * * @return static */ public static function empty() { return new static([]); } /** * Create a new collection by invoking the callback a given amount of times. * * @template TTimesValue * * @param int $number * @param (callable(int): TTimesValue)|null $callback * @return static&lt;int, TTimesValue> */ public static function times($number, ?callable $callback = null) { if ($number &lt; 1) { return new static; } return static::range(1, $number) ->unless($callback == null) ->map($callback); } /** * Get the average value of a given key. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function avg($callback = null) { $callback = $this->valueRetriever($callback); $reduced = $this->reduce(static function (&$reduce, $value) use ($callback) { if (! is_null($resolved = $callback($value))) { $reduce[0] += $resolved; $reduce[1]++; } return $reduce; }, [0, 0]); return $reduced[1] ? $reduced[0] / $reduced[1] : null; } /** * Alias for the &ldquo;avg&rdquo; method. * * @param (callable(TValue): float|int)|string|null $callback * @return float|int|null */ public function average($callback = null) { return $this->avg($callback); } /** * Alias for the &ldquo;contains&rdquo; method. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function some($key, $operator = null, $value = null) { return $this->contains(&mldr;func_get_args()); } /** * Dump the given arguments and terminate execution. * * @param mixed &mldr;$args * @return never */ public function dd(&mldr;$args) { dd($this->all(), &mldr;$args); } /** * Dump the items. * * @param mixed &mldr;$args * @return $this */ public function dump(&mldr;$args) { dump($this->all(), &mldr;$args); return $this; } /** * Execute a callback over each item. * * @param callable(TValue, TKey): mixed $callback * @return $this */ public function each(callable $callback) { foreach ($this as $key => $item) { if ($callback($item, $key) === false) { break; } } return $this; } /** * Execute a callback over each nested chunk of items. * * @param callable(&mldr;mixed): mixed $callback * @return static */ public function eachSpread(callable $callback) { return $this->each(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&mldr;$chunk); }); } /** * Determine if all items pass the given truth test. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function every($key, $operator = null, $value = null) { if (func_num_args() === 1) { $callback = $this->valueRetriever($key); foreach ($this as $k => $v) { if (! $callback($v, $k)) { return false; } } return true; } return $this->every($this->operatorForWhere(&mldr;func_get_args())); } /** * Get the first item by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return TValue|null */ public function firstWhere($key, $operator = null, $value = null) { return $this->first($this->operatorForWhere(&mldr;func_get_args())); } /** * Get a single key&rsquo;s value from the first matching item in the collection. * * @template TValueDefault * * @param string $key * @param TValueDefault|(\Closure(): TValueDefault) $default * @return TValue|TValueDefault */ public function value($key, $default = null) { if ($value = $this->firstWhere($key)) { return data_get($value, $key, $default); } return value($default); } /** * Ensure that every item in the collection is of the expected type. * * @template TEnsureOfType * * @param class-string&lt;TEnsureOfType>|array&lt;array-key, class-string&lt;TEnsureOfType&#187; $type * @return static&lt;TKey, TEnsureOfType> * * @throws \UnexpectedValueException */ public function ensure($type) { $allowedTypes = is_array($type) ? $type : [$type]; return $this->each(function ($item, $index) use ($allowedTypes) { $itemType = get_debug_type($item); foreach ($allowedTypes as $allowedType) { if ($itemType === $allowedType || $item instanceof $allowedType) { return true; } } throw new UnexpectedValueException( sprintf(&ldquo;Collection should only include [%s] items, but &lsquo;%s&rsquo; found at position %d.&rdquo;, implode(&rsquo;, &lsquo;, $allowedTypes), $itemType, $index) ); }); } /** * Determine if the collection is not empty. * * @phpstan-assert-if-true TValue $this->first() * @phpstan-assert-if-true TValue $this->last() * * @phpstan-assert-if-false null $this->first() * @phpstan-assert-if-false null $this->last() * * @return bool */ public function isNotEmpty() { return ! $this->isEmpty(); } /** * Run a map over each nested chunk of items. * * @template TMapSpreadValue * * @param callable(mixed&mldr;): TMapSpreadValue $callback * @return static&lt;TKey, TMapSpreadValue> */ public function mapSpread(callable $callback) { return $this->map(function ($chunk, $key) use ($callback) { $chunk[] = $key; return $callback(&mldr;$chunk); }); } /** * Run a grouping map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToGroupsKey of array-key * @template TMapToGroupsValue * * @param callable(TValue, TKey): array&lt;TMapToGroupsKey, TMapToGroupsValue> $callback * @return static&lt;TMapToGroupsKey, static&lt;int, TMapToGroupsValue&#187; */ public function mapToGroups(callable $callback) { $groups = $this->mapToDictionary($callback); return $groups->map([$this, &lsquo;make&rsquo;]); } /** * Map a collection and flatten the result by a single level. * * @template TFlatMapKey of array-key * @template TFlatMapValue * * @param callable(TValue, TKey): (\Illuminate\Support\Collection&lt;TFlatMapKey, TFlatMapValue>|array&lt;TFlatMapKey, TFlatMapValue>) $callback * @return static&lt;TFlatMapKey, TFlatMapValue> */ public function flatMap(callable $callback) { return $this->map($callback)->collapse(); } /** * Map the values into a new class. * * @template TMapIntoValue * * @param class-string&lt;TMapIntoValue> $class * @return static&lt;TKey, TMapIntoValue> */ public function mapInto($class) { if (is_subclass_of($class, BackedEnum::class)) { return $this->map(fn ($value, $key) => $class::from($value)); } return $this->map(fn ($value, $key) => new $class($value, $key)); } /** * Get the min value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function min($callback = null) { $callback = $this->valueRetriever($callback); return $this->map(fn ($value) => $callback($value)) ->filter(fn ($value) => ! is_null($value)) ->reduce(fn ($result, $value) => is_null($result) || $value &lt; $result ? $value : $result); } /** * Get the max value of a given key. * * @param (callable(TValue):mixed)|string|null $callback * @return mixed */ public function max($callback = null) { $callback = $this->valueRetriever($callback); return $this->filter(fn ($value) => ! is_null($value))->reduce(function ($result, $item) use ($callback) { $value = $callback($item); return is_null($result) || $value > $result ? $value : $result; }); } /** * &ldquo;Paginate&rdquo; the collection by slicing it into a smaller collection. * * @param int $page * @param int $perPage * @return static */ public function forPage($page, $perPage) { $offset = max(0, ($page - 1) * $perPage); return $this->slice($offset, $perPage); } /** * Partition the collection into two arrays using the given callback or key. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param TValue|string|null $operator * @param TValue|null $value * @return static&lt;int&lt;0, 1>, static&lt;TKey, TValue&#187; */ public function partition($key, $operator = null, $value = null) { $passed = []; $failed = []; $callback = func_num_args() === 1 ? $this->valueRetriever($key) : $this->operatorForWhere(&mldr;func_get_args()); foreach ($this as $key => $item) { if ($callback($item, $key)) { $passed[$key] = $item; } else { $failed[$key] = $item; } } return new static([new static($passed), new static($failed)]); } /** * Calculate the percentage of items that pass a given truth test. * * @param (callable(TValue, TKey): bool) $callback * @param int $precision * @return float|null */ public function percentage(callable $callback, int $precision = 2) { if ($this->isEmpty()) { return null; } return round( $this->filter($callback)->count() / $this->count() * 100, $precision ); } /** * Get the sum of the given values. * * @param (callable(TValue): mixed)|string|null $callback * @return mixed */ public function sum($callback = null) { $callback = is_null($callback) ? $this->identity() : $this->valueRetriever($callback); return $this->reduce(fn ($result, $item) => $result + $callback($item), 0); } /** * Apply the callback if the collection is empty. * * @template TWhenEmptyReturnType * * @param (callable($this): TWhenEmptyReturnType) $callback * @param (callable($this): TWhenEmptyReturnType)|null $default * @return $this|TWhenEmptyReturnType */ public function whenEmpty(callable $callback, ?callable $default = null) { return $this->when($this->isEmpty(), $callback, $default); } /** * Apply the callback if the collection is not empty. * * @template TWhenNotEmptyReturnType * * @param callable($this): TWhenNotEmptyReturnType $callback * @param (callable($this): TWhenNotEmptyReturnType)|null $default * @return $this|TWhenNotEmptyReturnType */ public function whenNotEmpty(callable $callback, ?callable $default = null) { return $this->when($this->isNotEmpty(), $callback, $default); } /** * Apply the callback unless the collection is empty. * * @template TUnlessEmptyReturnType * * @param callable($this): TUnlessEmptyReturnType $callback * @param (callable($this): TUnlessEmptyReturnType)|null $default * @return $this|TUnlessEmptyReturnType */ public function unlessEmpty(callable $callback, ?callable $default = null) { return $this->whenNotEmpty($callback, $default); } /** * Apply the callback unless the collection is not empty. * * @template TUnlessNotEmptyReturnType * * @param callable($this): TUnlessNotEmptyReturnType $callback * @param (callable($this): TUnlessNotEmptyReturnType)|null $default * @return $this|TUnlessNotEmptyReturnType */ public function unlessNotEmpty(callable $callback, ?callable $default = null) { return $this->whenEmpty($callback, $default); } /** * Filter items by the given key value pair. * * @param callable|string $key * @param mixed $operator * @param mixed $value * @return static */ public function where($key, $operator = null, $value = null) { return $this->filter($this->operatorForWhere(&mldr;func_get_args())); } /** * Filter items where the value for the given key is null. * * @param string|null $key * @return static */ public function whereNull($key = null) { return $this->whereStrict($key, null); } /** * Filter items where the value for the given key is not null. * * @param string|null $key * @return static */ public function whereNotNull($key = null) { return $this->where($key, &lsquo;!==&rsquo;, null); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param mixed $value * @return static */ public function whereStrict($key, $value) { return $this->where($key, &lsquo;===&rsquo;, $value); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereIn($key, $values, $strict = false) { $values = $this->getArrayableItems($values); return $this->filter(fn ($item) => in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereInStrict($key, $values) { return $this->whereIn($key, $values, true); } /** * Filter items such that the value of the given key is between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereBetween($key, $values) { return $this->where($key, &lsquo;>=&rsquo;, reset($values))->where($key, &lsquo;&lt;=&rsquo;, end($values)); } /** * Filter items such that the value of the given key is not between the given values. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotBetween($key, $values) { return $this->filter( fn ($item) => data_get($item, $key) &lt; reset($values) || data_get($item, $key) > end($values) ); } /** * Filter items by the given key value pair. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @param bool $strict * @return static */ public function whereNotIn($key, $values, $strict = false) { $values = $this->getArrayableItems($values); return $this->reject(fn ($item) => in_array(data_get($item, $key), $values, $strict)); } /** * Filter items by the given key value pair using strict comparison. * * @param string $key * @param \Illuminate\Contracts\Support\Arrayable|iterable $values * @return static */ public function whereNotInStrict($key, $values) { return $this->whereNotIn($key, $values, true); } /** * Filter the items, removing any items that don&rsquo;t match the given type(s). * * @template TWhereInstanceOf * * @param class-string&lt;TWhereInstanceOf>|array&lt;array-key, class-string&lt;TWhereInstanceOf&#187; $type * @return static&lt;TKey, TWhereInstanceOf> */ public function whereInstanceOf($type) { return $this->filter(function ($value) use ($type) { if (is_array($type)) { foreach ($type as $classType) { if ($value instanceof $classType) { return true; } } return false; } return $value instanceof $type; }); } /** * Pass the collection to the given callback and return the result. * * @template TPipeReturnType * * @param callable($this): TPipeReturnType $callback * @return TPipeReturnType */ public function pipe(callable $callback) { return $callback($this); } /** * Pass the collection into a new class. * * @template TPipeIntoValue * * @param class-string&lt;TPipeIntoValue> $class * @return TPipeIntoValue */ public function pipeInto($class) { return new $class($this); } /** * Pass the collection through a series of callable pipes and return the result. * * @param array&lt;callable> $callbacks * @return mixed */ public function pipeThrough($callbacks) { return Collection::make($callbacks)->reduce( fn ($carry, $callback) => $callback($carry), $this, ); } /** * Reduce the collection to a single value. * * @template TReduceInitial * @template TReduceReturnType * * @param callable(TReduceInitial|TReduceReturnType, TValue, TKey): TReduceReturnType $callback * @param TReduceInitial $initial * @return TReduceReturnType */ public function reduce(callable $callback, $initial = null) { $result = $initial; foreach ($this as $key => $value) { $result = $callback($result, $value, $key); } return $result; } /** * Reduce the collection to multiple aggregate values. * * @param callable $callback * @param mixed &mldr;$initial * @return array * * @throws \UnexpectedValueException */ public function reduceSpread(callable $callback, &mldr;$initial) { $result = $initial; foreach ($this as $key => $value) { $result = call_user_func_array($callback, array_merge($result, [$value, $key])); if (! is_array($result)) { throw new UnexpectedValueException(sprintf( &ldquo;%s::reduceSpread expects reducer to return an array, but got a &lsquo;%s&rsquo; instead.&rdquo;, class_basename(static::class), gettype($result) )); } } return $result; } /** * Reduce an associative collection to a single value. * * @template TReduceWithKeysInitial * @template TReduceWithKeysReturnType * * @param callable(TReduceWithKeysInitial|TReduceWithKeysReturnType, TValue, TKey): TReduceWithKeysReturnType $callback * @param TReduceWithKeysInitial $initial * @return TReduceWithKeysReturnType */ public function reduceWithKeys(callable $callback, $initial = null) { return $this->reduce($callback, $initial); } /** * Create a collection of all elements that do not pass a given truth test. * * @param (callable(TValue, TKey): bool)|bool|TValue $callback * @return static */ public function reject($callback = true) { $useAsCallable = $this->useAsCallable($callback); return $this->filter(function ($value, $key) use ($callback, $useAsCallable) { return $useAsCallable ? ! $callback($value, $key) : $value != $callback; }); } /** * Pass the collection to the given callback and then return it. * * @param callable($this): mixed $callback * @return $this */ public function tap(callable $callback) { $callback($this); return $this; } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { $callback = $this->valueRetriever($key); $exists = []; return $this->reject(function ($item, $key) use ($callback, $strict, &$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Return only unique items from the collection array using strict comparison. * * @param (callable(TValue, TKey): mixed)|string|null $key * @return static */ public function uniqueStrict($key = null) { return $this->unique($key, true); } /** * Collect the values into a collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue> */ public function collect() { return new Collection($this->all()); } /** * Get the collection of items as a plain array. * * @return array&lt;TKey, mixed> */ public function toArray() { return $this->map(fn ($value) => $value instanceof Arrayable ? $value->toArray() : $value)->all(); } /** * Convert the object into something JSON serializable. * * @return array&lt;TKey, mixed> */ public function jsonSerialize(): array { return array_map(function ($value) { if ($value instanceof JsonSerializable) { return $value->jsonSerialize(); } elseif ($value instanceof Jsonable) { return json_decode($value->toJson(), true); } elseif ($value instanceof Arrayable) { return $value->toArray(); } return $value; }, $this->all()); } /** * Get the collection of items as JSON. * * @param int $options * @return string */ public function toJson($options = 0) { return json_encode($this->jsonSerialize(), $options); } /** * Get a CachingIterator instance. * * @param int $flags * @return \CachingIterator */ public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING) { return new CachingIterator($this->getIterator(), $flags); } /** * Convert the collection to its string representation. * * @return string */ public function __toString() { return $this->escapeWhenCastingToString ? e($this->toJson()) : $this->toJson(); } /** * Indicate that the model&rsquo;s string representation should be escaped when __toString is invoked. * * @param bool $escape * @return $this */ public function escapeWhenCastingToString($escape = true) { $this->escapeWhenCastingToString = $escape; return $this; } /** * Add a method to the list of proxied methods. * * @param string $method * @return void */ public static function proxy($method) { static::$proxies[] = $method; } /** * Dynamically access collection proxies. * * @param string $key * @return mixed * * @throws \Exception */ public function __get($key) { if (! in_array($key, static::$proxies)) { throw new Exception(&ldquo;Property [{$key}] does not exist on this collection instance.&rdquo;); } return new HigherOrderCollectionProxy($this, $key); } /** * Results array of items from Collection or Arrayable. * * @param mixed $items * @return array&lt;TKey, TValue> */ protected function getArrayableItems($items) { if (is_array($items)) { return $items; } return match (true) { $items instanceof WeakMap => throw new InvalidArgumentException(&lsquo;Collections can not be created using instances of WeakMap.&rsquo;), $items instanceof Enumerable => $items->all(), $items instanceof Arrayable => $items->toArray(), $items instanceof \Traversable => iterator_to_array($items), $items instanceof Jsonable => json_decode($items->toJson(), true), $items instanceof JsonSerializable => (array) $items->jsonSerialize(), $items instanceof UnitEnum => [$items], default => (array) $items, }; } /** * Get an operator checker callback. * * @param callable|string $key * @param string|null $operator * @param mixed $value * @return \Closure */ protected function operatorForWhere($key, $operator = null, $value = null) { if ($this->useAsCallable($key)) { return $key; } if (func_num_args() === 1) { $value = true; $operator = &lsquo;=&rsquo;; } if (func_num_args() === 2) { $value = $operator; $operator = &lsquo;=&rsquo;; } return function ($item) use ($key, $operator, $value) { $retrieved = data_get($item, $key); $strings = array_filter([$retrieved, $value], function ($value) { return is_string($value) || (is_object($value) && method_exists($value, &lsquo;__toString&rsquo;)); }); if (count($strings) &lt; 2 && count(array_filter([$retrieved, $value], &lsquo;is_object&rsquo;)) == 1) { return in_array($operator, [&rsquo;!=&rsquo;, &lsquo;&lt;>&rsquo;, &lsquo;!==&rsquo;]); } switch ($operator) { default: case &lsquo;=&rsquo;: case &lsquo;==&rsquo;: return $retrieved == $value; case &lsquo;!=&rsquo;: case &lsquo;&lt;>&rsquo;: return $retrieved != $value; case &lsquo;&lt;&rsquo;: return $retrieved &lt; $value; case &lsquo;>&rsquo;: return $retrieved > $value; case &lsquo;&lt;=&rsquo;: return $retrieved &lt;= $value; case &lsquo;>=&rsquo;: return $retrieved >= $value; case &lsquo;===&rsquo;: return $retrieved === $value; case &lsquo;!==&rsquo;: return $retrieved !== $value; case &lsquo;&lt;=>&rsquo;: return $retrieved &lt;=> $value; } }; } /** * Determine if the given value is callable, but not a string. * * @param mixed $value * @return bool */ protected function useAsCallable($value) { return ! is_string($value) && is_callable($value); } /** * Get a value retrieving callback. * * @param callable|string|null $value * @return callable */ protected function valueRetriever($value) { if ($this->useAsCallable($value)) { return $value; } return fn ($item) => data_get($item, $value); } /** * Make a function to check an item&rsquo;s equality. * * @param mixed $value * @return \Closure(mixed): bool */ protected function equality($value) { return fn ($item) => $item === $value; } /** * Make a function using another function, by negating its result. * * @param \Closure $callback * @return \Closure */ protected function negate(Closure $callback) { return fn (&mldr;$params) => ! $callback(&mldr;$params); } /** * Make a function that returns what&rsquo;s passed to it. * * @return \Closure(TValue): TValue */ protected function identity() { return fn ($value) => $value; } } ?> &lt;?php namespace Illuminate\Support; use ArrayIterator; use Illuminate\Contracts\Support\CanBeEscapedWhenCastToString; use Illuminate\Support\Traits\EnumeratesValues; use stdClass; /** * @template TKey of array-key * * @template-covariant TValue * * @implements \ArrayAccess&lt;TKey, TValue> * @implements \Illuminate\Support\Enumerable&lt;TKey, TValue> */ class Collection implements \ArrayAccess, CanBeEscapedWhenCastToString, Enumerable { /** * @use \Illuminate\Support\Traits\EnumeratesValues&lt;TKey, TValue> */ use EnumeratesValues, Traits\Macroable; /** * The items contained in the collection. * * @var array&lt;TKey, TValue> */ protected $items = []; /** * Create a new collection. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue>|null $items * @return void */ public function __construct($items = []) { $this->items = $this->getArrayableItems($items); } /** * Create a collection with the given range. * * @param int $from * @param int $to * @param int $step * @return static&lt;int, int> */ public static function range($from, $to, $step = 1) { return new static(range($from, $to, $step)); } /** * Get all of the items in the collection. * * @return array&lt;TKey, TValue> */ public function all() { return $this->items; } /** * Get a lazy collection for the items in this collection. * * @return \Illuminate\Support\LazyCollection&lt;TKey, TValue> */ public function lazy() { return new LazyCollection($this->items); } /** * Get the median of a given key. * * @param string|array&lt;array-key, string>|null $key * @return float|int|null */ public function median($key = null) { $values = (isset($key) ? $this->pluck($key) : $this) ->filter(fn ($item) => ! is_null($item)) ->sort()->values(); $count = $values->count(); if ($count === 0) { return; } $middle = (int) ($count / 2); if ($count % 2) { return $values->get($middle); } return (new static([ $values->get($middle - 1), $values->get($middle), ]))->average(); } /** * Get the mode of a given key. * * @param string|array&lt;array-key, string>|null $key * @return array&lt;int, float|int>|null */ public function mode($key = null) { if ($this->count() === 0) { return; } $collection = isset($key) ? $this->pluck($key) : $this; $counts = new static; $collection->each(fn ($value) => $counts[$value] = isset($counts[$value]) ? $counts[$value] + 1 : 1); $sorted = $counts->sort(); $highestValue = $sorted->last(); return $sorted->filter(fn ($value) => $value == $highestValue) ->sort()->keys()->all(); } /** * Collapse the collection of items into a single array. * * @return static&lt;int, mixed> */ public function collapse() { return new static(Arr::collapse($this->items)); } /** * Collapse the collection of items into a single array while preserving its keys. * * @return static&lt;mixed, mixed> */ public function collapseWithKeys() { $results = []; foreach ($this->items as $key => $values) { if ($values instanceof Collection) { $values = $values->all(); } elseif (! is_array($values)) { continue; } $results[$key] = $values; } return new static(array_replace(&mldr;$results)); } /** * Determine if an item exists in the collection. * * @param (callable(TValue, TKey): bool)|TValue|string $key * @param mixed $operator * @param mixed $value * @return bool */ public function contains($key, $operator = null, $value = null) { if (func_num_args() === 1) { if ($this->useAsCallable($key)) { $placeholder = new stdClass; return $this->first($key, $placeholder) !== $placeholder; } return in_array($key, $this->items); } return $this->contains($this->operatorForWhere(&mldr;func_get_args())); } /** * Determine if an item exists, using strict comparison. * * @param (callable(TValue): bool)|TValue|array-key $key * @param TValue|null $value * @return bool */ public function containsStrict($key, $value = null) { if (func_num_args() === 2) { return $this->contains(fn ($item) => data_get($item, $key) === $value); } if ($this->useAsCallable($key)) { return ! is_null($this->first($key)); } return in_array($key, $this->items, true); } /** * Determine if an item is not contained in the collection. * * @param mixed $key * @param mixed $operator * @param mixed $value * @return bool */ public function doesntContain($key, $operator = null, $value = null) { return ! $this->contains(&mldr;func_get_args()); } /** * Cross join with the given lists, returning all possible permutations. * * @template TCrossJoinKey * @template TCrossJoinValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TCrossJoinKey, TCrossJoinValue>|iterable&lt;TCrossJoinKey, TCrossJoinValue> &mldr;$lists * @return static&lt;int, array&lt;int, TValue|TCrossJoinValue&#187; */ public function crossJoin(&mldr;$lists) { return new static(Arr::crossJoin( $this->items, &mldr;array_map([$this, &lsquo;getArrayableItems&rsquo;], $lists) )); } /** * Get the items in the collection that are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @return static */ public function diff($items) { return new static(array_diff($this->items, $this->getArrayableItems($items))); } /** * Get the items in the collection that are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function diffUsing($items, callable $callback) { return new static(array_udiff($this->items, $this->getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys and values are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function diffAssoc($items) { return new static(array_diff_assoc($this->items, $this->getArrayableItems($items))); } /** * Get the items in the collection whose keys and values are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffAssocUsing($items, callable $callback) { return new static(array_diff_uassoc($this->items, $this->getArrayableItems($items), $callback)); } /** * Get the items in the collection whose keys are not present in the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function diffKeys($items) { return new static(array_diff_key($this->items, $this->getArrayableItems($items))); } /** * Get the items in the collection whose keys are not present in the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @param callable(TKey, TKey): int $callback * @return static */ public function diffKeysUsing($items, callable $callback) { return new static(array_diff_ukey($this->items, $this->getArrayableItems($items), $callback)); } /** * Retrieve duplicate items from the collection. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @param bool $strict * @return static */ public function duplicates($callback = null, $strict = false) { $items = $this->map($this->valueRetriever($callback)); $uniqueItems = $items->unique(null, $strict); $compare = $this->duplicateComparator($strict); $duplicates = new static; foreach ($items as $key => $value) { if ($uniqueItems->isNotEmpty() && $compare($value, $uniqueItems->first())) { $uniqueItems->shift(); } else { $duplicates[$key] = $value; } } return $duplicates; } /** * Retrieve duplicate items from the collection using strict comparison. * * @template TMapValue * * @param (callable(TValue): TMapValue)|string|null $callback * @return static */ public function duplicatesStrict($callback = null) { return $this->duplicates($callback, true); } /** * Get the comparison function to detect duplicates. * * @param bool $strict * @return callable(TValue, TValue): bool */ protected function duplicateComparator($strict) { if ($strict) { return fn ($a, $b) => $a === $b; } return fn ($a, $b) => $a == $b; } /** * Get all items except for those with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string $keys * @return static */ public function except($keys) { if (is_null($keys)) { return new static($this->items); } if ($keys instanceof Enumerable) { $keys = $keys->all(); } elseif (! is_array($keys)) { $keys = func_get_args(); } return new static(Arr::except($this->items, $keys)); } /** * Run a filter over each of the items. * * @param (callable(TValue, TKey): bool)|null $callback * @return static */ public function filter(?callable $callback = null) { if ($callback) { return new static(Arr::where($this->items, $callback)); } return new static(array_filter($this->items)); } /** * Get the first item from the collection passing the given truth test. * * @template TFirstDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TFirstDefault|(\Closure(): TFirstDefault) $default * @return TValue|TFirstDefault */ public function first(?callable $callback = null, $default = null) { return Arr::first($this->items, $callback, $default); } /** * Get a flattened array of the items in the collection. * * @param int $depth * @return static&lt;int, mixed> */ public function flatten($depth = INF) { return new static(Arr::flatten($this->items, $depth)); } /** * Flip the items in the collection. * * @return static&lt;TValue, TKey> */ public function flip() { return new static(array_flip($this->items)); } /** * Remove an item from the collection by key. * * \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TKey>|TKey $keys * * @return $this */ public function forget($keys) { foreach ($this->getArrayableItems($keys) as $key) { $this->offsetUnset($key); } return $this; } /** * Get an item from the collection by key. * * @template TGetDefault * * @param TKey $key * @param TGetDefault|(\Closure(): TGetDefault) $default * @return TValue|TGetDefault */ public function get($key, $default = null) { if (array_key_exists($key, $this->items)) { return $this->items[$key]; } return value($default); } /** * Get an item from the collection by key or add it to collection if it does not exist. * * @template TGetOrPutValue * * @param mixed $key * @param TGetOrPutValue|(\Closure(): TGetOrPutValue) $value * @return TValue|TGetOrPutValue */ public function getOrPut($key, $value) { if (array_key_exists($key, $this->items)) { return $this->items[$key]; } $this->offsetSet($key, $value = value($value)); return $value; } /** * Group an associative array by a field or using a callback. * * @template TGroupKey of array-key * * @param (callable(TValue, TKey): TGroupKey)|array|string $groupBy * @param bool $preserveKeys * @return static&lt;($groupBy is string ? array-key : ($groupBy is array ? array-key : TGroupKey)), static&lt;($preserveKeys is true ? TKey : int), TValue&#187; */ public function groupBy($groupBy, $preserveKeys = false) { if (! $this->useAsCallable($groupBy) && is_array($groupBy)) { $nextGroups = $groupBy; $groupBy = array_shift($nextGroups); } $groupBy = $this->valueRetriever($groupBy); $results = []; foreach ($this->items as $key => $value) { $groupKeys = $groupBy($value, $key); if (! is_array($groupKeys)) { $groupKeys = [$groupKeys]; } foreach ($groupKeys as $groupKey) { $groupKey = match (true) { is_bool($groupKey) => (int) $groupKey, $groupKey instanceof \BackedEnum => $groupKey->value, $groupKey instanceof \Stringable => (string) $groupKey, default => $groupKey, }; if (! array_key_exists($groupKey, $results)) { $results[$groupKey] = new static; } $results[$groupKey]->offsetSet($preserveKeys ? $key : null, $value); } } $result = new static($results); if (! empty($nextGroups)) { return $result->map->groupBy($nextGroups, $preserveKeys); } return $result; } /** * Key an associative array by a field or using a callback. * * @template TNewKey of array-key * * @param (callable(TValue, TKey): TNewKey)|array|string $keyBy * @return static&lt;($keyBy is string ? array-key : ($keyBy is array ? array-key : TNewKey)), TValue> */ public function keyBy($keyBy) { $keyBy = $this->valueRetriever($keyBy); $results = []; foreach ($this->items as $key => $item) { $resolvedKey = $keyBy($item, $key); if (is_object($resolvedKey)) { $resolvedKey = (string) $resolvedKey; } $results[$resolvedKey] = $item; } return new static($results); } /** * Determine if an item exists in the collection by key. * * @param TKey|array&lt;array-key, TKey> $key * @return bool */ public function has($key) { $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if (! array_key_exists($value, $this->items)) { return false; } } return true; } /** * Determine if any of the keys exist in the collection. * * @param mixed $key * @return bool */ public function hasAny($key) { if ($this->isEmpty()) { return false; } $keys = is_array($key) ? $key : func_get_args(); foreach ($keys as $value) { if ($this->has($value)) { return true; } } return false; } /** * Concatenate values of a given key as a string. * * @param (callable(TValue, TKey): mixed)|string|null $value * @param string|null $glue * @return string */ public function implode($value, $glue = null) { if ($this->useAsCallable($value)) { return implode($glue ?? &lsquo;&rsquo;, $this->map($value)->all()); } $first = $this->first(); if (is_array($first) || (is_object($first) && ! $first instanceof Stringable)) { return implode($glue ?? &lsquo;&rsquo;, $this->pluck($value)->all()); } return implode($value ?? &lsquo;&rsquo;, $this->items); } /** * Intersect the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersect($items) { return new static(array_intersect($this->items, $this->getArrayableItems($items))); } /** * Intersect the collection with the given items, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectUsing($items, callable $callback) { return new static(array_uintersect($this->items, $this->getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items with additional index check. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function intersectAssoc($items) { return new static(array_intersect_assoc($this->items, $this->getArrayableItems($items))); } /** * Intersect the collection with the given items with additional index check, using the callback. * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TValue>|iterable&lt;array-key, TValue> $items * @param callable(TValue, TValue): int $callback * @return static */ public function intersectAssocUsing($items, callable $callback) { return new static(array_intersect_uassoc($this->items, $this->getArrayableItems($items), $callback)); } /** * Intersect the collection with the given items by key. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, mixed>|iterable&lt;TKey, mixed> $items * @return static */ public function intersectByKeys($items) { return new static(array_intersect_key( $this->items, $this->getArrayableItems($items) )); } /** * Determine if the collection is empty or not. * * @phpstan-assert-if-true null $this->first() * @phpstan-assert-if-true null $this->last() * * @phpstan-assert-if-false TValue $this->first() * @phpstan-assert-if-false TValue $this->last() * * @return bool */ public function isEmpty() { return empty($this->items); } /** * Determine if the collection contains a single item. * * @return bool */ public function containsOneItem() { return $this->count() === 1; } /** * Join all items from the collection using a string. The final items can use a separate glue string. * * @param string $glue * @param string $finalGlue * @return string */ public function join($glue, $finalGlue = &lsquo;&rsquo;) { if ($finalGlue === &lsquo;&rsquo;) { return $this->implode($glue); } $count = $this->count(); if ($count === 0) { return &lsquo;&rsquo;; } if ($count === 1) { return $this->last(); } $collection = new static($this->items); $finalItem = $collection->pop(); return $collection->implode($glue).$finalGlue.$finalItem; } /** * Get the keys of the collection items. * * @return static&lt;int, TKey> */ public function keys() { return new static(array_keys($this->items)); } /** * Get the last item from the collection. * * @template TLastDefault * * @param (callable(TValue, TKey): bool)|null $callback * @param TLastDefault|(\Closure(): TLastDefault) $default * @return TValue|TLastDefault */ public function last(?callable $callback = null, $default = null) { return Arr::last($this->items, $callback, $default); } /** * Get the values of a given key. * * @param string|int|array&lt;array-key, string>|null $value * @param string|null $key * @return static&lt;array-key, mixed> */ public function pluck($value, $key = null) { return new static(Arr::pluck($this->items, $value, $key)); } /** * Run a map over each of the items. * * @template TMapValue * * @param callable(TValue, TKey): TMapValue $callback * @return static&lt;TKey, TMapValue> */ public function map(callable $callback) { return new static(Arr::map($this->items, $callback)); } /** * Run a dictionary map over the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapToDictionaryKey of array-key * @template TMapToDictionaryValue * * @param callable(TValue, TKey): array&lt;TMapToDictionaryKey, TMapToDictionaryValue> $callback * @return static&lt;TMapToDictionaryKey, array&lt;int, TMapToDictionaryValue&#187; */ public function mapToDictionary(callable $callback) { $dictionary = []; foreach ($this->items as $key => $item) { $pair = $callback($item, $key); $key = key($pair); $value = reset($pair); if (! isset($dictionary[$key])) { $dictionary[$key] = []; } $dictionary[$key][] = $value; } return new static($dictionary); } /** * Run an associative map over each of the items. * * The callback should return an associative array with a single key/value pair. * * @template TMapWithKeysKey of array-key * @template TMapWithKeysValue * * @param callable(TValue, TKey): array&lt;TMapWithKeysKey, TMapWithKeysValue> $callback * @return static&lt;TMapWithKeysKey, TMapWithKeysValue> */ public function mapWithKeys(callable $callback) { return new static(Arr::mapWithKeys($this->items, $callback)); } /** * Merge the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function merge($items) { return new static(array_merge($this->items, $this->getArrayableItems($items))); } /** * Recursively merge the collection with the given items. * * @template TMergeRecursiveValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TMergeRecursiveValue>|iterable&lt;TKey, TMergeRecursiveValue> $items * @return static&lt;TKey, TValue|TMergeRecursiveValue> */ public function mergeRecursive($items) { return new static(array_merge_recursive($this->items, $this->getArrayableItems($items))); } /** * Multiply the items in the collection by the multiplier. * * @param int $multiplier * @return static */ public function multiply(int $multiplier) { $new = new static; for ($i = 0; $i &lt; $multiplier; $i++) { $new->push(&mldr;$this->items); } return $new; } /** * Create a collection by using this collection for keys and another for its values. * * @template TCombineValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TCombineValue>|iterable&lt;array-key, TCombineValue> $values * @return static&lt;TValue, TCombineValue> */ public function combine($values) { return new static(array_combine($this->all(), $this->getArrayableItems($values))); } /** * Union the collection with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function union($items) { return new static($this->items + $this->getArrayableItems($items)); } /** * Create a new collection consisting of every n-th element. * * @param int $step * @param int $offset * @return static */ public function nth($step, $offset = 0) { $new = []; $position = 0; foreach ($this->slice($offset)->items as $item) { if ($position % $step === 0) { $new[] = $item; } $position++; } return new static($new); } /** * Get the items with the specified keys. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string|null $keys * @return static */ public function only($keys) { if (is_null($keys)) { return new static($this->items); } if ($keys instanceof Enumerable) { $keys = $keys->all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::only($this->items, $keys)); } /** * Select specific values from the items within the collection. * * @param \Illuminate\Support\Enumerable&lt;array-key, TKey>|array&lt;array-key, TKey>|string|null $keys * @return static */ public function select($keys) { if (is_null($keys)) { return new static($this->items); } if ($keys instanceof Enumerable) { $keys = $keys->all(); } $keys = is_array($keys) ? $keys : func_get_args(); return new static(Arr::select($this->items, $keys)); } /** * Get and remove the last N items from the collection. * * @param int $count * @return static&lt;int, TValue>|TValue|null */ public function pop($count = 1) { if ($count === 1) { return array_pop($this->items); } if ($this->isEmpty()) { return new static; } $results = []; $collectionCount = $this->count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_pop($this->items)); } return new static($results); } /** * Push an item onto the beginning of the collection. * * @param TValue $value * @param TKey $key * @return $this */ public function prepend($value, $key = null) { $this->items = Arr::prepend($this->items, &mldr;func_get_args()); return $this; } /** * Push one or more items onto the end of the collection. * * @param TValue &mldr;$values * @return $this */ public function push(&mldr;$values) { foreach ($values as $value) { $this->items[] = $value; } return $this; } /** * Prepend one or more items to the beginning of the collection. * * @param TValue &mldr;$values * @return $this */ public function unshift(&mldr;$values) { array_unshift($this->items, &mldr;$values); return $this; } /** * Push all of the given items onto the collection. * * @template TConcatKey of array-key * @template TConcatValue * * @param iterable&lt;TConcatKey, TConcatValue> $source * @return static&lt;TKey|TConcatKey, TValue|TConcatValue> */ public function concat($source) { $result = new static($this); foreach ($source as $item) { $result->push($item); } return $result; } /** * Get and remove an item from the collection. * * @template TPullDefault * * @param TKey $key * @param TPullDefault|(\Closure(): TPullDefault) $default * @return TValue|TPullDefault */ public function pull($key, $default = null) { return Arr::pull($this->items, $key, $default); } /** * Put an item in the collection by key. * * @param TKey $key * @param TValue $value * @return $this */ public function put($key, $value) { $this->offsetSet($key, $value); return $this; } /** * Get one or a specified number of items randomly from the collection. * * @param (callable(self&lt;TKey, TValue>): int)|int|null $number * @param bool $preserveKeys * @return static&lt;int, TValue>|TValue * * @throws \InvalidArgumentException */ public function random($number = null, $preserveKeys = false) { if (is_null($number)) { return Arr::random($this->items); } if (is_callable($number)) { return new static(Arr::random($this->items, $number($this), $preserveKeys)); } return new static(Arr::random($this->items, $number, $preserveKeys)); } /** * Replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replace($items) { return new static(array_replace($this->items, $this->getArrayableItems($items))); } /** * Recursively replace the collection items with the given items. * * @param \Illuminate\Contracts\Support\Arrayable&lt;TKey, TValue>|iterable&lt;TKey, TValue> $items * @return static */ public function replaceRecursive($items) { return new static(array_replace_recursive($this->items, $this->getArrayableItems($items))); } /** * Reverse items order. * * @return static */ public function reverse() { return new static(array_reverse($this->items, true)); } /** * Search the collection for a given value and return the corresponding key if successful. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TKey|false */ public function search($value, $strict = false) { if (! $this->useAsCallable($value)) { return array_search($value, $this->items, $strict); } foreach ($this->items as $key => $item) { if ($value($item, $key)) { return $key; } } return false; } /** * Get the item before the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function before($value, $strict = false) { $key = $this->search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this->keys())->search($key); if ($position === 0) { return null; } return $this->get($keys->get($position - 1)); } /** * Get the item after the given item. * * @param TValue|(callable(TValue,TKey): bool) $value * @param bool $strict * @return TValue|null */ public function after($value, $strict = false) { $key = $this->search($value, $strict); if ($key === false) { return null; } $position = ($keys = $this->keys())->search($key); if ($position === $keys->count() - 1) { return null; } return $this->get($keys->get($position + 1)); } /** * Get and remove the first N items from the collection. * * @param int $count * @return static&lt;int, TValue>|TValue|null * * @throws \InvalidArgumentException */ public function shift($count = 1) { if ($count &lt; 0) { throw new InvalidArgumentException(&lsquo;Number of shifted items may not be less than zero.&rsquo;); } if ($this->isEmpty()) { return null; } if ($count === 0) { return new static; } if ($count === 1) { return array_shift($this->items); } $results = []; $collectionCount = $this->count(); foreach (range(1, min($count, $collectionCount)) as $item) { array_push($results, array_shift($this->items)); } return new static($results); } /** * Shuffle the items in the collection. * * @return static */ public function shuffle() { return new static(Arr::shuffle($this->items)); } /** * Create chunks representing a &ldquo;sliding window&rdquo; view of the items in the collection. * * @param int $size * @param int $step * @return static&lt;int, static> */ public function sliding($size = 2, $step = 1) { $chunks = floor(($this->count() - $size) / $step) + 1; return static::times($chunks, fn ($number) => $this->slice(($number - 1) * $step, $size)); } /** * Skip the first {$count} items. * * @param int $count * @return static */ public function skip($count) { return $this->slice($count); } /** * Skip items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipUntil($value) { return new static($this->lazy()->skipUntil($value)->all()); } /** * Skip items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function skipWhile($value) { return new static($this->lazy()->skipWhile($value)->all()); } /** * Slice the underlying collection array. * * @param int $offset * @param int|null $length * @return static */ public function slice($offset, $length = null) { return new static(array_slice($this->items, $offset, $length, true)); } /** * Split a collection into a certain number of groups. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function split($numberOfGroups) { if ($this->isEmpty()) { return new static; } $groups = new static; $groupSize = floor($this->count() / $numberOfGroups); $remain = $this->count() % $numberOfGroups; $start = 0; for ($i = 0; $i &lt; $numberOfGroups; $i++) { $size = $groupSize; if ($i &lt; $remain) { $size++; } if ($size) { $groups->push(new static(array_slice($this->items, $start, $size))); $start += $size; } } return $groups; } /** * Split a collection into a certain number of groups, and fill the first groups completely. * * @param int $numberOfGroups * @return static&lt;int, static> */ public function splitIn($numberOfGroups) { return $this->chunk((int) ceil($this->count() / $numberOfGroups)); } /** * Get the first item in the collection, but only if exactly one item exists. Otherwise, throw an exception. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException * @throws \Illuminate\Support\MultipleItemsFoundException */ public function sole($key = null, $operator = null, $value = null) { $filter = func_num_args() > 1 ? $this->operatorForWhere(&mldr;func_get_args()) : $key; $items = $this->unless($filter == null)->filter($filter); $count = $items->count(); if ($count === 0) { throw new ItemNotFoundException; } if ($count > 1) { throw new MultipleItemsFoundException($count); } return $items->first(); } /** * Get the first item in the collection but throw an exception if no matching items exist. * * @param (callable(TValue, TKey): bool)|string $key * @param mixed $operator * @param mixed $value * @return TValue * * @throws \Illuminate\Support\ItemNotFoundException */ public function firstOrFail($key = null, $operator = null, $value = null) { $filter = func_num_args() > 1 ? $this->operatorForWhere(&mldr;func_get_args()) : $key; $placeholder = new stdClass(); $item = $this->first($filter, $placeholder); if ($item === $placeholder) { throw new ItemNotFoundException; } return $item; } /** * Chunk the collection into chunks of the given size. * * @param int $size * @return static&lt;int, static> */ public function chunk($size) { if ($size &lt;= 0) { return new static; } $chunks = []; foreach (array_chunk($this->items, $size, true) as $chunk) { $chunks[] = new static($chunk); } return new static($chunks); } /** * Chunk the collection into chunks with a callback. * * @param callable(TValue, TKey, static&lt;int, TValue>): bool $callback * @return static&lt;int, static&lt;int, TValue&#187; */ public function chunkWhile(callable $callback) { return new static( $this->lazy()->chunkWhile($callback)->mapInto(static::class) ); } /** * Sort through each item with a callback. * * @param (callable(TValue, TValue): int)|null|int $callback * @return static */ public function sort($callback = null) { $items = $this->items; $callback && is_callable($callback) ? uasort($items, $callback) : asort($items, $callback ?? SORT_REGULAR); return new static($items); } /** * Sort items in descending order. * * @param int $options * @return static */ public function sortDesc($options = SORT_REGULAR) { $items = $this->items; arsort($items, $options); return new static($items); } /** * Sort the collection using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @param bool $descending * @return static */ public function sortBy($callback, $options = SORT_REGULAR, $descending = false) { if (is_array($callback) && ! is_callable($callback)) { return $this->sortByMany($callback, $options); } $results = []; $callback = $this->valueRetriever($callback); // First we will loop through the items and get the comparator from a callback // function which we were given. Then, we will sort the returned values and // grab all the corresponding values for the sorted keys from this array. foreach ($this->items as $key => $value) { $results[$key] = $callback($value, $key); } $descending ? arsort($results, $options) : asort($results, $options); // Once we have sorted all of the keys in the array, we will loop through them // and grab the corresponding model so we can set the underlying items list // to the sorted version. Then we&rsquo;ll just return the collection instance. foreach (array_keys($results) as $key) { $results[$key] = $this->items[$key]; } return new static($results); } /** * Sort the collection using multiple comparisons. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}> $comparisons * @param int $options * @return static */ protected function sortByMany(array $comparisons = [], int $options = SORT_REGULAR) { $items = $this->items; uasort($items, function ($a, $b) use ($comparisons, $options) { foreach ($comparisons as $comparison) { $comparison = Arr::wrap($comparison); $prop = $comparison[0]; $ascending = Arr::get($comparison, 1, true) === true || Arr::get($comparison, 1, true) === &lsquo;asc&rsquo;; if (! is_string($prop) && is_callable($prop)) { $result = $prop($a, $b); } else { $values = [data_get($a, $prop), data_get($b, $prop)]; if (! $ascending) { $values = array_reverse($values); } if (($options & SORT_FLAG_CASE) === SORT_FLAG_CASE) { if (($options & SORT_NATURAL) === SORT_NATURAL) { $result = strnatcasecmp($values[0], $values[1]); } else { $result = strcasecmp($values[0], $values[1]); } } else { $result = match ($options) { SORT_NUMERIC => intval($values[0]) &lt;=> intval($values[1]), SORT_STRING => strcmp($values[0], $values[1]), SORT_NATURAL => strnatcmp((string) $values[0], (string) $values[1]), SORT_LOCALE_STRING => strcoll($values[0], $values[1]), default => $values[0] &lt;=> $values[1], }; } } if ($result === 0) { continue; } return $result; } }); return new static($items); } /** * Sort the collection in descending order using the given callback. * * @param array&lt;array-key, (callable(TValue, TValue): mixed)|(callable(TValue, TKey): mixed)|string|array{string, string}>|(callable(TValue, TKey): mixed)|string $callback * @param int $options * @return static */ public function sortByDesc($callback, $options = SORT_REGULAR) { if (is_array($callback) && ! is_callable($callback)) { foreach ($callback as $index => $key) { $comparison = Arr::wrap($key); $comparison[1] = &lsquo;desc&rsquo;; $callback[$index] = $comparison; } } return $this->sortBy($callback, $options, true); } /** * Sort the collection keys. * * @param int $options * @param bool $descending * @return static */ public function sortKeys($options = SORT_REGULAR, $descending = false) { $items = $this->items; $descending ? krsort($items, $options) : ksort($items, $options); return new static($items); } /** * Sort the collection keys in descending order. * * @param int $options * @return static */ public function sortKeysDesc($options = SORT_REGULAR) { return $this->sortKeys($options, true); } /** * Sort the collection keys using a callback. * * @param callable(TKey, TKey): int $callback * @return static */ public function sortKeysUsing(callable $callback) { $items = $this->items; uksort($items, $callback); return new static($items); } /** * Splice a portion of the underlying collection array. * * @param int $offset * @param int|null $length * @param array&lt;array-key, TValue> $replacement * @return static */ public function splice($offset, $length = null, $replacement = []) { if (func_num_args() === 1) { return new static(array_splice($this->items, $offset)); } return new static(array_splice($this->items, $offset, $length, $this->getArrayableItems($replacement))); } /** * Take the first or last {$limit} items. * * @param int $limit * @return static */ public function take($limit) { if ($limit &lt; 0) { return $this->slice($limit, abs($limit)); } return $this->slice(0, $limit); } /** * Take items in the collection until the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeUntil($value) { return new static($this->lazy()->takeUntil($value)->all()); } /** * Take items in the collection while the given condition is met. * * @param TValue|callable(TValue,TKey): bool $value * @return static */ public function takeWhile($value) { return new static($this->lazy()->takeWhile($value)->all()); } /** * Transform each item in the collection using a callback. * * @param callable(TValue, TKey): TValue $callback * @return $this */ public function transform(callable $callback) { $this->items = $this->map($callback)->all(); return $this; } /** * Flatten a multi-dimensional associative array with dots. * * @return static */ public function dot() { return new static(Arr::dot($this->all())); } /** * Convert a flatten &ldquo;dot&rdquo; notation array into an expanded array. * * @return static */ public function undot() { return new static(Arr::undot($this->all())); } /** * Return only unique items from the collection array. * * @param (callable(TValue, TKey): mixed)|string|null $key * @param bool $strict * @return static */ public function unique($key = null, $strict = false) { if (is_null($key) && $strict === false) { return new static(array_unique($this->items, SORT_REGULAR)); } $callback = $this->valueRetriever($key); $exists = []; return $this->reject(function ($item, $key) use ($callback, $strict, &$exists) { if (in_array($id = $callback($item, $key), $exists, $strict)) { return true; } $exists[] = $id; }); } /** * Reset the keys on the underlying array. * * @return static&lt;int, TValue> */ public function values() { return new static(array_values($this->items)); } /** * Zip the collection together with one or more arrays. * * e.g. new Collection([1, 2, 3])->zip([4, 5, 6]); * => [[1, 4], [2, 5], [3, 6]] * * @template TZipValue * * @param \Illuminate\Contracts\Support\Arrayable&lt;array-key, TZipValue>|iterable&lt;array-key, TZipValue> &mldr;$items * @return static&lt;int, static&lt;int, TValue|TZipValue&#187; */ public function zip($items) { $arrayableItems = array_map(fn ($items) => $this->getArrayableItems($items), func_get_args()); $params = array_merge([fn () => new static(func_get_args()), $this->items], $arrayableItems); return new static(array_map(&mldr;$params)); } /** * Pad collection to the specified length with a value. * * @template TPadValue * * @param int $size * @param TPadValue $value * @return static&lt;int, TValue|TPadValue> */ public function pad($size, $value) { return new static(array_pad($this->items, $size, $value)); } /** * Get an iterator for the items. * * @return \ArrayIterator&lt;TKey, TValue> */ public function getIterator(): \Traversable { return new ArrayIterator($this->items); } /** * Count the number of items in the collection. * * @return int */ public function count(): int { return count($this->items); } /** * Count the number of items in the collection by a field or using a callback. * * @param (callable(TValue, TKey): array-key)|string|null $countBy * @return static&lt;array-key, int> */ public function countBy($countBy = null) { return new static($this->lazy()->countBy($countBy)->all()); } /** * Add an item to the collection. * * @param TValue $item * @return $this */ public function add($item) { $this->items[] = $item; return $this; } /** * Get a base Support collection instance from this collection. * * @return \Illuminate\Support\Collection&lt;TKey, TValue> */ public function toBase() { return new self($this); } /** * Determine if an item exists at an offset. * * @param TKey $key * @return bool */ public function offsetExists($key): bool { return isset($this->items[$key]); } /** * Get an item at a given offset. * * @param TKey $key * @return TValue */ public function offsetGet($key): mixed { return $this->items[$key]; } /** * Set the item at a given offset. * * @param TKey|null $key * @param TValue $value * @return void */ public function offsetSet($key, $value): void { if (is_null($key)) { $this->items[] = $value; } else { $this->items[$key] = $value; } } /** * Unset the item at a given offset. * * @param TKey $key * @return void */ public function offsetUnset($key): void { unset($this->items[$key]); } } ?> &lt;?php class Product { private string $title; private string $description; private int $price; private string $currency; private string $category; private string $brand; private Collection $options; /** * @param string $title * @param string $description * @param int $price * @param string $currency * @param string $category * @param string $brand * @param Collection $options */ public function __construct(string $title, string $description, int $price, string $currency, string $category, string $brand, Collection $options) { $this->title = $title; $this->description = $description; $this->price = $price; $this->currency = $currency; $this->category = $category; $this->brand = $brand; $this->options = $options; } /** * @return string */ public function getTitle(): string { return $this->title; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @return string */ public function getDescription(): string { return $this->description; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @return int */ public function getPrice(): int { return $this->price; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } /** * @return string */ public function getCurrency(): string { return $this->currency; } /** * @param string $currency */ public function setCurrency(string $currency): void { $this->currency = $currency; } /** * @return string */ public function getCategory(): string { return $this->category; } /** * @param string $category */ public function setCategory(string $category): void { $this->category = $category; } /** * @return string */ public function getBrand(): string { return $this->brand; } /** * @param string $brand */ public function setBrand(string $brand): void { $this->brand = $brand; } /** * @return Collection */ public function getOptions(): array { return $this->options; } /** * @param Collection $options */ public function setOptions(Collection $options): void { $this->options = $options; } } class Option { private string $title; private string $description; private int $price; private Collection $items; /** * @param string $title * @param string $description * @param int $price * @param Collection $items */ public function __construct(string $title, string $description, int $price, Collection $items) { $this->title = $title; $this->description = $description; $this->price = $price; $this->items = $items; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } /** * @param Collection $items */ public function setItems(Collection $items): void { $this->items = $items; } } class OptionItem { private string $title; private string $description; private int $price; /** * @param string $title * @param string $description * @param int $price */ public function __construct(string $title, string $description, int $price) { $this->title = $title; $this->description = $description; $this->price = $price; } /** * @param string $title */ public function setTitle(string $title): void { $this->title = $title; } /** * @param string $description */ public function setDescription(string $description): void { $this->description = $description; } /** * @param int $price */ public function setPrice(int $price): void { $this->price = $price; } } $products = new Collection(); $start = microtime(true); for ($k = 0; $k &lt;= 1000; $k++) { $options = new Collection(); for ($j = 0; $j &lt;= 10; $j++) { $optionItems = new Collection(); for ($i = 0; $i &lt;= 100; $i++) { $optionItem = new Collection(new OptionItem(title: &lsquo;OptionItem&rsquo; . $i, description: &lsquo;OptionItem &rsquo; . $i . &rsquo; Description&rsquo;, price: random_int(1000, 10000))); $optionItems->add($optionItem); } $option = new Collection(new Option(title: &lsquo;Option&rsquo; . $j, description: &lsquo;Option &rsquo; . $j . &rsquo; Description&rsquo;, price: random_int(1000, 10000), items: $optionItems)); $options->add($option); } $products->add(new Collection(new Product(title: &lsquo;Product&rsquo; . $k, description: &lsquo;Product &rsquo; . $k . &rsquo; Description&rsquo;, price: random_int(1000, 10000), currency: &lsquo;USD&rsquo;, category: &lsquo;Category&rsquo; . $k, brand: &lsquo;Brand&rsquo; . $k, options: $options))); } $end = microtime(true); echo &lsquo;Memory Peak Usage: &rsquo; . (memory_get_peak_usage(true) / 1024 / 1024) . &rsquo; MB&rsquo; . &lsquo;&lt;br>&rsquo;; echo &lsquo;Execution Time: &rsquo; . round($end - $start, 2) . &rsquo; seconds&rsquo; . &lsquo;&lt;br>&rsquo;;</td></tr></tbody></table></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2024-12-15</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/2022/08/11/vscode-git-private-key-%EC%98%A4%EB%A5%98/ class=prev rel=prev title="VSCode Git Private Key 오류"><i class="fas fa-angle-left fa-fw"></i>VSCode Git Private Key 오류</a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.110.0">Hugo</a>&nbsp;|&nbsp;Theme - <a href=https://github.com/HEIGE-PCloud/DoIt target=_blank rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank rel="noopener noreferrer">hodory</a></span></div><div class=footer-line></div><div class=footer-line></div></div></footer></div><div id=fixed-buttons><a href=#back-to-top id=back-to-top-button class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw"></i></a></div><div class=assets><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/js/theme.min.js defer></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","360040228",{anonymize_ip:!0})</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=360040228" async></script></div></body></html>