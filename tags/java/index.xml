<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Java - Tag - Web Developer Hodory</title><link>http://blog.hodory.dev/tags/java/</link><description>Java - Tag - Web Developer Hodory</description><generator>Hugo -- gohugo.io</generator><language>ko</language><managingEditor>master@hodory.dev (hodory)</managingEditor><webMaster>master@hodory.dev (hodory)</webMaster><lastBuildDate>Wed, 10 Aug 2022 23:04:49 +0000</lastBuildDate><atom:link href="http://blog.hodory.dev/tags/java/" rel="self" type="application/rss+xml"/><item><title>[Java] Spring AOP 에서 Custom Exception 사용하기</title><link>http://blog.hodory.dev/2022/08/10/springboot-spring-aop-%EC%97%90%EC%84%9C-custom-exception-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</link><pubDate>Wed, 10 Aug 2022 23:04:49 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2022/08/10/springboot-spring-aop-%EC%97%90%EC%84%9C-custom-exception-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/</guid><description><![CDATA[<h2 id="spring-aop에서-custom-exception-사용하기" class="headerLink">
    <a href="#spring-aop%ec%97%90%ec%84%9c-custom-exception-%ec%82%ac%ec%9a%a9%ed%95%98%ea%b8%b0" class="header-mark"></a>Spring AOP에서 Custom Exception 사용하기</h2><p>Spring AOP는 CglibAopProxy 클래스를 이용하여 동작합니다.</p>
<p>아래 코드와 같이 super.process() 를 try-catch로 처리하고 있고, Runtime Exception은 exception 을 그대로 던질 수 있기 때문에
Custom Exception은 Exception 클래스가 아니라 RuntimeException을 상속받아서 사용해야 합니다</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Override</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Nullable</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="n">Object</span> <span class="nf">proceed</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Throwable</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">try</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">proceed</span><span class="o">();</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">catch</span> <span class="o">(</span><span class="n">RuntimeException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">catch</span> <span class="o">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="o">(</span><span class="n">ReflectionUtils</span><span class="o">.</span><span class="na">declaresException</span><span class="o">(</span><span class="n">getMethod</span><span class="o">(),</span> <span class="n">ex</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">                <span class="n">KotlinDetector</span><span class="o">.</span><span class="na">isKotlinType</span><span class="o">(</span><span class="n">getMethod</span><span class="o">().</span><span class="na">getDeclaringClass</span><span class="o">()))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Propagate original exception if declared on the target method
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// (with callers expecting it). Always propagate it for Kotlin code
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// since checked exceptions do not have to be explicitly declared there.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">throw</span> <span class="n">ex</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// Checked exception thrown in the interceptor but not declared on the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// target method signature -&gt; apply an UndeclaredThrowableException,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// aligned with standard JDK dynamic proxy behavior.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">throw</span> <span class="k">new</span> <span class="n">UndeclaredThrowableException</span><span class="o">(</span><span class="n">ex</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">        <span class="o">}</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><figure><a class="lightgallery" href="/images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png" title="/images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png" data-thumbnail="/images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png">
        <img
            
            loading="lazy"
            src="/images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png"
            srcset="/images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png, /images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png 1.5x, /images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png 2x"
            sizes="auto"
            alt="/images/images_jsj3282_post_eeb0e722-571b-424b-bf3f-c50b24465e8c_v2naj.png">
    </a></figure></p>
]]></description></item><item><title>［Java］Spring REST Docs HTML이 생성되지 않을때</title><link>http://blog.hodory.dev/2019/12/04/spring-rest-docs-with-gradle-not-working-html5/</link><pubDate>Wed, 04 Dec 2019 23:39:14 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/12/04/spring-rest-docs-with-gradle-not-working-html5/</guid><description><![CDATA[<p>백기선님의 스프링부트 강좌를 수강하는중에 Spring REST Docs를 이용하여 HTML을 생성하려하는데,<!-- raw HTML omitted -->
아무리 빌드를 해도 <code>ascii\html\index.html</code>이 생성되지 않았습니다.</p>
<pre tabindex="0"><code>오후 11:58:18: Executing task &#39;build&#39;...

&gt; Task :compileJava
&gt; Task :processResources
&gt; Task :classes
&gt; Task :compileTestJava
&gt; Task :processTestResources NO-SOURCE
&gt; Task :testClasses

&gt; Task :test
2019-12-02 23:58:35.629  INFO 24376 --- [       Thread-5] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService &#39;applicationTaskExecutor&#39;
2019-12-02 23:58:35.629  INFO 24376 --- [       Thread-7] o.s.s.concurrent.ThreadPoolTaskExecutor  : Shutting down ExecutorService &#39;applicationTaskExecutor&#39;
2019-12-02 23:58:35.630  INFO 24376 --- [       Thread-7] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &#39;default&#39;
2019-12-02 23:58:35.630  INFO 24376 --- [       Thread-5] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit &#39;default&#39;
2019-12-02 23:58:35.630  INFO 24376 --- [       Thread-7] .SchemaDropperImpl$DelayedDropActionImpl : HHH000477: Starting delayed evictData of schema as part of SessionFactory shut-down&#39;
2019-12-02 23:58:35.630  INFO 24376 --- [       Thread-5] .SchemaDropperImpl$DelayedDropActionImpl : HHH000477: Starting delayed evictData of schema as part of SessionFactory shut-down&#39;
2019-12-02 23:58:35.637  INFO 24376 --- [       Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2019-12-02 23:58:35.642  INFO 24376 --- [       Thread-5] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
2019-12-02 23:58:35.733 ERROR 24376 --- [       Thread-7] .SchemaDropperImpl$DelayedDropActionImpl : HHH000478: Unsuccessful: drop table event if exists
2019-12-02 23:58:35.734  INFO 24376 --- [       Thread-7] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Shutdown initiated...
2019-12-02 23:58:35.739  INFO 24376 --- [       Thread-7] com.zaxxer.hikari.HikariDataSource       : HikariPool-2 - Shutdown completed.

&gt; Task :asciidoctor NO-SOURCE
&gt; Task :bootJar
&gt; Task :jar SKIPPED
&gt; Task :assemble
&gt; Task :check
&gt; Task :build

BUILD SUCCESSFUL in 18s
5 actionable tasks: 5 executed
오후 11:58:36: Task execution finished &#39;build&#39;.
</code></pre><p>cli를 들여다보니, 위와 같이 노출이 되는데 자세히 들여다보면 <code>&gt; Task :asciidoctor NO-SOURCE</code> 가 있습니다.</p>
<p>의존성문제인줄알고 버전도 변경 하여 보고 build.gradle 파일의 코드가 잘못되었거나,<!-- raw HTML omitted -->
버전이 올라가면서 변경점이 있는지 체크해보았으나 다른점이 없어 검색을 하였더니
asciidoctor sourceDirectory가 Maven 플러그인에서는 <code>src/main/asciidoc</code>이지만, Gradle 플러그인은 sourceDirectory가 <code>/src/docs/asciidoc</code> 였습니다.
또한 Spring-REST-Docs에 의해 생성되는 경로도 아래 이미지와 같이 달랐습니다</p>
<p><figure><a class="lightgallery" href="/images/spring-rest-docs-with-gradle-not-working-html5/1.png" title="JUnitRestDocumentation rule" data-thumbnail="/images/spring-rest-docs-with-gradle-not-working-html5/1.png">
        <img
            
            loading="lazy"
            src="/images/spring-rest-docs-with-gradle-not-working-html5/1.png"
            srcset="/images/spring-rest-docs-with-gradle-not-working-html5/1.png, /images/spring-rest-docs-with-gradle-not-working-html5/1.png 1.5x, /images/spring-rest-docs-with-gradle-not-working-html5/1.png 2x"
            sizes="auto"
            alt="JUnitRestDocumentation rule">
    </a></figure></p>
<p>Maven을 사용해 본 적이 없어서 gradle과 플러그인도 동일할줄 알았는데,<!-- raw HTML omitted -->
빌드 결과물도 다른 디렉토리에 생성되고 실행가능한 명령어들도 다른것을 알 수 있었습니다.</p>
<blockquote>
<p>참고자료</p>
</blockquote>
<hr>
<ul>
<li><a href="https://github.com/asciidoctor/asciidoctor-maven-plugin" target="_blank" rel="noopener noreferrer">Github - asciidoctor Maven Plugin</a></li>
<li><a href="https://asciidoctor.org/docs/asciidoctor-gradle-plugin/" target="_blank" rel="noopener noreferrer">Docs - asciidoctor Gradle Plugin</a></li>
<li><a href="https://docs.spring.io/spring-restdocs/docs/2.0.4.RELEASE/reference/html5/#getting-started-documentation-snippets" target="_blank" rel="noopener noreferrer">Docs - Spring REST Docs#Generating Documentation Snippets</a></li>
</ul>
]]></description></item><item><title>［Java］해당 클래스의 서비스는 어디서 주입되나요??</title><link>http://blog.hodory.dev/2019/06/05/where-is-constructor-inject/</link><pubDate>Wed, 05 Jun 2019 11:40:37 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/06/05/where-is-constructor-inject/</guid><description><![CDATA[<p>회사 업무중 스프링 서비스 코드 푸시를 하였습니다.</p>
<p>다른 팀원들에게</p>
<blockquote>
<p>인터페이스를 파라미터로 정의한것은 확인하였는데,<!-- raw HTML omitted -->
혹시 해당 컨트롤러에 주입은 어디에서 되나요?`</p>
</blockquote>
<p>라는 질문을 들었습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RequiredArgsConstructor</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">YourController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">YourService</span> <span class="n">yourService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>위와같이 컨트롤러가 선언되어있었습니다.(물론 예제입니다.)</p>
<!-- raw HTML omitted -->
<p>해당 클래스의 <code>yourService</code>에 <code>YourServiceImpl(인터페이스 구현체)</code>는 어떻게 주입이 되는걸까요?</p>
<p>아직도 스프링의 <code>Application Context</code>에 의한 DI(의존성 주입)가 저는 이해하기 어려운것 같습니다.</p>
<p>인터페이스의 구현체가 Service 어노테이션을 사용해서 <code>Application Context</code>에 의해 관리되는 <code>Bean</code>으로 등록되면,</p>
<p>해당 인터페이스에 자동으로 주입이됩니다<!-- raw HTML omitted -->
(이 부분은 정말 신기하다고 생각합니다.<!-- raw HTML omitted -->
<del>제가 PHP 개발자이고, Laravel 프레임워크의 간결함과 모던함을 좋아하는데,<!-- raw HTML omitted -->
이렇게까지 사용해본적이 없어,<!-- raw HTML omitted -->
해당 프레임워크 뿐 아니라, 다른 언어나 프레임워크에서도 이와같이 주입이 되는지 확답을 쓸 수 없습니다.</del>
)</p>
<hr>
<p>2019.06.09 추가 :</p>
<p><a href="https://ko.wikipedia.org/wiki/%EC%9D%98%EC%A1%B4%EC%84%B1_%EC%A3%BC%EC%9E%85" target="_blank" rel="noopener noreferrer">의존성 주입</a></p>
<blockquote>
<p>의존성 주입(Dependency Injection, DI)은 프로그래밍에서 구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나이다.</p>
</blockquote>
<p>DI는 그저 디자인 패턴으로 어디에서든 구현 가능합니다.<!-- raw HTML omitted -->
예시로 <a href="https://laravel.kr/docs/5.8/container#%EC%9E%90%EB%8F%99%20%EC%A3%BC%EC%9E%85" target="_blank" rel="noopener noreferrer">Laravel 5.8 - 자동주입</a>과 같이
다른 프레임워크에서도 스프링처럼 DI가 구현되어 있습니다.</p>
<hr>
<p>일반적으로 해당 클래스에 구현체를 주입하기 위해서는</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * controller/YourController.java
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">YourController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">YourService</span> <span class="n">yourService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">YouController</span><span class="o">(</span><span class="n">YourServiceImpl</span> <span class="n">yourService</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">yourService</span> <span class="o">=</span> <span class="n">yourService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * service/YourService.java
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">YourService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">whatYouCall</span><span class="o">();</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">---</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm"> * service/impl/YourServiceImpl.java
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">YourServiceImpl</span> <span class="kd">implements</span> <span class="n">YourService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Override</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">whatYouCall</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>위와 같이 구현했을것입니다.</p>
<p>클래스에 <code>YourService</code>라는 Interface를 프로퍼티로 선언한 후,<!-- raw HTML omitted -->
해당 클래스에 <code>YourSericeImpl</code>을 주입하여 주는것이죠.</p>
<p>일반적으로 제가 생각하는 방식 또한 위와 같으나,<!-- raw HTML omitted -->
<code>Spring Framework</code>는 해당 클래스에 <code>Spring Bean</code>을 주입해줍니다.(????)</p>
<p><code>@Service</code> 어노테이션을 이용하여 <code>YourServiceImpl</code> 클래스는 <code>YourService</code>의 구현체로 스프링어플리케이션의 빈에 등록이 됩니다.<!-- raw HTML omitted -->
더불어, 스프링의 DI에 의해 YourService에 주입될 때는 해당 인터페이스의 구현체가 주입이 되게 되죠&hellip;..</p>
<p>같은 인터페이스의 구현체가 여러개일 경우는 어떻게 해야할까요?</p>
<pre tabindex="0"><code>1. 위의 코드와 같이 구현 클래스를 주입 받는 걸로 바꾼다.
2. `@Qualifier` 어노테이션을 이용한다.
3. 스프링 빈의 네임 기반으로 해야한다.
</code></pre><p>제가 아는 방안은 위와 같은 세가지 방안입니다.<!-- raw HTML omitted -->
(해당 부분을 가르쳐주신 <a href="https://jheloper.github.io/" target="_blank" rel="noopener noreferrer">@jhkim</a>님 감사합니다)</p>
<hr>
<p>위와 같은 개념을 이해하였다면 Lombok을 사용하여 해당 부분을 더 간소화 시킬 수 있습니다.</p>
<p><code>@RequiredArgsConstructor</code>은 어떻게 동작할까요?</p>
<p>해당 어노테이션 인터페이스의 주석을 보면 이와 같습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Generates</span> <span class="n">a</span> <span class="n">constructor</span> <span class="n">with</span> <span class="n">required</span> <span class="n">arguments</span><span class="o">.</span>
</span></span><span class="line"><span class="cl"><span class="n">Required</span> <span class="n">arguments</span> <span class="n">are</span> <span class="kd">final</span> <span class="n">fields</span> <span class="n">and</span> <span class="n">fields</span> <span class="n">with</span> <span class="n">constraints</span> <span class="n">such</span> <span class="n">as</span> <span class="o">{</span><span class="nd">@code</span> <span class="nd">@NonNull</span><span class="o">}.</span>
</span></span></code></pre></div><p>위의 주석에 따르면 <code>final</code>로 선언된 필드를 매개변수로 갖는 생성자를 자동 생성하여줍니다.</p>
<p><a href="https://hodory.github.io/2019/05/28/required-a-bean-of-type-that-could-not-be-found/" target="_blank" rel="noopener noreferrer">이전의 실수 - AllArgsConstructor의 잘못된 사용</a>를 통해 배울 수 있던 부분입니다.</p>
<p><code>@RequiredArgsConstructor</code> 어노테이션과 함께 <!-- raw HTML omitted -->
<code>private final YourService yourService;</code> 이와 같이 선언 할 경우,<!-- raw HTML omitted -->
해당 코드는 컴파일시 아래와 같이 변환됩니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@RestController</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">YourController</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">YourService</span> <span class="n">yourService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">YouController</span><span class="o">(</span><span class="n">YourService</span> <span class="n">yourService</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">yourService</span> <span class="o">=</span> <span class="n">yourService</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>    
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>위에서 본 코드와 유사해지는데요</p>
<p>이와 같이 Lombok 어노테이션은 생성자를 직접 만들어주기때문에 간결한 코드를 유지할 수 있습니다.</p>
<p>허나 위의 코드와 다른점은 <code>YourService</code>를 생성자의 파라미터 타입으로 주느냐, <code>YourServiceImpl</code>을 생성자 파라미터 타입으로 주느냐의 차이인데</p>
<p>위에 언급한바와 같이, 스프링 DI는 스프링 빈에 등록된 클래스를 주입합니다.</p>
<p>고로, <code>YourService</code> 타입이지만, <code>YourServiceImpl</code> 클래스가 해당 인터페이스를 구현한 구현체이며, 스프링빈으로 등록되어 있기 때문에,<!-- raw HTML omitted -->
해당 클래스가 주입이됩니다.</p>
<hr>
<p>포스팅의 잘못된 부분이 있다면 코멘트 또는 메일로 보내주시면<!-- raw HTML omitted -->
부족한 부분은 보완하고, 틀린 부분은 수정하겠습니다<!-- raw HTML omitted -->
아직 프로그래밍에 서툴어서 제가 이해한 개념과 다를 수 있는데, 많은 도움 부탁드리겠습니다.</p>
<p>끝으로 긴 글을 읽어주셔서 감사합니다.</p>
]]></description></item><item><title>［Java］@JsonProperty이 왜 동작을 안하지?</title><link>http://blog.hodory.dev/2019/06/04/json-property-not-working/</link><pubDate>Tue, 04 Jun 2019 23:13:03 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/06/04/json-property-not-working/</guid><description><![CDATA[<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">anonymousDTO</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">whatYouWant</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>대부분 자바의 변수를 생성할때 위와 같이 CamelCase를 많이 쓰는것으로 알고있습니다&hellip;..(본인이 잘못 생각하는것일 수 있습니다.)</p>
<p>필자 또한 위와 같이 <code>camelCase</code>를 사용하였으나 API 통신 및 응답을 리턴할때에는<!-- raw HTML omitted -->
<code>hyphen uppercase</code>가 필요했습니다.</p>
<!-- raw HTML omitted -->
<p>위의 조건을 충족하기 위해 적절한 어노테이션을 찾았는데,<!-- raw HTML omitted -->
<code>@JsonProperty(&quot;{WHAT_YOU_WANT}&quot;)</code>였습니다.</p>
<p>json으로 매핑할때 <code>WHAT_YOU_WANT</code>에 들어갈 값으로 해당 프로퍼티를 매핑하는것이였습니다.</p>
<p>테스트 코드를 작성하여 확인해보았지만 정상 동작하지 않아,</p>
<p>주위의 도움을 받았는데,<!-- raw HTML omitted -->
<code>getter</code>메소드에 해당 어노테이션을 작성해야한다는 조언도 있었으며,<!-- raw HTML omitted -->
<code>compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind'</code><!-- raw HTML omitted -->
해당 라이브러리를 gradle에 추가하여 jackson 라이브러리를 최신화 할 필요가 있다는 조언을 받았습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Getter</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Setter</span>
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">anonymousDTO</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@JsonProperty</span><span class="o">(</span><span class="s">&#34;WHAT-YOU-WANT&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">whatYouWant</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">anonymousDTO</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">whatYouWant</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nd">@JsonProperty</span><span class="o">(</span><span class="s">&#34;WHAT-YOU-WANT&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getWhatYouWant</span><span class="o">()</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">whatYouWant</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>많은 주위의 도움을 받아 위와 같이 두가지 방법을적용해 보았으나, 기대하는 결과를 얻을 수 없었습니다.<!-- raw HTML omitted -->
(에러나 Exception은 발생하지 않았으나, 요청에 대한 응답을 모델에 매핑하였으나, Null 값이 해당 프로퍼티에 매핑되었습니다.)</p>
<p>오랜 삽질 끝에 얻은 결과는<!-- raw HTML omitted -->
제가 요청에 대한 json Object 응답을 <code>Gson</code>을 이용하여 해당타입으로 받았는데,
jackson의 json object로 매핑하였고, jackson의 어노테이션인 <code>@JsonProperty</code>가 기대와 다르게 동작하여,
검색하였는데 <code>@SerializedName</code> 어노테이션으로 해결할 수 있다는 StackOverFlow에서의 답변이였습니다.</p>
<p>그리하여 해당 코드를 이와같이 변경하였습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Getter</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Setter</span>
</span></span><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">anonymousDTO</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@SerializedName</span><span class="o">(</span><span class="s">&#34;WHAT-YOU-WANT&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">whatYouWant</span><span class="o">;</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>Gson을 이용할 때에는 <code>@SerializedName</code>을 사용해야하고 jackson을 사용할때에는 <code>@JsonProperty</code>를 사용해야 한다는데<!-- raw HTML omitted -->
레거시 PHP와 JS를 좋아하는 저로써는 똑같은 json object 이고, 사실상 <code>JsonObject</code>라는 타입인데,<!-- raw HTML omitted -->
Gson의 json 이냐 jackson의 json이냐에 따라 다른 어노테이션을 써야한다는게 이해하기 어려웠습니다.</p>
<p>지난번, 어노테이션을 사용할때에도 해당 어노테이션이 어떻게 동작하는지 유의를 하며 써야겠다고 다짐했으나,<!-- raw HTML omitted -->
결국 빠른 결과물과 편리함을 추구하다보니, 많이 사용하는 어노테이션을 그저 가져다 쓰는데에만 중점을 두었습니다.</p>
<p>제가 여태까지 사용해온 레거시 php 나 js는 이와 같은 강타입 언어가 아니다보니, 해당 어노테이션도 없을 뿐만 아니라,<!-- raw HTML omitted -->
그저 모델 클래스를 만들 필요없이 변수에 담을 수 있었는데,<!-- raw HTML omitted -->
이러한 부분이 어렵기도 하고, 긍정적인 시각으로 바라보았을때는 어느정도 타입체킹이 되고, 개발자 입장에선 복잡도는 증가하지만,<!-- raw HTML omitted -->
조금 더 안정적이지 않을까 싶기도 합니다.</p>
<p>물론 제가 다른 대안으로 생각하는 <code>TypeScript</code>와 <code>PHP v7.x</code>도 있지만요&hellip;</p>
]]></description></item><item><title>［Java］@AllArgsConstructor의 잘못된 사용</title><link>http://blog.hodory.dev/2019/05/28/required-a-bean-of-type-that-could-not-be-found/</link><pubDate>Tue, 28 May 2019 23:29:30 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/05/28/required-a-bean-of-type-that-could-not-be-found/</guid><description><![CDATA[<h1 id="consider-defining-a-bean-of-type-javalangstring-in-your-configuration" class="headerLink">
    <a href="#consider-defining-a-bean-of-type-javalangstring-in-your-configuration" class="header-mark"></a>Consider defining a bean of type java.lang.String in your configuration.</h1><p>스프링부트로 서비스를 개발중에 <code>@Value</code> 어노테이션을 이용하여 application.yml 파일에 저장해둔 환경변수에 접근하고 싶었는데,<!-- raw HTML omitted -->
아래와 같은 오류가 발생하였습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">Parameter <span class="m">2</span> of constructor in com.hodory.v1.service.MyService required a bean of <span class="nb">type</span> <span class="s1">&#39;java.lang.String&#39;</span> that could not be found.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Consider defining a bean of <span class="nb">type</span> <span class="s1">&#39;java.lang.String&#39;</span> in your configuration.
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>Retrofit을 사용하기위해 apiBaseUrl을 가져오려 작성한 코드는 아래와 같습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="nd">@AllArgsConstructor</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ModelMapper</span> <span class="n">modelMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Value</span><span class="o">(</span><span class="s">&#34;${config.endpoint.url}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">serviceUrl</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>필드에 <code>@Autowired</code>를 사용하는것은 권장하지 않는다는 IDE에서 나오는 메세지때문에 이 방식은 사용하지 않았습니다.</p>
<p>생성자를 이용한 주입이 아닌 <code>@AllArgsConstructor</code> 어노테이션을 사용한 이유는<!-- raw HTML omitted -->
이전에 사용하였을때, 생성자를 이용해 직접 주입하는 방식보다, 의존성 주입 할 대상이 많아졌을때 훨씬 더 깔끔하였던 경험이 있어,<!-- raw HTML omitted -->
해당 어노테이션을 사용하였습니다.</p>
<p><code>private String serviceUrl</code> 을 추가하고나서부터 해당 오류가 나타났습니다.</p>
<p>한참을 고민하다가 팀원들의 도움을 받아 원인을 알게 되었는데,</p>
<p><code>serviceUrl</code>이라는 값은 <code>String</code> 타입의 변수일 뿐, 스프링에서 관리하는 Bean이 아니기 때문에 의존성 자동 주입이 될 수 없다는것이였습니다.</p>
<p><code>@Value</code>를 사용하면 자동 주입이 되는줄 알았는데, 제가 생각했던것과 달랐습니다.</p>
<p>아래와 같이 스프링 애플리케이션에 의해 자동 주입 가능한 필드들을 파라미터로 가진 생성자를 만들어 필드에 매핑하도록 수정 하였더니,<!-- raw HTML omitted -->
오류 없이 serviceUrl에 application.yml파일에 있던 url도 설정 되어 있었습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span>
</span></span><span class="line"><span class="cl"><span class="nd">@Service</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="kd">final</span> <span class="n">ModelMapper</span> <span class="n">modelMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="nd">@Value</span><span class="o">(</span><span class="s">&#34;${config.endpoint.url}&#34;</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="n">String</span> <span class="n">serviceUrl</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nd">@Autowired</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(</span><span class="n">MyRepository</span> <span class="n">repository</span><span class="o">,</span> <span class="n">ModelMapper</span> <span class="n">modelMapper</span><span class="o">)</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">repository</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="o">.</span><span class="na">modelMapper</span> <span class="o">=</span> <span class="n">modelMapper</span><span class="o">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>위와 같이 생성자에 직접 필요한 Bean들을 명시하여 주입 하는 방식 말고도<!-- raw HTML omitted -->
기존 코드에서 <code>@AllArgsConstructor</code> 대신 <code>@RequiredArgsConstructor</code> 어노테이션을 사용하기만 하면,<!-- raw HTML omitted -->
<code>final</code>로 선언된 필드나 <code>@NonNull</code> 어노테이션을 사용한 필드만을 필요로 하는 생성자를 만들어주기 때문에,<!-- raw HTML omitted -->
이 경우에는 원하는 결과를 얻을 수 있었습니다.</p>
<p>자바에도 익숙 하지 않고, 의존성 주입이라는 개념에 대해 익숙하지 않은데,<!-- raw HTML omitted -->
원리를 파악하지 않고, 남들을 따라하는 기존의 자세에 반성하는 계기가 되었으며,</p>
<p>어노테이션을 사용 할 때 해당 어노테이션이 해주는 기능만 파악 하는 것 만큼<!-- raw HTML omitted -->
어떻게 동작하는지(예를 들어 <code>lombok</code>의 경우 어떤 코드를 생성 해주는지)등을 유의하며 사용해야겠다고 느꼈습니다.</p>
]]></description></item><item><title>［Java］스프링부트 회원 기존 비밀번호 체크하기</title><link>http://blog.hodory.dev/2019/05/14/spring-boot-validate-user-old-password/</link><pubDate>Tue, 14 May 2019 15:42:32 +0000</pubDate><author><name>hodory</name></author><guid>http://blog.hodory.dev/2019/05/14/spring-boot-validate-user-old-password/</guid><description><![CDATA[<p>회원 비밀번호 변경 로직을 작성중에 현재 비밀번호와 새 비밀번호를 입력받아,<!-- raw HTML omitted -->
기존 비밀번호가 맞는지 체크하는 로직을 넣고 싶었습니다.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span> <span class="n">currentPassword</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BCryptPasswordEncoder</span><span class="o">().</span><span class="na">encode</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getCurrentPassword</span><span class="o">());</span>	
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">User</span> <span class="n">persistUser</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findUserByIdAndPassword</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">currentPassword</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">        <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">EntityNotFoundException</span><span class="o">(</span><span class="s">&#34;회원정보를 찾을 수 없습니다.&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="o">(!</span><span class="n">currentPassword</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">persistUser</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()))</span> <span class="o">{</span>	
</span></span><span class="line"><span class="cl">    <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;changePassword is Not Equal Current Password&#34;</span><span class="o">);</span>	
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">UserRegisterResult</span><span class="o">.</span><span class="na">ERROR</span><span class="o">.</span><span class="na">getResponseBody</span><span class="o">(),</span>	
</span></span><span class="line"><span class="cl">            <span class="n">HttpStatus</span><span class="o">.</span><span class="na">FORBIDDEN</span><span class="o">);</span>	
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p><code>new BCryptPasswordEncoder().encode(password);</code>로 암호화 한 패스워드를 저장했기 때문에,<!-- raw HTML omitted -->
회원을 찾을때도 이렇게 하면 되겠다고 생각해서 위와 같은 코드를 작성하였는데,<!-- raw HTML omitted -->
테스트중 계속하여 <code>EntityNotFoundException</code>이 발생하였습니다.</p>
<p>디버깅으로 체크하였더니 <code>String currentPassword = new BCryptPasswordEncoder().encode(request.getCurrentPassword());</code> 부분에서 매번 다른 비밀번호가 currentPassword에 들어갔습니다.</p>
<p>왜 다른 값이 나오는지 알고 싶어 <code>BCryptPasswordEncoder</code> 클래스 파일을 열어보았는데,</p>
<p>encode 부분에서 <code>rawPassword</code> 와 <code>salt</code>값을 생성하여 두개의 값으로 패스워드를 해싱하고 있었습니다.</p>
<p>해당 클래스 파일안에 <code>matches(CharSequence rawPassword, String encodedPassword)</code>라는 함수가 있었고,</p>
<p>클래스의 인터페이스를 확인하였더니,</p>
<pre tabindex="0"><code>/**
 * Verify the encoded password obtained from storage matches the submitted raw
 * password after it too is encoded. Returns true if the passwords match, false if
 * they do not. The stored password itself is never decoded.
 *
 * @param rawPassword the raw password to encode and match
 * @param encodedPassword the encoded password from storage to compare with
 * @return true if the raw password, after encoding, matches the encoded password from
 * storage
 */
boolean matches(CharSequence rawPassword, String encodedPassword);
</code></pre><p>라는 주석을 확인하였고, 구현체가 아닌 인터페이스를 사용하고자
<code>org.springframework.security.crypto.password.PasswordEncoder</code> 를 의존성 주입하여,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">final</span> <span class="n">User</span> <span class="n">persistUser</span> <span class="o">=</span> <span class="n">userRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">userId</span><span class="o">)</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">EntityNotFoundException</span><span class="o">(</span><span class="s">&#34;회원정보를 찾을 수 없습니다.&#34;</span><span class="o">));</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="o">(!</span><span class="n">passwordEncoder</span>
</span></span><span class="line"><span class="cl">                <span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">request</span><span class="o">.</span><span class="na">getCurrentPassword</span><span class="o">(),</span> <span class="n">persistUser</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()))</span> <span class="o">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">logger</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">&#34;changePassword is Not Equal Current Password&#34;</span><span class="o">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="n">ResponseEntity</span><span class="o">&lt;&gt;(</span><span class="n">UserRegisterResult</span><span class="o">.</span><span class="na">ERROR</span><span class="o">.</span><span class="na">getResponseBody</span><span class="o">(),</span>
</span></span><span class="line"><span class="cl">            <span class="n">HttpStatus</span><span class="o">.</span><span class="na">FORBIDDEN</span><span class="o">);</span>
</span></span><span class="line"><span class="cl"><span class="o">}</span>
</span></span></code></pre></div><p>이와 같이 수정하였고, 기대했던 결과대로 수행되었습니다.</p>
<p>아직 자바와 스프링이 많이 서툴러서 코드를 작성하는 시간보다 검색해보는 시간이 많아 더 어려운거 같습니다.</p>
<p>잘못된 부분이 있다면 코멘트 부탁드리겠습니다.</p>
]]></description></item></channel></rss>